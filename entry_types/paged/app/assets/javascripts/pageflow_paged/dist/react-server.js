this.pageflow = this.pageflow || {};
this.pageflow.react = (function (React$1, Backbone, ReactDOM, Wavesurfer, pageflow$1) {
	'use strict';

	var React$1__default = 'default' in React$1 ? React$1['default'] : React$1;
	Backbone = Backbone && Backbone.hasOwnProperty('default') ? Backbone['default'] : Backbone;
	ReactDOM = ReactDOM && ReactDOM.hasOwnProperty('default') ? ReactDOM['default'] : ReactDOM;
	Wavesurfer = Wavesurfer && Wavesurfer.hasOwnProperty('default') ? Wavesurfer['default'] : Wavesurfer;
	pageflow$1 = pageflow$1 && pageflow$1.hasOwnProperty('default') ? pageflow$1['default'] : pageflow$1;

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var check = function check(it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	// eslint-disable-next-line no-undef
	check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	// eslint-disable-next-line no-new-func
	Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Thank's IE8 for his funny defineProperty
	var descriptors = !fails(function () {
	  return Object.defineProperty({}, 1, {
	    get: function get() {
	      return 7;
	    }
	  })[1] != 7;
	});

	var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
	  1: 2
	}, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
	var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : nativePropertyIsEnumerable;

	var objectPropertyIsEnumerable = {
		f: f
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString = {}.toString;
	var classofRaw = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var split = ''.split;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings


	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// `ToPrimitive` abstract operation
	// https://tc39.github.io/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject(input)) return input;
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var hasOwnProperty = {}.hasOwnProperty;
	var has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var document$1 = global_1.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS = isObject(document$1) && isObject(document$1.createElement);
	var documentCreateElement = function (it) {
	  return EXISTS ? document$1.createElement(it) : {};
	};

	// Thank's IE8 for his funny defineProperty
	var ie8DomDefine = !descriptors && !fails(function () {
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function get() {
	      return 7;
	    }
	  }).a != 7;
	});

	var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) try {
	    return nativeGetOwnPropertyDescriptor(O, P);
	  } catch (error) {/* empty */}
	  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$1
	};

	var anObject = function (it) {
	  if (!isObject(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  }
	  return it;
	};

	var nativeDefineProperty = Object.defineProperty;

	// `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty
	var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return nativeDefineProperty(O, P, Attributes);
	  } catch (error) {/* empty */}
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$2
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  }
	  return value;
	};

	var SHARED = '__core-js_shared__';
	var store = global_1[SHARED] || setGlobal(SHARED, {});
	var sharedStore = store;

	var functionToString = Function.toString;

	// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
	if (typeof sharedStore.inspectSource != 'function') {
	  sharedStore.inspectSource = function (it) {
	    return functionToString.call(it);
	  };
	}
	var inspectSource = sharedStore.inspectSource;

	var WeakMap$1 = global_1.WeakMap;
	var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource(WeakMap$1));

	var isPure = false;

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.6.5',
	  mode:  'global',
	  copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var postfix = Math.random();
	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
	};

	var keys = shared('keys');
	var sharedKey = function (key) {
	  return keys[key] || (keys[key] = uid(key));
	};

	var hiddenKeys = {};

	var WeakMap$2 = global_1.WeakMap;
	var set, get, has$1;
	var enforce = function enforce(it) {
	  return has$1(it) ? get(it) : set(it, {});
	};
	var getterFor = function getterFor(TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    }
	    return state;
	  };
	};
	if (nativeWeakMap) {
	  var store$1 = new WeakMap$2();
	  var wmget = store$1.get;
	  var wmhas = store$1.has;
	  var wmset = store$1.set;
	  set = function set(it, metadata) {
	    wmset.call(store$1, it, metadata);
	    return metadata;
	  };
	  get = function get(it) {
	    return wmget.call(store$1, it) || {};
	  };
	  has$1 = function has(it) {
	    return wmhas.call(store$1, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;
	  set = function set(it, metadata) {
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get = function get(it) {
	    return has(it, STATE) ? it[STATE] : {};
	  };
	  has$1 = function has$1(it) {
	    return has(it, STATE);
	  };
	}
	var internalState = {
	  set: set,
	  get: get,
	  has: has$1,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var redefine = createCommonjsModule(function (module) {
	var getInternalState = internalState.get;
	var enforceInternalState = internalState.enforce;
	var TEMPLATE = String(String).split('String');
	(module.exports = function (O, key, value, options) {
	  var unsafe = options ? !!options.unsafe : false;
	  var simple = options ? !!options.enumerable : false;
	  var noTargetGet = options ? !!options.noTargetGet : false;
	  if (typeof value == 'function') {
	    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
	    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
	  }
	  if (O === global_1) {
	    if (simple) O[key] = value;else setGlobal(key, value);
	    return;
	  } else if (!unsafe) {
	    delete O[key];
	  } else if (!noTargetGet && O[key]) {
	    simple = true;
	  }
	  if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value);
	  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, 'toString', function toString() {
	  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
	});
	});

	var path = global_1;

	var aFunction = function aFunction(variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};
	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var ceil = Math.ceil;
	var floor = Math.floor;

	// `ToInteger` abstract operation
	// https://tc39.github.io/ecma262/#sec-tointeger
	var toInteger = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
	};

	var min = Math.min;

	// `ToLength` abstract operation
	// https://tc39.github.io/ecma262/#sec-tolength
	var toLength = function (argument) {
	  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger(index);
	  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod = function createMethod(IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	      // Array#indexOf ignores holes, Array#includes - not
	    } else for (; length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    }
	    return !IS_INCLUDES && -1;
	  };
	};
	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
	  includes: createMethod(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod(false)
	};

	var indexOf = arrayIncludes.indexOf;

	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~indexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

	var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys$1);
	};

	var objectGetOwnPropertyNames = {
		f: f$3
	};

	var f$4 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$4
	};

	// all object keys, includes non-enumerable and symbols
	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
	};

	var copyConstructorProperties = function (target, source) {
	  var keys = ownKeys(source);
	  var defineProperty = objectDefineProperty.f;
	  var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
	  }
	};

	var replacement = /#|\.prototype\./;
	var isForced = function isForced(feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
	};
	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};
	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';
	var isForced_1 = isForced;

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
	  if (GLOBAL) {
	    target = global_1;
	  } else if (STATIC) {
	    target = global_1[TARGET] || setGlobal(TARGET, {});
	  } else {
	    target = (global_1[TARGET] || {}).prototype;
	  }
	  if (target) for (key in source) {
	    sourceProperty = source[key];
	    if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(target, key);
	      targetProperty = descriptor && descriptor.value;
	    } else targetProperty = target[key];
	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contained in target
	    if (!FORCED && targetProperty !== undefined) {
	      if (typeof sourceProperty === typeof targetProperty) continue;
	      copyConstructorProperties(sourceProperty, targetProperty);
	    }
	    // add a flag to not completely full polyfills
	    if (options.sham || targetProperty && targetProperty.sham) {
	      createNonEnumerableProperty(sourceProperty, 'sham', true);
	    }
	    // extend global
	    redefine(target, key, sourceProperty, options);
	  }
	};

	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  // Chrome 38 Symbol has incorrect toString conversion
	  // eslint-disable-next-line no-undef
	  return !String(Symbol());
	});

	var useSymbolAsUid = nativeSymbol
	// eslint-disable-next-line no-undef
	&& !Symbol.sham
	// eslint-disable-next-line no-undef
	&& typeof Symbol.iterator == 'symbol';

	// `IsArray` abstract operation
	// https://tc39.github.io/ecma262/#sec-isarray
	var isArray = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	// `ToObject` abstract operation
	// https://tc39.github.io/ecma262/#sec-toobject
	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `Object.defineProperties` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperties
	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
	  return O;
	};

	var html = getBuiltIn('document', 'documentElement');

	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey('IE_PROTO');
	var EmptyConstructor = function EmptyConstructor() {/* empty */};
	var scriptTag = function scriptTag(content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX(activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame() {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var _NullProtoObject = function NullProtoObject() {
	  try {
	    /* global ActiveXObject */
	    activeXDocument = document.domain && new ActiveXObject('htmlfile');
	  } catch (error) {/* ignore */}
	  _NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
	  var length = enumBugKeys.length;
	  while (length--) delete _NullProtoObject[PROTOTYPE][enumBugKeys[length]];
	  return _NullProtoObject();
	};
	hiddenKeys[IE_PROTO] = true;

	// `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = _NullProtoObject();
	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;
	var toString$1 = {}.toString;
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
	var getWindowNames = function getWindowNames(it) {
	  try {
	    return nativeGetOwnPropertyNames(it);
	  } catch (error) {
	    return windowNames.slice();
	  }
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var f$5 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
	};

	var objectGetOwnPropertyNamesExternal = {
		f: f$5
	};

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$1 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;
	var wellKnownSymbol = function (name) {
	  if (!has(WellKnownSymbolsStore, name)) {
	    if (nativeSymbol && has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
	  }
	  return WellKnownSymbolsStore[name];
	};

	var f$6 = wellKnownSymbol;

	var wellKnownSymbolWrapped = {
		f: f$6
	};

	var defineProperty = objectDefineProperty.f;
	var defineWellKnownSymbol = function (NAME) {
	  var Symbol = path.Symbol || (path.Symbol = {});
	  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
	    value: wellKnownSymbolWrapped.f(NAME)
	  });
	};

	var defineProperty$1 = objectDefineProperty.f;


	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var setToStringTag = function (it, TAG, STATIC) {
	  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
	    defineProperty$1(it, TO_STRING_TAG, {
	      configurable: true,
	      value: TAG
	    });
	  }
	};

	var aFunction$1 = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  }
	  return it;
	};

	// optional / simple context binding
	var functionBindContext = function (fn, that, length) {
	  aFunction$1(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 0:
	      return function () {
	        return fn.call(that);
	      };
	    case 1:
	      return function (a) {
	        return fn.call(that, a);
	      };
	    case 2:
	      return function (a, b) {
	        return fn.call(that, a, b);
	      };
	    case 3:
	      return function (a, b, c) {
	        return fn.call(that, a, b, c);
	      };
	  }
	  return function /* ...args */
	  () {
	    return fn.apply(that, arguments);
	  };
	};

	var SPECIES = wellKnownSymbol('species');

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate = function (originalArray, length) {
	  var C;
	  if (isArray(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
	      C = C[SPECIES];
	      if (C === null) C = undefined;
	    }
	  }
	  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push;

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
	var createMethod$1 = function createMethod(TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
	    var value, result;
	    for (; length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	          case 3:
	            return true;
	          // some
	          case 5:
	            return value;
	          // find
	          case 6:
	            return index;
	          // findIndex
	          case 2:
	            push.call(target, value);
	          // filter
	        } else if (IS_EVERY) return false; // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};
	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$1(0),
	  // `Array.prototype.map` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.map
	  map: createMethod$1(1),
	  // `Array.prototype.filter` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
	  filter: createMethod$1(2),
	  // `Array.prototype.some` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.some
	  some: createMethod$1(3),
	  // `Array.prototype.every` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.every
	  every: createMethod$1(4),
	  // `Array.prototype.find` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.find
	  find: createMethod$1(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$1(6)
	};

	var $forEach = arrayIteration.forEach;
	var HIDDEN = sharedKey('hidden');
	var SYMBOL = 'Symbol';
	var PROTOTYPE$1 = 'prototype';
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	var setInternalState = internalState.set;
	var getInternalState = internalState.getterFor(SYMBOL);
	var ObjectPrototype = Object[PROTOTYPE$1];
	var $Symbol = global_1.Symbol;
	var $stringify = getBuiltIn('JSON', 'stringify');
	var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
	var nativeDefineProperty$1 = objectDefineProperty.f;
	var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
	var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
	var AllSymbols = shared('symbols');
	var ObjectPrototypeSymbols = shared('op-symbols');
	var StringToSymbolRegistry = shared('string-to-symbol-registry');
	var SymbolToStringRegistry = shared('symbol-to-string-registry');
	var WellKnownSymbolsStore$1 = shared('wks');
	var QObject = global_1.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDescriptor = descriptors && fails(function () {
	  return objectCreate(nativeDefineProperty$1({}, 'a', {
	    get: function get() {
	      return nativeDefineProperty$1(this, 'a', {
	        value: 7
	      }).a;
	    }
	  })).a != 7;
	}) ? function (O, P, Attributes) {
	  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype, P);
	  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
	  nativeDefineProperty$1(O, P, Attributes);
	  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
	    nativeDefineProperty$1(ObjectPrototype, P, ObjectPrototypeDescriptor);
	  }
	} : nativeDefineProperty$1;
	var wrap = function wrap(tag, description) {
	  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
	  setInternalState(symbol, {
	    type: SYMBOL,
	    tag: tag,
	    description: description
	  });
	  if (!descriptors) symbol.description = description;
	  return symbol;
	};
	var isSymbol = useSymbolAsUid ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return Object(it) instanceof $Symbol;
	};
	var $defineProperty = function defineProperty(O, P, Attributes) {
	  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
	  anObject(O);
	  var key = toPrimitive(P, true);
	  anObject(Attributes);
	  if (has(AllSymbols, key)) {
	    if (!Attributes.enumerable) {
	      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
	      O[HIDDEN][key] = true;
	    } else {
	      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
	      Attributes = objectCreate(Attributes, {
	        enumerable: createPropertyDescriptor(0, false)
	      });
	    }
	    return setSymbolDescriptor(O, key, Attributes);
	  }
	  return nativeDefineProperty$1(O, key, Attributes);
	};
	var $defineProperties = function defineProperties(O, Properties) {
	  anObject(O);
	  var properties = toIndexedObject(Properties);
	  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
	  $forEach(keys, function (key) {
	    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
	  });
	  return O;
	};
	var $create = function create(O, Properties) {
	  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(V) {
	  var P = toPrimitive(V, true);
	  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
	  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
	  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
	  var it = toIndexedObject(O);
	  var key = toPrimitive(P, true);
	  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
	  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);
	  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
	    descriptor.enumerable = true;
	  }
	  return descriptor;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(O) {
	  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
	  });
	  return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
	  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
	  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
	  var result = [];
	  $forEach(names, function (key) {
	    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
	      result.push(AllSymbols[key]);
	    }
	  });
	  return result;
	};

	// `Symbol` constructor
	// https://tc39.github.io/ecma262/#sec-symbol-constructor
	if (!nativeSymbol) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
	    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var tag = uid(description);
	    var setter = function setter(value) {
	      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
	    };
	    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
	      configurable: true,
	      set: setter
	    });
	    return wrap(tag, description);
	  };
	  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
	    return getInternalState(this).tag;
	  });
	  redefine($Symbol, 'withoutSetter', function (description) {
	    return wrap(uid(description), description);
	  });
	  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
	  objectDefineProperty.f = $defineProperty;
	  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
	  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
	  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;
	  wellKnownSymbolWrapped.f = function (name) {
	    return wrap(wellKnownSymbol(name), name);
	  };
	  if (descriptors) {
	    // https://github.com/tc39/proposal-Symbol-description
	    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
	      configurable: true,
	      get: function description() {
	        return getInternalState(this).description;
	      }
	    });
	    {
	      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
	        unsafe: true
	      });
	    }
	  }
	}
	_export({
	  global: true,
	  wrap: true,
	  forced: !nativeSymbol,
	  sham: !nativeSymbol
	}, {
	  Symbol: $Symbol
	});
	$forEach(objectKeys(WellKnownSymbolsStore$1), function (name) {
	  defineWellKnownSymbol(name);
	});
	_export({
	  target: SYMBOL,
	  stat: true,
	  forced: !nativeSymbol
	}, {
	  // `Symbol.for` method
	  // https://tc39.github.io/ecma262/#sec-symbol.for
	  'for': function _for(key) {
	    var string = String(key);
	    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
	    var symbol = $Symbol(string);
	    StringToSymbolRegistry[string] = symbol;
	    SymbolToStringRegistry[symbol] = string;
	    return symbol;
	  },
	  // `Symbol.keyFor` method
	  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
	    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
	  },
	  useSetter: function useSetter() {
	    USE_SETTER = true;
	  },
	  useSimple: function useSimple() {
	    USE_SETTER = false;
	  }
	});
	_export({
	  target: 'Object',
	  stat: true,
	  forced: !nativeSymbol,
	  sham: !descriptors
	}, {
	  // `Object.create` method
	  // https://tc39.github.io/ecma262/#sec-object.create
	  create: $create,
	  // `Object.defineProperty` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperty
	  defineProperty: $defineProperty,
	  // `Object.defineProperties` method
	  // https://tc39.github.io/ecma262/#sec-object.defineproperties
	  defineProperties: $defineProperties,
	  // `Object.getOwnPropertyDescriptor` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
	});
	_export({
	  target: 'Object',
	  stat: true,
	  forced: !nativeSymbol
	}, {
	  // `Object.getOwnPropertyNames` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // `Object.getOwnPropertySymbols` method
	  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443
	_export({
	  target: 'Object',
	  stat: true,
	  forced: fails(function () {
	    objectGetOwnPropertySymbols.f(1);
	  })
	}, {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return objectGetOwnPropertySymbols.f(toObject(it));
	  }
	});

	// `JSON.stringify` method behavior with symbols
	// https://tc39.github.io/ecma262/#sec-json.stringify
	if ($stringify) {
	  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
	    var symbol = $Symbol();
	    // MS Edge converts symbol values to JSON as {}
	    return $stringify([symbol]) != '[null]'
	    // WebKit converts symbol values to JSON as null
	    || $stringify({
	      a: symbol
	    }) != '{}'
	    // V8 throws on boxed symbols
	    || $stringify(Object(symbol)) != '{}';
	  });
	  _export({
	    target: 'JSON',
	    stat: true,
	    forced: FORCED_JSON_STRINGIFY
	  }, {
	    // eslint-disable-next-line no-unused-vars
	    stringify: function stringify(it, replacer, space) {
	      var args = [it];
	      var index = 1;
	      var $replacer;
	      while (arguments.length > index) args.push(arguments[index++]);
	      $replacer = replacer;
	      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	      if (!isArray(replacer)) replacer = function replacer(key, value) {
	        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	        if (!isSymbol(value)) return value;
	      };
	      args[1] = replacer;
	      return $stringify.apply(null, args);
	    }
	  });
	}

	// `Symbol.prototype[@@toPrimitive]` method
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
	if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
	  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
	}
	// `Symbol.prototype[@@toStringTag]` property
	// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
	setToStringTag($Symbol, SYMBOL);
	hiddenKeys[HIDDEN] = true;

	var defineProperty$2 = objectDefineProperty.f;

	var NativeSymbol = global_1.Symbol;
	if (descriptors && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
	// Safari 12 bug
	NativeSymbol().description !== undefined)) {
	  var EmptyStringDescriptionStore = {};
	  // wrap Symbol constructor for correct work with undefined description
	  var SymbolWrapper = function Symbol() {
	    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var result = this instanceof SymbolWrapper ? new NativeSymbol(description)
	    // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
	    : description === undefined ? NativeSymbol() : NativeSymbol(description);
	    if (description === '') EmptyStringDescriptionStore[result] = true;
	    return result;
	  };
	  copyConstructorProperties(SymbolWrapper, NativeSymbol);
	  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
	  symbolPrototype.constructor = SymbolWrapper;
	  var symbolToString = symbolPrototype.toString;
	  var _native = String(NativeSymbol('test')) == 'Symbol(test)';
	  var regexp = /^Symbol\((.*)\)[^)]+$/;
	  defineProperty$2(symbolPrototype, 'description', {
	    configurable: true,
	    get: function description() {
	      var symbol = isObject(this) ? this.valueOf() : this;
	      var string = symbolToString.call(symbol);
	      if (has(EmptyStringDescriptionStore, symbol)) return '';
	      var desc = _native ? string.slice(7, -1) : string.replace(regexp, '$1');
	      return desc === '' ? undefined : desc;
	    }
	  });
	  _export({
	    global: true,
	    forced: true
	  }, {
	    Symbol: SymbolWrapper
	  });
	}

	// `Symbol.asyncIterator` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.asynciterator
	defineWellKnownSymbol('asyncIterator');

	// `Symbol.hasInstance` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.hasinstance
	defineWellKnownSymbol('hasInstance');

	// `Symbol.isConcatSpreadable` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable
	defineWellKnownSymbol('isConcatSpreadable');

	// `Symbol.iterator` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.iterator
	defineWellKnownSymbol('iterator');

	// `Symbol.match` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.match
	defineWellKnownSymbol('match');

	// `Symbol.replace` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.replace
	defineWellKnownSymbol('replace');

	// `Symbol.search` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.search
	defineWellKnownSymbol('search');

	// `Symbol.species` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.species
	defineWellKnownSymbol('species');

	// `Symbol.split` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.split
	defineWellKnownSymbol('split');

	// `Symbol.toPrimitive` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.toprimitive
	defineWellKnownSymbol('toPrimitive');

	// `Symbol.toStringTag` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.tostringtag
	defineWellKnownSymbol('toStringTag');

	// `Symbol.unscopables` well-known symbol
	// https://tc39.github.io/ecma262/#sec-symbol.unscopables
	defineWellKnownSymbol('unscopables');

	var createProperty = function (object, key, value) {
	  var propertyKey = toPrimitive(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
	};

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var process$1 = global_1.process;
	var versions = process$1 && process$1.versions;
	var v8 = versions && versions.v8;
	var match, version;
	if (v8) {
	  match = v8.split('.');
	  version = match[0] + match[1];
	} else if (engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version = match[1];
	  }
	}
	var engineV8Version = version && +version;

	var SPECIES$1 = wellKnownSymbol('species');
	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return engineV8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};
	    constructor[SPECIES$1] = function () {
	      return {
	        foo: 1
	      };
	    };
	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

	// We can't use this feature detection in V8 since it causes
	// deoptimization and serious performance degradation
	// https://github.com/zloirock/core-js/issues/679
	var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
	  var array = [];
	  array[IS_CONCAT_SPREADABLE] = false;
	  return array.concat()[0] !== array;
	});
	var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');
	var isConcatSpreadable = function isConcatSpreadable(O) {
	  if (!isObject(O)) return false;
	  var spreadable = O[IS_CONCAT_SPREADABLE];
	  return spreadable !== undefined ? !!spreadable : isArray(O);
	};
	var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

	// `Array.prototype.concat` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.concat
	// with adding support of @@isConcatSpreadable and @@species
	_export({
	  target: 'Array',
	  proto: true,
	  forced: FORCED
	}, {
	  concat: function concat(arg) {
	    // eslint-disable-line no-unused-vars
	    var O = toObject(this);
	    var A = arraySpeciesCreate(O, 0);
	    var n = 0;
	    var i, k, length, len, E;
	    for (i = -1, length = arguments.length; i < length; i++) {
	      E = i === -1 ? O : arguments[i];
	      if (isConcatSpreadable(E)) {
	        len = toLength(E.length);
	        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
	      } else {
	        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        createProperty(A, n++, E);
	      }
	    }
	    A.length = n;
	    return A;
	  }
	});

	var min$2 = Math.min;

	// `Array.prototype.copyWithin` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
	var arrayCopyWithin = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
	  var O = toObject(this);
	  var len = toLength(O.length);
	  var to = toAbsoluteIndex(target, len);
	  var from = toAbsoluteIndex(start, len);
	  var end = arguments.length > 2 ? arguments[2] : undefined;
	  var count = min$2((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
	  var inc = 1;
	  if (from < to && to < from + count) {
	    inc = -1;
	    from += count - 1;
	    to += count - 1;
	  }
	  while (count-- > 0) {
	    if (from in O) O[to] = O[from];else delete O[to];
	    to += inc;
	    from += inc;
	  }
	  return O;
	};

	var UNSCOPABLES = wellKnownSymbol('unscopables');
	var ArrayPrototype = Array.prototype;

	// Array.prototype[@@unscopables]
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	if (ArrayPrototype[UNSCOPABLES] == undefined) {
	  objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
	    configurable: true,
	    value: objectCreate(null)
	  });
	}

	// add a key to Array.prototype[@@unscopables]
	var addToUnscopables = function (key) {
	  ArrayPrototype[UNSCOPABLES][key] = true;
	};

	// `Array.prototype.copyWithin` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
	_export({
	  target: 'Array',
	  proto: true
	}, {
	  copyWithin: arrayCopyWithin
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('copyWithin');

	var arrayMethodIsStrict = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call,no-throw-literal
	    method.call(null, argument || function () {
	      throw 1;
	    }, 1);
	  });
	};

	var defineProperty$3 = Object.defineProperty;
	var cache = {};
	var thrower = function thrower(it) {
	  throw it;
	};
	var arrayMethodUsesToLength = function (METHOD_NAME, options) {
	  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
	  if (!options) options = {};
	  var method = [][METHOD_NAME];
	  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
	  var argument0 = has(options, 0) ? options[0] : thrower;
	  var argument1 = has(options, 1) ? options[1] : undefined;
	  return cache[METHOD_NAME] = !!method && !fails(function () {
	    if (ACCESSORS && !descriptors) return true;
	    var O = {
	      length: -1
	    };
	    if (ACCESSORS) defineProperty$3(O, 1, {
	      enumerable: true,
	      get: thrower
	    });else O[1] = 1;
	    method.call(O, argument0, argument1);
	  });
	};

	var $every = arrayIteration.every;


	var STRICT_METHOD = arrayMethodIsStrict('every');
	var USES_TO_LENGTH = arrayMethodUsesToLength('every');

	// `Array.prototype.every` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.every
	_export({
	  target: 'Array',
	  proto: true,
	  forced: !STRICT_METHOD || !USES_TO_LENGTH
	}, {
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Array.prototype.fill` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.fill
	var arrayFill = function fill(value /* , start = 0, end = @length */) {
	  var O = toObject(this);
	  var length = toLength(O.length);
	  var argumentsLength = arguments.length;
	  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
	  var end = argumentsLength > 2 ? arguments[2] : undefined;
	  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
	  while (endPos > index) O[index++] = value;
	  return O;
	};

	// `Array.prototype.fill` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.fill
	_export({
	  target: 'Array',
	  proto: true
	}, {
	  fill: arrayFill
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('fill');

	var $filter = arrayIteration.filter;


	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
	// Edge 14- issue
	var USES_TO_LENGTH$1 = arrayMethodUsesToLength('filter');

	// `Array.prototype.filter` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.filter
	// with adding support of @@species
	_export({
	  target: 'Array',
	  proto: true,
	  forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH$1
	}, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $find = arrayIteration.find;


	var FIND = 'find';
	var SKIPS_HOLES = true;
	var USES_TO_LENGTH$2 = arrayMethodUsesToLength(FIND);

	// Shouldn't skip holes
	if (FIND in []) Array(1)[FIND](function () {
	  SKIPS_HOLES = false;
	});

	// `Array.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.find
	_export({
	  target: 'Array',
	  proto: true,
	  forced: SKIPS_HOLES || !USES_TO_LENGTH$2
	}, {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND);

	var $findIndex = arrayIteration.findIndex;


	var FIND_INDEX = 'findIndex';
	var SKIPS_HOLES$1 = true;
	var USES_TO_LENGTH$3 = arrayMethodUsesToLength(FIND_INDEX);

	// Shouldn't skip holes
	if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () {
	  SKIPS_HOLES$1 = false;
	});

	// `Array.prototype.findIndex` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
	_export({
	  target: 'Array',
	  proto: true,
	  forced: SKIPS_HOLES$1 || !USES_TO_LENGTH$3
	}, {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables(FIND_INDEX);

	// `FlattenIntoArray` abstract operation
	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
	var flattenIntoArray = function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? functionBindContext(mapper, thisArg, 3) : false;
	  var element;
	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
	      if (depth > 0 && isArray(element)) {
	        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
	        target[targetIndex] = element;
	      }
	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	};
	var flattenIntoArray_1 = flattenIntoArray;

	// `Array.prototype.flat` method
	// https://github.com/tc39/proposal-flatMap
	_export({
	  target: 'Array',
	  proto: true
	}, {
	  flat: function flat( /* depthArg = 1 */
	  ) {
	    var depthArg = arguments.length ? arguments[0] : undefined;
	    var O = toObject(this);
	    var sourceLen = toLength(O.length);
	    var A = arraySpeciesCreate(O, 0);
	    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
	    return A;
	  }
	});

	// `Array.prototype.flatMap` method
	// https://github.com/tc39/proposal-flatMap
	_export({
	  target: 'Array',
	  proto: true
	}, {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = toObject(this);
	    var sourceLen = toLength(O.length);
	    var A;
	    aFunction$1(callbackfn);
	    A = arraySpeciesCreate(O, 0);
	    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return A;
	  }
	});

	var $forEach$1 = arrayIteration.forEach;


	var STRICT_METHOD$1 = arrayMethodIsStrict('forEach');
	var USES_TO_LENGTH$4 = arrayMethodUsesToLength('forEach');

	// `Array.prototype.forEach` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	var arrayForEach = !STRICT_METHOD$1 || !USES_TO_LENGTH$4 ? function forEach(callbackfn /* , thisArg */) {
	  return $forEach$1(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	} : [].forEach;

	// `Array.prototype.forEach` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
	_export({
	  target: 'Array',
	  proto: true,
	  forced: [].forEach != arrayForEach
	}, {
	  forEach: arrayForEach
	});

	// call something on iterator step with safe closing on error
	var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	    // 7.4.6 IteratorClose(iterator, completion)
	  } catch (error) {
	    var returnMethod = iterator['return'];
	    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
	    throw error;
	  }
	};

	var iterators = {};

	var ITERATOR = wellKnownSymbol('iterator');
	var ArrayPrototype$1 = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR] === it);
	};

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	var test = {};
	test[TO_STRING_TAG$1] = 'z';
	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () {
	  return arguments;
	}()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function tryGet(it, key) {
	  try {
	    return it[key];
	  } catch (error) {/* empty */}
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	  // @@toStringTag case
	  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag
	  // builtinTag case
	  : CORRECT_ARGUMENTS ? classofRaw(O)
	  // ES3 arguments fallback
	  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	var ITERATOR$1 = wellKnownSymbol('iterator');
	var getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$1] || it['@@iterator'] || iterators[classof(it)];
	};

	// `Array.from` method implementation
	// https://tc39.github.io/ecma262/#sec-array.from
	var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	  var O = toObject(arrayLike);
	  var C = typeof this == 'function' ? this : Array;
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var index = 0;
	  var length, result, step, iterator, next, value;
	  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
	  // if the target is not iterable or it's an array with the default iterator - use a simple case
	  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    result = new C();
	    for (; !(step = next.call(iterator)).done; index++) {
	      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
	      createProperty(result, index, value);
	    }
	  } else {
	    length = toLength(O.length);
	    result = new C(length);
	    for (; length > index; index++) {
	      value = mapping ? mapfn(O[index], index) : O[index];
	      createProperty(result, index, value);
	    }
	  }
	  result.length = index;
	  return result;
	};

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;
	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function next() {
	      return {
	        done: !!called++
	      };
	    },
	    'return': function _return() {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR$2] = function () {
	    return this;
	  };
	  // eslint-disable-next-line no-throw-literal
	  Array.from(iteratorWithReturn, function () {
	    throw 2;
	  });
	} catch (error) {/* empty */}
	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR$2] = function () {
	      return {
	        next: function next() {
	          return {
	            done: ITERATION_SUPPORT = true
	          };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) {/* empty */}
	  return ITERATION_SUPPORT;
	};

	var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
	  Array.from(iterable);
	});

	// `Array.from` method
	// https://tc39.github.io/ecma262/#sec-array.from
	_export({
	  target: 'Array',
	  stat: true,
	  forced: INCORRECT_ITERATION
	}, {
	  from: arrayFrom
	});

	var $includes = arrayIncludes.includes;


	var USES_TO_LENGTH$5 = arrayMethodUsesToLength('indexOf', {
	  ACCESSORS: true,
	  1: 0
	});

	// `Array.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.includes
	_export({
	  target: 'Array',
	  proto: true,
	  forced: !USES_TO_LENGTH$5
	}, {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('includes');

	var $indexOf = arrayIncludes.indexOf;


	var nativeIndexOf = [].indexOf;
	var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
	var STRICT_METHOD$2 = arrayMethodIsStrict('indexOf');
	var USES_TO_LENGTH$6 = arrayMethodUsesToLength('indexOf', {
	  ACCESSORS: true,
	  1: 0
	});

	// `Array.prototype.indexOf` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
	_export({
	  target: 'Array',
	  proto: true,
	  forced: NEGATIVE_ZERO || !STRICT_METHOD$2 || !USES_TO_LENGTH$6
	}, {
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	    // convert -0 to +0
	    ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `Array.isArray` method
	// https://tc39.github.io/ecma262/#sec-array.isarray
	_export({
	  target: 'Array',
	  stat: true
	}, {
	  isArray: isArray
	});

	var correctPrototypeGetter = !fails(function () {
	  function F() {/* empty */}
	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO$1 = sharedKey('IE_PROTO');
	var ObjectPrototype$1 = Object.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof
	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  }
	  return O instanceof Object ? ObjectPrototype$1 : null;
	};

	var ITERATOR$3 = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false;
	var returnThis = function returnThis() {
	  return this;
	};

	// `%IteratorPrototype%` object
	// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
	  }
	}
	if (IteratorPrototype == undefined) IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	if ( !has(IteratorPrototype, ITERATOR$3)) {
	  createNonEnumerableProperty(IteratorPrototype, ITERATOR$3, returnThis);
	}
	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;




	var returnThis$1 = function returnThis() {
	  return this;
	};
	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
	    next: createPropertyDescriptor(1, next)
	  });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var aPossiblePrototype = function (it) {
	  if (!isObject(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  }
	  return it;
	};

	// `Object.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) {/* empty */}
	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$4 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';
	var returnThis$2 = function returnThis() {
	  return this;
	};
	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);
	  var getIterationMethod = function getIterationMethod(KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS:
	        return function keys() {
	          return new IteratorConstructor(this, KIND);
	        };
	      case VALUES:
	        return function values() {
	          return new IteratorConstructor(this, KIND);
	        };
	      case ENTRIES:
	        return function entries() {
	          return new IteratorConstructor(this, KIND);
	        };
	    }
	    return function () {
	      return new IteratorConstructor(this);
	    };
	  };
	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$4] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
	      if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
	        if (objectSetPrototypeOf) {
	          objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
	        } else if (typeof CurrentIteratorPrototype[ITERATOR$4] != 'function') {
	          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$4, returnThis$2);
	        }
	      }
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
	    }
	  }

	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;
	    defaultIterator = function values() {
	      return nativeIterator.call(this);
	    };
	  }

	  // define iterator
	  if ( IterablePrototype[ITERATOR$4] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR$4, defaultIterator);
	  }
	  iterators[NAME] = defaultIterator;

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({
	      target: NAME,
	      proto: true,
	      forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
	    }, methods);
	  }
	  return methods;
	};

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$1 = internalState.set;
	var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.github.io/ecma262/#sec-createarrayiterator
	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$1(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated),
	    // target
	    index: 0,
	    // next index
	    kind: kind // kind
	  });
	  // `%ArrayIteratorPrototype%.next` method
	  // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$1(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return {
	      value: undefined,
	      done: true
	    };
	  }
	  if (kind == 'keys') return {
	    value: index,
	    done: false
	  };
	  if (kind == 'values') return {
	    value: target[index],
	    done: false
	  };
	  return {
	    value: [index, target[index]],
	    done: false
	  };
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
	iterators.Arguments = iterators.Array;

	// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

	var nativeJoin = [].join;
	var ES3_STRINGS = indexedObject != Object;
	var STRICT_METHOD$3 = arrayMethodIsStrict('join', ',');

	// `Array.prototype.join` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.join
	_export({
	  target: 'Array',
	  proto: true,
	  forced: ES3_STRINGS || !STRICT_METHOD$3
	}, {
	  join: function join(separator) {
	    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
	  }
	});

	var min$3 = Math.min;
	var nativeLastIndexOf = [].lastIndexOf;
	var NEGATIVE_ZERO$1 = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
	var STRICT_METHOD$4 = arrayMethodIsStrict('lastIndexOf');
	// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
	var USES_TO_LENGTH$7 = arrayMethodUsesToLength('indexOf', {
	  ACCESSORS: true,
	  1: 0
	});
	var FORCED$1 = NEGATIVE_ZERO$1 || !STRICT_METHOD$4 || !USES_TO_LENGTH$7;

	// `Array.prototype.lastIndexOf` method implementation
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
	var arrayLastIndexOf = FORCED$1 ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
	  // convert -0 to +0
	  if (NEGATIVE_ZERO$1) return nativeLastIndexOf.apply(this, arguments) || 0;
	  var O = toIndexedObject(this);
	  var length = toLength(O.length);
	  var index = length - 1;
	  if (arguments.length > 1) index = min$3(index, toInteger(arguments[1]));
	  if (index < 0) index = length + index;
	  for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
	  return -1;
	} : nativeLastIndexOf;

	// `Array.prototype.lastIndexOf` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
	_export({
	  target: 'Array',
	  proto: true,
	  forced: arrayLastIndexOf !== [].lastIndexOf
	}, {
	  lastIndexOf: arrayLastIndexOf
	});

	var $map = arrayIteration.map;


	var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('map');
	// FF49- issue
	var USES_TO_LENGTH$8 = arrayMethodUsesToLength('map');

	// `Array.prototype.map` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.map
	// with adding support of @@species
	_export({
	  target: 'Array',
	  proto: true,
	  forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$8
	}, {
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var ISNT_GENERIC = fails(function () {
	  function F() {/* empty */}
	  return !(Array.of.call(F) instanceof F);
	});

	// `Array.of` method
	// https://tc39.github.io/ecma262/#sec-array.of
	// WebKit Array.of isn't generic
	_export({
	  target: 'Array',
	  stat: true,
	  forced: ISNT_GENERIC
	}, {
	  of: function of( /* ...args */
	  ) {
	    var index = 0;
	    var argumentsLength = arguments.length;
	    var result = new (typeof this == 'function' ? this : Array)(argumentsLength);
	    while (argumentsLength > index) createProperty(result, index, arguments[index++]);
	    result.length = argumentsLength;
	    return result;
	  }
	});

	// `Array.prototype.{ reduce, reduceRight }` methods implementation
	var createMethod$2 = function createMethod(IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aFunction$1(callbackfn);
	    var O = toObject(that);
	    var self = indexedObject(O);
	    var length = toLength(O.length);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }
	      index += i;
	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError('Reduce of empty array with no initial value');
	      }
	    }
	    for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	    return memo;
	  };
	};
	var arrayReduce = {
	  // `Array.prototype.reduce` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	  left: createMethod$2(false),
	  // `Array.prototype.reduceRight` method
	  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
	  right: createMethod$2(true)
	};

	var $reduce = arrayReduce.left;


	var STRICT_METHOD$5 = arrayMethodIsStrict('reduce');
	var USES_TO_LENGTH$9 = arrayMethodUsesToLength('reduce', {
	  1: 0
	});

	// `Array.prototype.reduce` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
	_export({
	  target: 'Array',
	  proto: true,
	  forced: !STRICT_METHOD$5 || !USES_TO_LENGTH$9
	}, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $reduceRight = arrayReduce.right;


	var STRICT_METHOD$6 = arrayMethodIsStrict('reduceRight');
	// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
	var USES_TO_LENGTH$a = arrayMethodUsesToLength('reduce', {
	  1: 0
	});

	// `Array.prototype.reduceRight` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
	_export({
	  target: 'Array',
	  proto: true,
	  forced: !STRICT_METHOD$6 || !USES_TO_LENGTH$a
	}, {
	  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
	    return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var nativeReverse = [].reverse;
	var test$1 = [1, 2];

	// `Array.prototype.reverse` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.reverse
	// fix for Safari 12.0 bug
	// https://bugs.webkit.org/show_bug.cgi?id=188794
	_export({
	  target: 'Array',
	  proto: true,
	  forced: String(test$1) === String(test$1.reverse())
	}, {
	  reverse: function reverse() {
	    // eslint-disable-next-line no-self-assign
	    if (isArray(this)) this.length = this.length;
	    return nativeReverse.call(this);
	  }
	});

	var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('slice');
	var USES_TO_LENGTH$b = arrayMethodUsesToLength('slice', {
	  ACCESSORS: true,
	  0: 0,
	  1: 2
	});
	var SPECIES$2 = wellKnownSymbol('species');
	var nativeSlice = [].slice;
	var max$1 = Math.max;

	// `Array.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.slice
	// fallback for not array-like ES3 strings and DOM objects
	_export({
	  target: 'Array',
	  proto: true,
	  forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$b
	}, {
	  slice: function slice(start, end) {
	    var O = toIndexedObject(this);
	    var length = toLength(O.length);
	    var k = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
	    var Constructor, result, n;
	    if (isArray(O)) {
	      Constructor = O.constructor;
	      // cross-realm fallback
	      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
	        Constructor = undefined;
	      } else if (isObject(Constructor)) {
	        Constructor = Constructor[SPECIES$2];
	        if (Constructor === null) Constructor = undefined;
	      }
	      if (Constructor === Array || Constructor === undefined) {
	        return nativeSlice.call(O, k, fin);
	      }
	    }
	    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));
	    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
	    result.length = n;
	    return result;
	  }
	});

	var $some = arrayIteration.some;


	var STRICT_METHOD$7 = arrayMethodIsStrict('some');
	var USES_TO_LENGTH$c = arrayMethodUsesToLength('some');

	// `Array.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.some
	_export({
	  target: 'Array',
	  proto: true,
	  forced: !STRICT_METHOD$7 || !USES_TO_LENGTH$c
	}, {
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var test$2 = [];
	var nativeSort = test$2.sort;

	// IE8-
	var FAILS_ON_UNDEFINED = fails(function () {
	  test$2.sort(undefined);
	});
	// V8 bug
	var FAILS_ON_NULL = fails(function () {
	  test$2.sort(null);
	});
	// Old WebKit
	var STRICT_METHOD$8 = arrayMethodIsStrict('sort');
	var FORCED$2 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$8;

	// `Array.prototype.sort` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.sort
	_export({
	  target: 'Array',
	  proto: true,
	  forced: FORCED$2
	}, {
	  sort: function sort(comparefn) {
	    return comparefn === undefined ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction$1(comparefn));
	  }
	});

	var SPECIES$3 = wellKnownSymbol('species');
	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;
	  if (descriptors && Constructor && !Constructor[SPECIES$3]) {
	    defineProperty(Constructor, SPECIES$3, {
	      configurable: true,
	      get: function get() {
	        return this;
	      }
	    });
	  }
	};

	// `Array[@@species]` getter
	// https://tc39.github.io/ecma262/#sec-get-array-@@species
	setSpecies('Array');

	var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('splice');
	var USES_TO_LENGTH$d = arrayMethodUsesToLength('splice', {
	  ACCESSORS: true,
	  0: 0,
	  1: 2
	});
	var max$2 = Math.max;
	var min$4 = Math.min;
	var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

	// `Array.prototype.splice` method
	// https://tc39.github.io/ecma262/#sec-array.prototype.splice
	// with adding support of @@species
	_export({
	  target: 'Array',
	  proto: true,
	  forced: !HAS_SPECIES_SUPPORT$3 || !USES_TO_LENGTH$d
	}, {
	  splice: function splice(start, deleteCount /* , ...items */) {
	    var O = toObject(this);
	    var len = toLength(O.length);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;
	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min$4(max$2(toInteger(deleteCount), 0), len - actualStart);
	    }
	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
	      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }
	    A = arraySpeciesCreate(O, actualDeleteCount);
	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) createProperty(A, k, O[from]);
	    }
	    A.length = actualDeleteCount;
	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) O[to] = O[from];else delete O[to];
	      }
	      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) O[to] = O[from];else delete O[to];
	      }
	    }
	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments[k + 2];
	    }
	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	// this method was added to unscopables after implementation
	// in popular engines, so it's moved to a separate module

	addToUnscopables('flat');

	// this method was added to unscopables after implementation
	// in popular engines, so it's moved to a separate module

	addToUnscopables('flatMap');

	var arrayBufferNative = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

	var redefineAll = function (target, src, options) {
	  for (var key in src) redefine(target, key, src[key], options);
	  return target;
	};

	var anInstance = function (it, Constructor, name) {
	  if (!(it instanceof Constructor)) {
	    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
	  }
	  return it;
	};

	// `ToIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-toindex
	var toIndex = function (it) {
	  if (it === undefined) return 0;
	  var number = toInteger(it);
	  var length = toLength(number);
	  if (number !== length) throw RangeError('Wrong length or index');
	  return length;
	};

	// IEEE754 conversions based on https://github.com/feross/ieee754
	// eslint-disable-next-line no-shadow-restricted-names
	var Infinity$1 = 1 / 0;
	var abs = Math.abs;
	var pow = Math.pow;
	var floor$1 = Math.floor;
	var log = Math.log;
	var LN2 = Math.LN2;
	var pack = function pack(number, mantissaLength, bytes) {
	  var buffer = new Array(bytes);
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
	  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
	  var index = 0;
	  var exponent, mantissa, c;
	  number = abs(number);
	  // eslint-disable-next-line no-self-compare
	  if (number != number || number === Infinity$1) {
	    // eslint-disable-next-line no-self-compare
	    mantissa = number != number ? 1 : 0;
	    exponent = eMax;
	  } else {
	    exponent = floor$1(log(number) / LN2);
	    if (number * (c = pow(2, -exponent)) < 1) {
	      exponent--;
	      c *= 2;
	    }
	    if (exponent + eBias >= 1) {
	      number += rt / c;
	    } else {
	      number += rt * pow(2, 1 - eBias);
	    }
	    if (number * c >= 2) {
	      exponent++;
	      c /= 2;
	    }
	    if (exponent + eBias >= eMax) {
	      mantissa = 0;
	      exponent = eMax;
	    } else if (exponent + eBias >= 1) {
	      mantissa = (number * c - 1) * pow(2, mantissaLength);
	      exponent = exponent + eBias;
	    } else {
	      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
	      exponent = 0;
	    }
	  }
	  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
	  exponent = exponent << mantissaLength | mantissa;
	  exponentLength += mantissaLength;
	  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
	  buffer[--index] |= sign * 128;
	  return buffer;
	};
	var unpack = function unpack(buffer, mantissaLength) {
	  var bytes = buffer.length;
	  var exponentLength = bytes * 8 - mantissaLength - 1;
	  var eMax = (1 << exponentLength) - 1;
	  var eBias = eMax >> 1;
	  var nBits = exponentLength - 7;
	  var index = bytes - 1;
	  var sign = buffer[index--];
	  var exponent = sign & 127;
	  var mantissa;
	  sign >>= 7;
	  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
	  mantissa = exponent & (1 << -nBits) - 1;
	  exponent >>= -nBits;
	  nBits += mantissaLength;
	  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
	  if (exponent === 0) {
	    exponent = 1 - eBias;
	  } else if (exponent === eMax) {
	    return mantissa ? NaN : sign ? -Infinity$1 : Infinity$1;
	  } else {
	    mantissa = mantissa + pow(2, mantissaLength);
	    exponent = exponent - eBias;
	  }
	  return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
	};
	var ieee754 = {
	  pack: pack,
	  unpack: unpack
	};

	var getOwnPropertyNames = objectGetOwnPropertyNames.f;
	var defineProperty$4 = objectDefineProperty.f;



	var getInternalState$2 = internalState.get;
	var setInternalState$2 = internalState.set;
	var ARRAY_BUFFER = 'ArrayBuffer';
	var DATA_VIEW = 'DataView';
	var PROTOTYPE$2 = 'prototype';
	var WRONG_LENGTH = 'Wrong length';
	var WRONG_INDEX = 'Wrong index';
	var NativeArrayBuffer = global_1[ARRAY_BUFFER];
	var $ArrayBuffer = NativeArrayBuffer;
	var $DataView = global_1[DATA_VIEW];
	var $DataViewPrototype = $DataView && $DataView[PROTOTYPE$2];
	var ObjectPrototype$2 = Object.prototype;
	var RangeError$1 = global_1.RangeError;
	var packIEEE754 = ieee754.pack;
	var unpackIEEE754 = ieee754.unpack;
	var packInt8 = function packInt8(number) {
	  return [number & 0xFF];
	};
	var packInt16 = function packInt16(number) {
	  return [number & 0xFF, number >> 8 & 0xFF];
	};
	var packInt32 = function packInt32(number) {
	  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
	};
	var unpackInt32 = function unpackInt32(buffer) {
	  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
	};
	var packFloat32 = function packFloat32(number) {
	  return packIEEE754(number, 23, 4);
	};
	var packFloat64 = function packFloat64(number) {
	  return packIEEE754(number, 52, 8);
	};
	var addGetter = function addGetter(Constructor, key) {
	  defineProperty$4(Constructor[PROTOTYPE$2], key, {
	    get: function get() {
	      return getInternalState$2(this)[key];
	    }
	  });
	};
	var get$1 = function get(view, count, index, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$2(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState$2(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = bytes.slice(start, start + count);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set$1 = function set(view, count, index, conversion, value, isLittleEndian) {
	  var intIndex = toIndex(index);
	  var store = getInternalState$2(view);
	  if (intIndex + count > store.byteLength) throw RangeError$1(WRONG_INDEX);
	  var bytes = getInternalState$2(store.buffer).bytes;
	  var start = intIndex + store.byteOffset;
	  var pack = conversion(+value);
	  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
	};
	if (!arrayBufferNative) {
	  $ArrayBuffer = function ArrayBuffer(length) {
	    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
	    var byteLength = toIndex(length);
	    setInternalState$2(this, {
	      bytes: arrayFill.call(new Array(byteLength), 0),
	      byteLength: byteLength
	    });
	    if (!descriptors) this.byteLength = byteLength;
	  };
	  $DataView = function DataView(buffer, byteOffset, byteLength) {
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = getInternalState$2(buffer).byteLength;
	    var offset = toInteger(byteOffset);
	    if (offset < 0 || offset > bufferLength) throw RangeError$1('Wrong offset');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if (offset + byteLength > bufferLength) throw RangeError$1(WRONG_LENGTH);
	    setInternalState$2(this, {
	      buffer: buffer,
	      byteLength: byteLength,
	      byteOffset: offset
	    });
	    if (!descriptors) {
	      this.buffer = buffer;
	      this.byteLength = byteLength;
	      this.byteOffset = offset;
	    }
	  };
	  if (descriptors) {
	    addGetter($ArrayBuffer, 'byteLength');
	    addGetter($DataView, 'buffer');
	    addGetter($DataView, 'byteLength');
	    addGetter($DataView, 'byteOffset');
	  }
	  redefineAll($DataView[PROTOTYPE$2], {
	    getInt8: function getInt8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset) {
	      return get$1(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /* , littleEndian */) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /* , littleEndian */) {
	      var bytes = get$1(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /* , littleEndian */) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
	    },
	    getUint32: function getUint32(byteOffset /* , littleEndian */) {
	      return unpackInt32(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get$1(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
	    },
	    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
	      return unpackIEEE754(get$1(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
	    },
	    setInt8: function setInt8(byteOffset, value) {
	      set$1(this, 1, byteOffset, packInt8, value);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      set$1(this, 1, byteOffset, packInt8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
	      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
	      set$1(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
	      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
	      set$1(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
	      set$1(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
	      set$1(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
	    }
	  });
	} else {
	  if (!fails(function () {
	    NativeArrayBuffer(1);
	  }) || !fails(function () {
	    new NativeArrayBuffer(-1); // eslint-disable-line no-new
	  }) || fails(function () {
	    new NativeArrayBuffer(); // eslint-disable-line no-new
	    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
	    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
	    return NativeArrayBuffer.name != ARRAY_BUFFER;
	  })) {
	    $ArrayBuffer = function ArrayBuffer(length) {
	      anInstance(this, $ArrayBuffer);
	      return new NativeArrayBuffer(toIndex(length));
	    };
	    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE$2] = NativeArrayBuffer[PROTOTYPE$2];
	    for (var keys$1 = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys$1.length > j;) {
	      if (!((key = keys$1[j++]) in $ArrayBuffer)) {
	        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
	      }
	    }
	    ArrayBufferPrototype.constructor = $ArrayBuffer;
	  }

	  // WebKit bug - the same parent prototype for typed arrays and data view
	  if (objectSetPrototypeOf && objectGetPrototypeOf($DataViewPrototype) !== ObjectPrototype$2) {
	    objectSetPrototypeOf($DataViewPrototype, ObjectPrototype$2);
	  }

	  // iOS Safari 7.x bug
	  var testView = new $DataView(new $ArrayBuffer(2));
	  var nativeSetInt8 = $DataViewPrototype.setInt8;
	  testView.setInt8(0, 2147483648);
	  testView.setInt8(1, 2147483649);
	  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
	    setInt8: function setInt8(byteOffset, value) {
	      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value) {
	      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, {
	    unsafe: true
	  });
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	var arrayBuffer = {
	  ArrayBuffer: $ArrayBuffer,
	  DataView: $DataView
	};

	var ARRAY_BUFFER$1 = 'ArrayBuffer';
	var ArrayBuffer$1 = arrayBuffer[ARRAY_BUFFER$1];
	var NativeArrayBuffer$1 = global_1[ARRAY_BUFFER$1];

	// `ArrayBuffer` constructor
	// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor
	_export({
	  global: true,
	  forced: NativeArrayBuffer$1 !== ArrayBuffer$1
	}, {
	  ArrayBuffer: ArrayBuffer$1
	});
	setSpecies(ARRAY_BUFFER$1);

	var defineProperty$5 = objectDefineProperty.f;




	var Int8Array$1 = global_1.Int8Array;
	var Int8ArrayPrototype = Int8Array$1 && Int8Array$1.prototype;
	var Uint8ClampedArray = global_1.Uint8ClampedArray;
	var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
	var TypedArray = Int8Array$1 && objectGetPrototypeOf(Int8Array$1);
	var TypedArrayPrototype = Int8ArrayPrototype && objectGetPrototypeOf(Int8ArrayPrototype);
	var ObjectPrototype$3 = Object.prototype;
	var isPrototypeOf = ObjectPrototype$3.isPrototypeOf;
	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
	var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
	// Fixing native typed arrays in Opera Presto crashes the browser, see #595
	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferNative && !!objectSetPrototypeOf && classof(global_1.opera) !== 'Opera';
	var TYPED_ARRAY_TAG_REQIRED = false;
	var NAME;
	var TypedArrayConstructorsList = {
	  Int8Array: 1,
	  Uint8Array: 1,
	  Uint8ClampedArray: 1,
	  Int16Array: 2,
	  Uint16Array: 2,
	  Int32Array: 4,
	  Uint32Array: 4,
	  Float32Array: 4,
	  Float64Array: 8
	};
	var isView = function isView(it) {
	  var klass = classof(it);
	  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
	};
	var isTypedArray = function isTypedArray(it) {
	  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
	};
	var aTypedArray = function aTypedArray(it) {
	  if (isTypedArray(it)) return it;
	  throw TypeError('Target is not a typed array');
	};
	var aTypedArrayConstructor = function aTypedArrayConstructor(C) {
	  if (objectSetPrototypeOf) {
	    if (isPrototypeOf.call(TypedArray, C)) return C;
	  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
	    var TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
	      return C;
	    }
	  }
	  throw TypeError('Target is not a typed array constructor');
	};
	var exportTypedArrayMethod = function exportTypedArrayMethod(KEY, property, forced) {
	  if (!descriptors) return;
	  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
	    var TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
	      delete TypedArrayConstructor.prototype[KEY];
	    }
	  }
	  if (!TypedArrayPrototype[KEY] || forced) {
	    redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
	  }
	};
	var exportTypedArrayStaticMethod = function exportTypedArrayStaticMethod(KEY, property, forced) {
	  var ARRAY, TypedArrayConstructor;
	  if (!descriptors) return;
	  if (objectSetPrototypeOf) {
	    if (forced) for (ARRAY in TypedArrayConstructorsList) {
	      TypedArrayConstructor = global_1[ARRAY];
	      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
	        delete TypedArrayConstructor[KEY];
	      }
	    }
	    if (!TypedArray[KEY] || forced) {
	      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
	      try {
	        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array$1[KEY] || property);
	      } catch (error) {/* empty */}
	    } else return;
	  }
	  for (ARRAY in TypedArrayConstructorsList) {
	    TypedArrayConstructor = global_1[ARRAY];
	    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
	      redefine(TypedArrayConstructor, KEY, property);
	    }
	  }
	};
	for (NAME in TypedArrayConstructorsList) {
	  if (!global_1[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
	}

	// WebKit bug - typed arrays constructors prototype is Object.prototype
	if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
	  // eslint-disable-next-line no-shadow
	  TypedArray = function TypedArray() {
	    throw TypeError('Incorrect invocation');
	  };
	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
	    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME], TypedArray);
	  }
	}
	if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype$3) {
	  TypedArrayPrototype = TypedArray.prototype;
	  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
	    if (global_1[NAME]) objectSetPrototypeOf(global_1[NAME].prototype, TypedArrayPrototype);
	  }
	}

	// WebKit bug - one more object in Uint8ClampedArray prototype chain
	if (NATIVE_ARRAY_BUFFER_VIEWS && objectGetPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
	  objectSetPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
	}
	if (descriptors && !has(TypedArrayPrototype, TO_STRING_TAG$3)) {
	  TYPED_ARRAY_TAG_REQIRED = true;
	  defineProperty$5(TypedArrayPrototype, TO_STRING_TAG$3, {
	    get: function get() {
	      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
	    }
	  });
	  for (NAME in TypedArrayConstructorsList) if (global_1[NAME]) {
	    createNonEnumerableProperty(global_1[NAME], TYPED_ARRAY_TAG, NAME);
	  }
	}
	var arrayBufferViewCore = {
	  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
	  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
	  aTypedArray: aTypedArray,
	  aTypedArrayConstructor: aTypedArrayConstructor,
	  exportTypedArrayMethod: exportTypedArrayMethod,
	  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
	  isView: isView,
	  isTypedArray: isTypedArray,
	  TypedArray: TypedArray,
	  TypedArrayPrototype: TypedArrayPrototype
	};

	var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

	// `ArrayBuffer.isView` method
	// https://tc39.github.io/ecma262/#sec-arraybuffer.isview
	_export({
	  target: 'ArrayBuffer',
	  stat: true,
	  forced: !NATIVE_ARRAY_BUFFER_VIEWS$1
	}, {
	  isView: arrayBufferViewCore.isView
	});

	var SPECIES$4 = wellKnownSymbol('species');

	// `SpeciesConstructor` abstract operation
	// https://tc39.github.io/ecma262/#sec-speciesconstructor
	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$4]) == undefined ? defaultConstructor : aFunction$1(S);
	};

	var ArrayBuffer$2 = arrayBuffer.ArrayBuffer;
	var DataView$1 = arrayBuffer.DataView;
	var nativeArrayBufferSlice = ArrayBuffer$2.prototype.slice;
	var INCORRECT_SLICE = fails(function () {
	  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;
	});

	// `ArrayBuffer.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
	_export({
	  target: 'ArrayBuffer',
	  proto: true,
	  unsafe: true,
	  forced: INCORRECT_SLICE
	}, {
	  slice: function slice(start, end) {
	    if (nativeArrayBufferSlice !== undefined && end === undefined) {
	      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
	    }
	    var length = anObject(this).byteLength;
	    var first = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    var result = new (speciesConstructor(this, ArrayBuffer$2))(toLength(fin - first));
	    var viewSource = new DataView$1(this);
	    var viewTarget = new DataView$1(result);
	    var index = 0;
	    while (first < fin) {
	      viewTarget.setUint8(index++, viewSource.getUint8(first++));
	    }
	    return result;
	  }
	});

	// `DataView` constructor
	// https://tc39.github.io/ecma262/#sec-dataview-constructor
	_export({
	  global: true,
	  forced: !arrayBufferNative
	}, {
	  DataView: arrayBuffer.DataView
	});

	// `Date.now` method
	// https://tc39.github.io/ecma262/#sec-date.now
	_export({
	  target: 'Date',
	  stat: true
	}, {
	  now: function now() {
	    return new Date().getTime();
	  }
	});

	// `String.prototype.repeat` method implementation
	// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
	var stringRepeat = ''.repeat || function repeat(count) {
	  var str = String(requireObjectCoercible(this));
	  var result = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
	  for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
	  return result;
	};

	// https://github.com/tc39/proposal-string-pad-start-end



	var ceil$1 = Math.ceil;

	// `String.prototype.{ padStart, padEnd }` methods implementation
	var createMethod$3 = function createMethod(IS_END) {
	  return function ($this, maxLength, fillString) {
	    var S = String(requireObjectCoercible($this));
	    var stringLength = S.length;
	    var fillStr = fillString === undefined ? ' ' : String(fillString);
	    var intMaxLength = toLength(maxLength);
	    var fillLen, stringFiller;
	    if (intMaxLength <= stringLength || fillStr == '') return S;
	    fillLen = intMaxLength - stringLength;
	    stringFiller = stringRepeat.call(fillStr, ceil$1(fillLen / fillStr.length));
	    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	    return IS_END ? S + stringFiller : stringFiller + S;
	  };
	};
	var stringPad = {
	  // `String.prototype.padStart` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.padstart
	  start: createMethod$3(false),
	  // `String.prototype.padEnd` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.padend
	  end: createMethod$3(true)
	};

	var padStart = stringPad.start;
	var abs$1 = Math.abs;
	var DatePrototype = Date.prototype;
	var getTime = DatePrototype.getTime;
	var nativeDateToISOString = DatePrototype.toISOString;

	// `Date.prototype.toISOString` method implementation
	// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
	// PhantomJS / old WebKit fails here:
	var dateToIsoString = fails(function () {
	  return nativeDateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
	}) || !fails(function () {
	  nativeDateToISOString.call(new Date(NaN));
	}) ? function toISOString() {
	  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
	  var date = this;
	  var year = date.getUTCFullYear();
	  var milliseconds = date.getUTCMilliseconds();
	  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
	  return sign + padStart(abs$1(year), sign ? 6 : 4, 0) + '-' + padStart(date.getUTCMonth() + 1, 2, 0) + '-' + padStart(date.getUTCDate(), 2, 0) + 'T' + padStart(date.getUTCHours(), 2, 0) + ':' + padStart(date.getUTCMinutes(), 2, 0) + ':' + padStart(date.getUTCSeconds(), 2, 0) + '.' + padStart(milliseconds, 3, 0) + 'Z';
	} : nativeDateToISOString;

	// `Date.prototype.toISOString` method
	// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
	// PhantomJS / old WebKit has a broken implementations
	_export({
	  target: 'Date',
	  proto: true,
	  forced: Date.prototype.toISOString !== dateToIsoString
	}, {
	  toISOString: dateToIsoString
	});

	var FORCED$3 = fails(function () {
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
	    toISOString: function toISOString() {
	      return 1;
	    }
	  }) !== 1;
	});

	// `Date.prototype.toJSON` method
	// https://tc39.github.io/ecma262/#sec-date.prototype.tojson
	_export({
	  target: 'Date',
	  proto: true,
	  forced: FORCED$3
	}, {
	  // eslint-disable-next-line no-unused-vars
	  toJSON: function toJSON(key) {
	    var O = toObject(this);
	    var pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

	var dateToPrimitive = function (hint) {
	  if (hint !== 'string' && hint !== 'number' && hint !== 'default') {
	    throw TypeError('Incorrect hint');
	  }
	  return toPrimitive(anObject(this), hint !== 'number');
	};

	var TO_PRIMITIVE$1 = wellKnownSymbol('toPrimitive');
	var DatePrototype$1 = Date.prototype;

	// `Date.prototype[@@toPrimitive]` method
	// https://tc39.github.io/ecma262/#sec-date.prototype-@@toprimitive
	if (!(TO_PRIMITIVE$1 in DatePrototype$1)) {
	  createNonEnumerableProperty(DatePrototype$1, TO_PRIMITIVE$1, dateToPrimitive);
	}

	var DatePrototype$2 = Date.prototype;
	var INVALID_DATE = 'Invalid Date';
	var TO_STRING = 'toString';
	var nativeDateToString = DatePrototype$2[TO_STRING];
	var getTime$1 = DatePrototype$2.getTime;

	// `Date.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-date.prototype.tostring
	if (new Date(NaN) + '' != INVALID_DATE) {
	  redefine(DatePrototype$2, TO_STRING, function toString() {
	    var value = getTime$1.call(this);
	    // eslint-disable-next-line no-self-compare
	    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
	  });
	}

	var slice = [].slice;
	var factories = {};
	var construct = function construct(C, argsLength, args) {
	  if (!(argsLength in factories)) {
	    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func
	    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
	  }
	  return factories[argsLength](C, args);
	};

	// `Function.prototype.bind` method implementation
	// https://tc39.github.io/ecma262/#sec-function.prototype.bind
	var functionBind = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction$1(this);
	  var partArgs = slice.call(arguments, 1);
	  var boundFunction = function bound( /* args... */
	  ) {
	    var args = partArgs.concat(slice.call(arguments));
	    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
	  };
	  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
	  return boundFunction;
	};

	// `Function.prototype.bind` method
	// https://tc39.github.io/ecma262/#sec-function.prototype.bind
	_export({
	  target: 'Function',
	  proto: true
	}, {
	  bind: functionBind
	});

	var HAS_INSTANCE = wellKnownSymbol('hasInstance');
	var FunctionPrototype = Function.prototype;

	// `Function.prototype[@@hasInstance]` method
	// https://tc39.github.io/ecma262/#sec-function.prototype-@@hasinstance
	if (!(HAS_INSTANCE in FunctionPrototype)) {
	  objectDefineProperty.f(FunctionPrototype, HAS_INSTANCE, {
	    value: function value(O) {
	      if (typeof this != 'function' || !isObject(O)) return false;
	      if (!isObject(this.prototype)) return O instanceof this;
	      // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	      while (O = objectGetPrototypeOf(O)) if (this.prototype === O) return true;
	      return false;
	    }
	  });
	}

	var defineProperty$6 = objectDefineProperty.f;
	var FunctionPrototype$1 = Function.prototype;
	var FunctionPrototypeToString = FunctionPrototype$1.toString;
	var nameRE = /^\s*function ([^ (]*)/;
	var NAME$1 = 'name';

	// Function instances `.name` property
	// https://tc39.github.io/ecma262/#sec-function-instances-name
	if (descriptors && !(NAME$1 in FunctionPrototype$1)) {
	  defineProperty$6(FunctionPrototype$1, NAME$1, {
	    configurable: true,
	    get: function get() {
	      try {
	        return FunctionPrototypeToString.call(this).match(nameRE)[1];
	      } catch (error) {
	        return '';
	      }
	    }
	  });
	}

	// JSON[@@toStringTag] property
	// https://tc39.github.io/ecma262/#sec-json-@@tostringtag
	setToStringTag(global_1.JSON, 'JSON', true);

	var freezing = !fails(function () {
	  return Object.isExtensible(Object.preventExtensions({}));
	});

	var internalMetadata = createCommonjsModule(function (module) {
	var defineProperty = objectDefineProperty.f;


	var METADATA = uid('meta');
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var setMetadata = function setMetadata(it) {
	  defineProperty(it, METADATA, {
	    value: {
	      objectID: 'O' + ++id,
	      // object ID
	      weakData: {} // weak collections IDs
	    }
	  });
	};
	var fastKey = function fastKey(it, create) {
	  // return a primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMetadata(it);
	    // return object ID
	  }
	  return it[METADATA].objectID;
	};
	var getWeakData = function getWeakData(it, create) {
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMetadata(it);
	    // return the store of weak collections IDs
	  }
	  return it[METADATA].weakData;
	};

	// add metadata on freeze-family methods calling
	var onFreeze = function onFreeze(it) {
	  if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
	  return it;
	};
	var meta = module.exports = {
	  REQUIRED: false,
	  fastKey: fastKey,
	  getWeakData: getWeakData,
	  onFreeze: onFreeze
	};
	hiddenKeys[METADATA] = true;
	});
	var internalMetadata_1 = internalMetadata.REQUIRED;
	var internalMetadata_2 = internalMetadata.fastKey;
	var internalMetadata_3 = internalMetadata.getWeakData;
	var internalMetadata_4 = internalMetadata.onFreeze;

	var iterate_1 = createCommonjsModule(function (module) {
	var Result = function Result(stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};
	var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
	  var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
	  var iterator, iterFn, index, length, result, next, step;
	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
	    // optimisation for array iterators
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = toLength(iterable.length); length > index; index++) {
	        result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
	        if (result && result instanceof Result) return result;
	      }
	      return new Result(false);
	    }
	    iterator = iterFn.call(iterable);
	  }
	  next = iterator.next;
	  while (!(step = next.call(iterator)).done) {
	    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
	    if (typeof result == 'object' && result && result instanceof Result) return result;
	  }
	  return new Result(false);
	};
	iterate.stop = function (result) {
	  return new Result(true, result);
	};
	});

	// makes subclassing work correct for wrapped built-ins
	var inheritIfRequired = function ($this, dummy, Wrapper) {
	  var NewTarget, NewTargetPrototype;
	  if (
	  // it can work only with native `setPrototypeOf`
	  objectSetPrototypeOf &&
	  // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
	  typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) objectSetPrototypeOf($this, NewTargetPrototype);
	  return $this;
	};

	var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
	  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
	  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
	  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
	  var Constructor = NativeConstructor;
	  var exported = {};
	  var fixMethod = function fixMethod(KEY) {
	    var nativeMethod = NativePrototype[KEY];
	    redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
	      nativeMethod.call(this, value === 0 ? 0 : value);
	      return this;
	    } : KEY == 'delete' ? function (key) {
	      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
	    } : KEY == 'get' ? function get(key) {
	      return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
	    } : KEY == 'has' ? function has(key) {
	      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
	    } : function set(key, value) {
	      nativeMethod.call(this, key === 0 ? 0 : key, value);
	      return this;
	    });
	  };

	  // eslint-disable-next-line max-len
	  if (isForced_1(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
	    new NativeConstructor().entries().next();
	  })))) {
	    // create collection constructor
	    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
	    internalMetadata.REQUIRED = true;
	  } else if (isForced_1(CONSTRUCTOR_NAME, true)) {
	    var instance = new Constructor();
	    // early implementations not supports chaining
	    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
	    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
	    var THROWS_ON_PRIMITIVES = fails(function () {
	      instance.has(1);
	    });
	    // most early implementations doesn't supports iterables, most modern - not close it correctly
	    // eslint-disable-next-line no-new
	    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
	      new NativeConstructor(iterable);
	    });
	    // for early implementations -0 and +0 not the same
	    var BUGGY_ZERO = !IS_WEAK && fails(function () {
	      // V8 ~ Chromium 42- fails only with 5+ elements
	      var $instance = new NativeConstructor();
	      var index = 5;
	      while (index--) $instance[ADDER](index, index);
	      return !$instance.has(-0);
	    });
	    if (!ACCEPT_ITERABLES) {
	      Constructor = wrapper(function (dummy, iterable) {
	        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
	        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
	        if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
	        return that;
	      });
	      Constructor.prototype = NativePrototype;
	      NativePrototype.constructor = Constructor;
	    }
	    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

	    // weak collections should not contains .clear method
	    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
	  }
	  exported[CONSTRUCTOR_NAME] = Constructor;
	  _export({
	    global: true,
	    forced: Constructor != NativeConstructor
	  }, exported);
	  setToStringTag(Constructor, CONSTRUCTOR_NAME);
	  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
	  return Constructor;
	};

	var defineProperty$7 = objectDefineProperty.f;








	var fastKey = internalMetadata.fastKey;

	var setInternalState$3 = internalState.set;
	var internalStateGetterFor = internalState.getterFor;
	var collectionStrong = {
	  getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, CONSTRUCTOR_NAME);
	      setInternalState$3(that, {
	        type: CONSTRUCTOR_NAME,
	        index: objectCreate(null),
	        first: undefined,
	        last: undefined,
	        size: 0
	      });
	      if (!descriptors) that.size = 0;
	      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
	    });
	    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
	    var define = function define(that, key, value) {
	      var state = getInternalState(that);
	      var entry = getEntry(that, key);
	      var previous, index;
	      // change existing entry
	      if (entry) {
	        entry.value = value;
	        // create new entry
	      } else {
	        state.last = entry = {
	          index: index = fastKey(key, true),
	          key: key,
	          value: value,
	          previous: previous = state.last,
	          next: undefined,
	          removed: false
	        };
	        if (!state.first) state.first = entry;
	        if (previous) previous.next = entry;
	        if (descriptors) state.size++;else that.size++;
	        // add to index
	        if (index !== 'F') state.index[index] = entry;
	      }
	      return that;
	    };
	    var getEntry = function getEntry(that, key) {
	      var state = getInternalState(that);
	      // fast case
	      var index = fastKey(key);
	      var entry;
	      if (index !== 'F') return state.index[index];
	      // frozen object case
	      for (entry = state.first; entry; entry = entry.next) {
	        if (entry.key == key) return entry;
	      }
	    };
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        var that = this;
	        var state = getInternalState(that);
	        var data = state.index;
	        var entry = state.first;
	        while (entry) {
	          entry.removed = true;
	          if (entry.previous) entry.previous = entry.previous.next = undefined;
	          delete data[entry.index];
	          entry = entry.next;
	        }
	        state.first = state.last = undefined;
	        if (descriptors) state.size = 0;else that.size = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function _delete(key) {
	        var that = this;
	        var state = getInternalState(that);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.next;
	          var prev = entry.previous;
	          delete state.index[entry.index];
	          entry.removed = true;
	          if (prev) prev.next = next;
	          if (next) next.previous = prev;
	          if (state.first == entry) state.first = next;
	          if (state.last == entry) state.last = prev;
	          if (descriptors) state.size--;else that.size--;
	        }
	        return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        var state = getInternalState(this);
	        var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.next : state.first) {
	          boundFunction(entry.value, entry.key, this);
	          // revert to the last existing entry
	          while (entry && entry.removed) entry = entry.previous;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(this, key);
	      }
	    });
	    redefineAll(C.prototype, IS_MAP ? {
	      // 23.1.3.6 Map.prototype.get(key)
	      get: function get(key) {
	        var entry = getEntry(this, key);
	        return entry && entry.value;
	      },
	      // 23.1.3.9 Map.prototype.set(key, value)
	      set: function set(key, value) {
	        return define(this, key === 0 ? 0 : key, value);
	      }
	    } : {
	      // 23.2.3.1 Set.prototype.add(value)
	      add: function add(value) {
	        return define(this, value = value === 0 ? 0 : value, value);
	      }
	    });
	    if (descriptors) defineProperty$7(C.prototype, 'size', {
	      get: function get() {
	        return getInternalState(this).size;
	      }
	    });
	    return C;
	  },
	  setStrong: function setStrong(C, CONSTRUCTOR_NAME, IS_MAP) {
	    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
	    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
	    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
	      setInternalState$3(this, {
	        type: ITERATOR_NAME,
	        target: iterated,
	        state: getInternalCollectionState(iterated),
	        kind: kind,
	        last: undefined
	      });
	    }, function () {
	      var state = getInternalIteratorState(this);
	      var kind = state.kind;
	      var entry = state.last;
	      // revert to the last existing entry
	      while (entry && entry.removed) entry = entry.previous;
	      // get next entry
	      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
	        // or finish the iteration
	        state.target = undefined;
	        return {
	          value: undefined,
	          done: true
	        };
	      }
	      // return step by kind
	      if (kind == 'keys') return {
	        value: entry.key,
	        done: false
	      };
	      if (kind == 'values') return {
	        value: entry.value,
	        done: false
	      };
	      return {
	        value: [entry.key, entry.value],
	        done: false
	      };
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(CONSTRUCTOR_NAME);
	  }
	};

	// `Map` constructor
	// https://tc39.github.io/ecma262/#sec-map-objects
	var es_map = collection('Map', function (init) {
	  return function Map() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	}, collectionStrong);

	var log$1 = Math.log;

	// `Math.log1p` method implementation
	// https://tc39.github.io/ecma262/#sec-math.log1p
	var mathLog1p = Math.log1p || function log1p(x) {
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log$1(1 + x);
	};

	var nativeAcosh = Math.acosh;
	var log$2 = Math.log;
	var sqrt = Math.sqrt;
	var LN2$1 = Math.LN2;
	var FORCED$4 = !nativeAcosh
	// V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	|| Math.floor(nativeAcosh(Number.MAX_VALUE)) != 710
	// Tor Browser bug: Math.acosh(Infinity) -> NaN
	|| nativeAcosh(Infinity) != Infinity;

	// `Math.acosh` method
	// https://tc39.github.io/ecma262/#sec-math.acosh
	_export({
	  target: 'Math',
	  stat: true,
	  forced: FORCED$4
	}, {
	  acosh: function acosh(x) {
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? log$2(x) + LN2$1 : mathLog1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

	var nativeAsinh = Math.asinh;
	var log$3 = Math.log;
	var sqrt$1 = Math.sqrt;
	function asinh(x) {
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log$3(x + sqrt$1(x * x + 1));
	}

	// `Math.asinh` method
	// https://tc39.github.io/ecma262/#sec-math.asinh
	// Tor Browser bug: Math.asinh(0) -> -0
	_export({
	  target: 'Math',
	  stat: true,
	  forced: !(nativeAsinh && 1 / nativeAsinh(0) > 0)
	}, {
	  asinh: asinh
	});

	var nativeAtanh = Math.atanh;
	var log$4 = Math.log;

	// `Math.atanh` method
	// https://tc39.github.io/ecma262/#sec-math.atanh
	// Tor Browser bug: Math.atanh(-0) -> 0
	_export({
	  target: 'Math',
	  stat: true,
	  forced: !(nativeAtanh && 1 / nativeAtanh(-0) < 0)
	}, {
	  atanh: function atanh(x) {
	    return (x = +x) == 0 ? x : log$4((1 + x) / (1 - x)) / 2;
	  }
	});

	// `Math.sign` method implementation
	// https://tc39.github.io/ecma262/#sec-math.sign
	var mathSign = Math.sign || function sign(x) {
	  // eslint-disable-next-line no-self-compare
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

	var abs$2 = Math.abs;
	var pow$1 = Math.pow;

	// `Math.cbrt` method
	// https://tc39.github.io/ecma262/#sec-math.cbrt
	_export({
	  target: 'Math',
	  stat: true
	}, {
	  cbrt: function cbrt(x) {
	    return mathSign(x = +x) * pow$1(abs$2(x), 1 / 3);
	  }
	});

	var floor$2 = Math.floor;
	var log$5 = Math.log;
	var LOG2E = Math.LOG2E;

	// `Math.clz32` method
	// https://tc39.github.io/ecma262/#sec-math.clz32
	_export({
	  target: 'Math',
	  stat: true
	}, {
	  clz32: function clz32(x) {
	    return (x >>>= 0) ? 31 - floor$2(log$5(x + 0.5) * LOG2E) : 32;
	  }
	});

	var nativeExpm1 = Math.expm1;
	var exp = Math.exp;

	// `Math.expm1` method implementation
	// https://tc39.github.io/ecma262/#sec-math.expm1
	var mathExpm1 = !nativeExpm1
	// Old FF bug
	|| nativeExpm1(10) > 22025.465794806719 || nativeExpm1(10) < 22025.4657948067165168
	// Tor Browser bug
	|| nativeExpm1(-2e-17) != -2e-17 ? function expm1(x) {
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
	} : nativeExpm1;

	var nativeCosh = Math.cosh;
	var abs$3 = Math.abs;
	var E = Math.E;

	// `Math.cosh` method
	// https://tc39.github.io/ecma262/#sec-math.cosh
	_export({
	  target: 'Math',
	  stat: true,
	  forced: !nativeCosh || nativeCosh(710) === Infinity
	}, {
	  cosh: function cosh(x) {
	    var t = mathExpm1(abs$3(x) - 1) + 1;
	    return (t + 1 / (t * E * E)) * (E / 2);
	  }
	});

	// `Math.expm1` method
	// https://tc39.github.io/ecma262/#sec-math.expm1
	_export({
	  target: 'Math',
	  stat: true,
	  forced: mathExpm1 != Math.expm1
	}, {
	  expm1: mathExpm1
	});

	var abs$4 = Math.abs;
	var pow$2 = Math.pow;
	var EPSILON = pow$2(2, -52);
	var EPSILON32 = pow$2(2, -23);
	var MAX32 = pow$2(2, 127) * (2 - EPSILON32);
	var MIN32 = pow$2(2, -126);
	var roundTiesToEven = function roundTiesToEven(n) {
	  return n + 1 / EPSILON - 1 / EPSILON;
	};

	// `Math.fround` method implementation
	// https://tc39.github.io/ecma262/#sec-math.fround
	var mathFround = Math.fround || function fround(x) {
	  var $abs = abs$4(x);
	  var $sign = mathSign(x);
	  var a, result;
	  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	  a = (1 + EPSILON32 / EPSILON) * $abs;
	  result = a - (a - $abs);
	  // eslint-disable-next-line no-self-compare
	  if (result > MAX32 || result != result) return $sign * Infinity;
	  return $sign * result;
	};

	// `Math.fround` method
	// https://tc39.github.io/ecma262/#sec-math.fround
	_export({
	  target: 'Math',
	  stat: true
	}, {
	  fround: mathFround
	});

	var $hypot = Math.hypot;
	var abs$5 = Math.abs;
	var sqrt$2 = Math.sqrt;

	// Chrome 77 bug
	// https://bugs.chromium.org/p/v8/issues/detail?id=9546
	var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;

	// `Math.hypot` method
	// https://tc39.github.io/ecma262/#sec-math.hypot
	_export({
	  target: 'Math',
	  stat: true,
	  forced: BUGGY
	}, {
	  hypot: function hypot(value1, value2) {
	    // eslint-disable-line no-unused-vars
	    var sum = 0;
	    var i = 0;
	    var aLen = arguments.length;
	    var larg = 0;
	    var arg, div;
	    while (i < aLen) {
	      arg = abs$5(arguments[i++]);
	      if (larg < arg) {
	        div = larg / arg;
	        sum = sum * div * div + 1;
	        larg = arg;
	      } else if (arg > 0) {
	        div = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * sqrt$2(sum);
	  }
	});

	var nativeImul = Math.imul;
	var FORCED$5 = fails(function () {
	  return nativeImul(0xFFFFFFFF, 5) != -5 || nativeImul.length != 2;
	});

	// `Math.imul` method
	// https://tc39.github.io/ecma262/#sec-math.imul
	// some WebKit versions fails with big numbers, some has wrong arity
	_export({
	  target: 'Math',
	  stat: true,
	  forced: FORCED$5
	}, {
	  imul: function imul(x, y) {
	    var UINT16 = 0xFFFF;
	    var xn = +x;
	    var yn = +y;
	    var xl = UINT16 & xn;
	    var yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

	var log$6 = Math.log;
	var LOG10E = Math.LOG10E;

	// `Math.log10` method
	// https://tc39.github.io/ecma262/#sec-math.log10
	_export({
	  target: 'Math',
	  stat: true
	}, {
	  log10: function log10(x) {
	    return log$6(x) * LOG10E;
	  }
	});

	// `Math.log1p` method
	// https://tc39.github.io/ecma262/#sec-math.log1p
	_export({
	  target: 'Math',
	  stat: true
	}, {
	  log1p: mathLog1p
	});

	var log$7 = Math.log;
	var LN2$2 = Math.LN2;

	// `Math.log2` method
	// https://tc39.github.io/ecma262/#sec-math.log2
	_export({
	  target: 'Math',
	  stat: true
	}, {
	  log2: function log2(x) {
	    return log$7(x) / LN2$2;
	  }
	});

	// `Math.sign` method
	// https://tc39.github.io/ecma262/#sec-math.sign
	_export({
	  target: 'Math',
	  stat: true
	}, {
	  sign: mathSign
	});

	var abs$6 = Math.abs;
	var exp$1 = Math.exp;
	var E$1 = Math.E;
	var FORCED$6 = fails(function () {
	  return Math.sinh(-2e-17) != -2e-17;
	});

	// `Math.sinh` method
	// https://tc39.github.io/ecma262/#sec-math.sinh
	// V8 near Chromium 38 has a problem with very small numbers
	_export({
	  target: 'Math',
	  stat: true,
	  forced: FORCED$6
	}, {
	  sinh: function sinh(x) {
	    return abs$6(x = +x) < 1 ? (mathExpm1(x) - mathExpm1(-x)) / 2 : (exp$1(x - 1) - exp$1(-x - 1)) * (E$1 / 2);
	  }
	});

	var exp$2 = Math.exp;

	// `Math.tanh` method
	// https://tc39.github.io/ecma262/#sec-math.tanh
	_export({
	  target: 'Math',
	  stat: true
	}, {
	  tanh: function tanh(x) {
	    var a = mathExpm1(x = +x);
	    var b = mathExpm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp$2(x) + exp$2(-x));
	  }
	});

	// Math[@@toStringTag] property
	// https://tc39.github.io/ecma262/#sec-math-@@tostringtag
	setToStringTag(Math, 'Math', true);

	var ceil$2 = Math.ceil;
	var floor$3 = Math.floor;

	// `Math.trunc` method
	// https://tc39.github.io/ecma262/#sec-math.trunc
	_export({
	  target: 'Math',
	  stat: true
	}, {
	  trunc: function trunc(it) {
	    return (it > 0 ? floor$3 : ceil$2)(it);
	  }
	});

	// a string of all valid unicode whitespaces
	// eslint-disable-next-line max-len
	var whitespaces = "\t\n\x0B\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

	var whitespace = '[' + whitespaces + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$');

	// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
	var createMethod$4 = function createMethod(TYPE) {
	  return function ($this) {
	    var string = String(requireObjectCoercible($this));
	    if (TYPE & 1) string = string.replace(ltrim, '');
	    if (TYPE & 2) string = string.replace(rtrim, '');
	    return string;
	  };
	};
	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$4(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
	  end: createMethod$4(2),
	  // `String.prototype.trim` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
	  trim: createMethod$4(3)
	};

	var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
	var defineProperty$8 = objectDefineProperty.f;
	var trim = stringTrim.trim;
	var NUMBER = 'Number';
	var NativeNumber = global_1[NUMBER];
	var NumberPrototype = NativeNumber.prototype;

	// Opera ~12 has broken Object#toString
	var BROKEN_CLASSOF = classofRaw(objectCreate(NumberPrototype)) == NUMBER;

	// `ToNumber` abstract operation
	// https://tc39.github.io/ecma262/#sec-tonumber
	var toNumber = function toNumber(argument) {
	  var it = toPrimitive(argument, false);
	  var first, third, radix, maxCode, digits, length, index, code;
	  if (typeof it == 'string' && it.length > 2) {
	    it = trim(it);
	    first = it.charCodeAt(0);
	    if (first === 43 || first === 45) {
	      third = it.charCodeAt(2);
	      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if (first === 48) {
	      switch (it.charCodeAt(1)) {
	        case 66:
	        case 98:
	          radix = 2;
	          maxCode = 49;
	          break;
	        // fast equal of /^0b[01]+$/i
	        case 79:
	        case 111:
	          radix = 8;
	          maxCode = 55;
	          break;
	        // fast equal of /^0o[0-7]+$/i
	        default:
	          return +it;
	      }
	      digits = it.slice(2);
	      length = digits.length;
	      for (index = 0; index < length; index++) {
	        code = digits.charCodeAt(index);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if (code < 48 || code > maxCode) return NaN;
	      }
	      return parseInt(digits, radix);
	    }
	  }
	  return +it;
	};

	// `Number` constructor
	// https://tc39.github.io/ecma262/#sec-number-constructor
	if (isForced_1(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
	  var NumberWrapper = function Number(value) {
	    var it = arguments.length < 1 ? 0 : value;
	    var dummy = this;
	    return dummy instanceof NumberWrapper
	    // check on 1..constructor(foo) case
	    && (BROKEN_CLASSOF ? fails(function () {
	      NumberPrototype.valueOf.call(dummy);
	    }) : classofRaw(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
	  };
	  for (var keys$2 = descriptors ? getOwnPropertyNames$1(NativeNumber) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES2015 (in case, if modules with ES2015 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j$1 = 0, key$1; keys$2.length > j$1; j$1++) {
	    if (has(NativeNumber, key$1 = keys$2[j$1]) && !has(NumberWrapper, key$1)) {
	      defineProperty$8(NumberWrapper, key$1, getOwnPropertyDescriptor$2(NativeNumber, key$1));
	    }
	  }
	  NumberWrapper.prototype = NumberPrototype;
	  NumberPrototype.constructor = NumberWrapper;
	  redefine(global_1, NUMBER, NumberWrapper);
	}

	// `Number.EPSILON` constant
	// https://tc39.github.io/ecma262/#sec-number.epsilon
	_export({
	  target: 'Number',
	  stat: true
	}, {
	  EPSILON: Math.pow(2, -52)
	});

	var globalIsFinite = global_1.isFinite;

	// `Number.isFinite` method
	// https://tc39.github.io/ecma262/#sec-number.isfinite
	var numberIsFinite = Number.isFinite || function isFinite(it) {
	  return typeof it == 'number' && globalIsFinite(it);
	};

	// `Number.isFinite` method
	// https://tc39.github.io/ecma262/#sec-number.isfinite
	_export({
	  target: 'Number',
	  stat: true
	}, {
	  isFinite: numberIsFinite
	});

	var floor$4 = Math.floor;

	// `Number.isInteger` method implementation
	// https://tc39.github.io/ecma262/#sec-number.isinteger
	var isInteger = function isInteger(it) {
	  return !isObject(it) && isFinite(it) && floor$4(it) === it;
	};

	// `Number.isInteger` method
	// https://tc39.github.io/ecma262/#sec-number.isinteger
	_export({
	  target: 'Number',
	  stat: true
	}, {
	  isInteger: isInteger
	});

	// `Number.isNaN` method
	// https://tc39.github.io/ecma262/#sec-number.isnan
	_export({
	  target: 'Number',
	  stat: true
	}, {
	  isNaN: function isNaN(number) {
	    // eslint-disable-next-line no-self-compare
	    return number != number;
	  }
	});

	var abs$7 = Math.abs;

	// `Number.isSafeInteger` method
	// https://tc39.github.io/ecma262/#sec-number.issafeinteger
	_export({
	  target: 'Number',
	  stat: true
	}, {
	  isSafeInteger: function isSafeInteger(number) {
	    return isInteger(number) && abs$7(number) <= 0x1FFFFFFFFFFFFF;
	  }
	});

	// `Number.MAX_SAFE_INTEGER` constant
	// https://tc39.github.io/ecma262/#sec-number.max_safe_integer
	_export({
	  target: 'Number',
	  stat: true
	}, {
	  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
	});

	// `Number.MIN_SAFE_INTEGER` constant
	// https://tc39.github.io/ecma262/#sec-number.min_safe_integer
	_export({
	  target: 'Number',
	  stat: true
	}, {
	  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
	});

	var trim$1 = stringTrim.trim;

	var $parseFloat = global_1.parseFloat;
	var FORCED$7 = 1 / $parseFloat(whitespaces + '-0') !== -Infinity;

	// `parseFloat` method
	// https://tc39.github.io/ecma262/#sec-parsefloat-string
	var numberParseFloat = FORCED$7 ? function parseFloat(string) {
	  var trimmedString = trim$1(String(string));
	  var result = $parseFloat(trimmedString);
	  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	// `Number.parseFloat` method
	// https://tc39.github.io/ecma262/#sec-number.parseFloat
	_export({
	  target: 'Number',
	  stat: true,
	  forced: Number.parseFloat != numberParseFloat
	}, {
	  parseFloat: numberParseFloat
	});

	var trim$2 = stringTrim.trim;

	var $parseInt = global_1.parseInt;
	var hex = /^[+-]?0[Xx]/;
	var FORCED$8 = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22;

	// `parseInt` method
	// https://tc39.github.io/ecma262/#sec-parseint-string-radix
	var numberParseInt = FORCED$8 ? function parseInt(string, radix) {
	  var S = trim$2(String(string));
	  return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
	} : $parseInt;

	// `Number.parseInt` method
	// https://tc39.github.io/ecma262/#sec-number.parseint
	_export({
	  target: 'Number',
	  stat: true,
	  forced: Number.parseInt != numberParseInt
	}, {
	  parseInt: numberParseInt
	});

	// `thisNumberValue` abstract operation
	// https://tc39.github.io/ecma262/#sec-thisnumbervalue
	var thisNumberValue = function (value) {
	  if (typeof value != 'number' && classofRaw(value) != 'Number') {
	    throw TypeError('Incorrect invocation');
	  }
	  return +value;
	};

	var nativeToFixed = 1.0.toFixed;
	var floor$5 = Math.floor;
	var pow$3 = function pow(x, n, acc) {
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log$8 = function log(x) {
	  var n = 0;
	  var x2 = x;
	  while (x2 >= 4096) {
	    n += 12;
	    x2 /= 4096;
	  }
	  while (x2 >= 2) {
	    n += 1;
	    x2 /= 2;
	  }
	  return n;
	};
	var FORCED$9 = nativeToFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !fails(function () {
	  // V8 ~ Android 4.3-
	  nativeToFixed.call({});
	});

	// `Number.prototype.toFixed` method
	// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
	_export({
	  target: 'Number',
	  proto: true,
	  forced: FORCED$9
	}, {
	  // eslint-disable-next-line max-statements
	  toFixed: function toFixed(fractionDigits) {
	    var number = thisNumberValue(this);
	    var fractDigits = toInteger(fractionDigits);
	    var data = [0, 0, 0, 0, 0, 0];
	    var sign = '';
	    var result = '0';
	    var e, z, j, k;
	    var multiply = function multiply(n, c) {
	      var index = -1;
	      var c2 = c;
	      while (++index < 6) {
	        c2 += n * data[index];
	        data[index] = c2 % 1e7;
	        c2 = floor$5(c2 / 1e7);
	      }
	    };
	    var divide = function divide(n) {
	      var index = 6;
	      var c = 0;
	      while (--index >= 0) {
	        c += data[index];
	        data[index] = floor$5(c / n);
	        c = c % n * 1e7;
	      }
	    };
	    var dataToString = function dataToString() {
	      var index = 6;
	      var s = '';
	      while (--index >= 0) {
	        if (s !== '' || index === 0 || data[index] !== 0) {
	          var t = String(data[index]);
	          s = s === '' ? t : s + stringRepeat.call('0', 7 - t.length) + t;
	        }
	      }
	      return s;
	    };
	    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
	    // eslint-disable-next-line no-self-compare
	    if (number != number) return 'NaN';
	    if (number <= -1e21 || number >= 1e21) return String(number);
	    if (number < 0) {
	      sign = '-';
	      number = -number;
	    }
	    if (number > 1e-21) {
	      e = log$8(number * pow$3(2, 69, 1)) - 69;
	      z = e < 0 ? number * pow$3(2, -e, 1) : number / pow$3(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if (e > 0) {
	        multiply(0, z);
	        j = fractDigits;
	        while (j >= 7) {
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow$3(10, j, 1), 0);
	        j = e - 1;
	        while (j >= 23) {
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        result = dataToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        result = dataToString() + stringRepeat.call('0', fractDigits);
	      }
	    }
	    if (fractDigits > 0) {
	      k = result.length;
	      result = sign + (k <= fractDigits ? '0.' + stringRepeat.call('0', fractDigits - k) + result : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
	    } else {
	      result = sign + result;
	    }
	    return result;
	  }
	});

	var nativeToPrecision = 1.0.toPrecision;
	var FORCED$a = fails(function () {
	  // IE7-
	  return nativeToPrecision.call(1, undefined) !== '1';
	}) || !fails(function () {
	  // V8 ~ Android 4.3-
	  nativeToPrecision.call({});
	});

	// `Number.prototype.toPrecision` method
	// https://tc39.github.io/ecma262/#sec-number.prototype.toprecision
	_export({
	  target: 'Number',
	  proto: true,
	  forced: FORCED$a
	}, {
	  toPrecision: function toPrecision(precision) {
	    return precision === undefined ? nativeToPrecision.call(thisNumberValue(this)) : nativeToPrecision.call(thisNumberValue(this), precision);
	  }
	});

	var nativeAssign = Object.assign;
	var defineProperty$9 = Object.defineProperty;

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	var objectAssign = !nativeAssign || fails(function () {
	  // should have correct order of operations (Edge bug)
	  if (descriptors && nativeAssign({
	    b: 1
	  }, nativeAssign(defineProperty$9({}, 'a', {
	    enumerable: true,
	    get: function get() {
	      defineProperty$9(this, 'b', {
	        value: 3,
	        enumerable: false
	      });
	    }
	  }), {
	    b: 2
	  })).b !== 1) return true;
	  // should work with symbols and should have deterministic property order (V8 bug)
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var symbol = Symbol();
	  var alphabet = 'abcdefghijklmnopqrst';
	  A[symbol] = 7;
	  alphabet.split('').forEach(function (chr) {
	    B[chr] = chr;
	  });
	  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
	}) ? function assign(target, source) {
	  // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var argumentsLength = arguments.length;
	  var index = 1;
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  var propertyIsEnumerable = objectPropertyIsEnumerable.f;
	  while (argumentsLength > index) {
	    var S = indexedObject(arguments[index++]);
	    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
	    }
	  }
	  return T;
	} : nativeAssign;

	// `Object.assign` method
	// https://tc39.github.io/ecma262/#sec-object.assign
	_export({
	  target: 'Object',
	  stat: true,
	  forced: Object.assign !== objectAssign
	}, {
	  assign: objectAssign
	});

	// `Object.create` method
	// https://tc39.github.io/ecma262/#sec-object.create
	_export({
	  target: 'Object',
	  stat: true,
	  sham: !descriptors
	}, {
	  create: objectCreate
	});

	// Forced replacement object prototype accessors methods
	var objectPrototypeAccessorsForced =  !fails(function () {
	  var key = Math.random();
	  // In FF throws only define methods
	  // eslint-disable-next-line no-undef, no-useless-call
	  __defineSetter__.call(null, key, function () {/* empty */});
	  delete global_1[key];
	});

	// `Object.prototype.__defineGetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__defineGetter__
	if (descriptors) {
	  _export({
	    target: 'Object',
	    proto: true,
	    forced: objectPrototypeAccessorsForced
	  }, {
	    __defineGetter__: function __defineGetter__(P, getter) {
	      objectDefineProperty.f(toObject(this), P, {
	        get: aFunction$1(getter),
	        enumerable: true,
	        configurable: true
	      });
	    }
	  });
	}

	// `Object.defineProperties` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperties
	_export({
	  target: 'Object',
	  stat: true,
	  forced: !descriptors,
	  sham: !descriptors
	}, {
	  defineProperties: objectDefineProperties
	});

	// `Object.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-object.defineproperty
	_export({
	  target: 'Object',
	  stat: true,
	  forced: !descriptors,
	  sham: !descriptors
	}, {
	  defineProperty: objectDefineProperty.f
	});

	// `Object.prototype.__defineSetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__defineSetter__
	if (descriptors) {
	  _export({
	    target: 'Object',
	    proto: true,
	    forced: objectPrototypeAccessorsForced
	  }, {
	    __defineSetter__: function __defineSetter__(P, setter) {
	      objectDefineProperty.f(toObject(this), P, {
	        set: aFunction$1(setter),
	        enumerable: true,
	        configurable: true
	      });
	    }
	  });
	}

	var propertyIsEnumerable = objectPropertyIsEnumerable.f;

	// `Object.{ entries, values }` methods implementation
	var createMethod$5 = function createMethod(TO_ENTRIES) {
	  return function (it) {
	    var O = toIndexedObject(it);
	    var keys = objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!descriptors || propertyIsEnumerable.call(O, key)) {
	        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};
	var objectToArray = {
	  // `Object.entries` method
	  // https://tc39.github.io/ecma262/#sec-object.entries
	  entries: createMethod$5(true),
	  // `Object.values` method
	  // https://tc39.github.io/ecma262/#sec-object.values
	  values: createMethod$5(false)
	};

	var $entries = objectToArray.entries;

	// `Object.entries` method
	// https://tc39.github.io/ecma262/#sec-object.entries
	_export({
	  target: 'Object',
	  stat: true
	}, {
	  entries: function entries(O) {
	    return $entries(O);
	  }
	});

	var onFreeze = internalMetadata.onFreeze;
	var nativeFreeze = Object.freeze;
	var FAILS_ON_PRIMITIVES = fails(function () {
	  nativeFreeze(1);
	});

	// `Object.freeze` method
	// https://tc39.github.io/ecma262/#sec-object.freeze
	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES,
	  sham: !freezing
	}, {
	  freeze: function freeze(it) {
	    return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
	  }
	});

	// `Object.fromEntries` method
	// https://github.com/tc39/proposal-object-from-entries
	_export({
	  target: 'Object',
	  stat: true
	}, {
	  fromEntries: function fromEntries(iterable) {
	    var obj = {};
	    iterate_1(iterable, function (k, v) {
	      createProperty(obj, k, v);
	    }, undefined, true);
	    return obj;
	  }
	});

	var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;

	var FAILS_ON_PRIMITIVES$1 = fails(function () {
	  nativeGetOwnPropertyDescriptor$2(1);
	});
	var FORCED$b = !descriptors || FAILS_ON_PRIMITIVES$1;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
	_export({
	  target: 'Object',
	  stat: true,
	  forced: FORCED$b,
	  sham: !descriptors
	}, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
	    return nativeGetOwnPropertyDescriptor$2(toIndexedObject(it), key);
	  }
	});

	// `Object.getOwnPropertyDescriptors` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
	_export({
	  target: 'Object',
	  stat: true,
	  sham: !descriptors
	}, {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIndexedObject(object);
	    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var index = 0;
	    var key, descriptor;
	    while (keys.length > index) {
	      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
	      if (descriptor !== undefined) createProperty(result, key, descriptor);
	    }
	    return result;
	  }
	});

	var nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;
	var FAILS_ON_PRIMITIVES$2 = fails(function () {
	  return !Object.getOwnPropertyNames(1);
	});

	// `Object.getOwnPropertyNames` method
	// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$2
	}, {
	  getOwnPropertyNames: nativeGetOwnPropertyNames$2
	});

	var FAILS_ON_PRIMITIVES$3 = fails(function () {
	  objectGetPrototypeOf(1);
	});

	// `Object.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.getprototypeof
	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$3,
	  sham: !correctPrototypeGetter
	}, {
	  getPrototypeOf: function getPrototypeOf(it) {
	    return objectGetPrototypeOf(toObject(it));
	  }
	});

	// `SameValue` abstract operation
	// https://tc39.github.io/ecma262/#sec-samevalue
	var sameValue = Object.is || function is(x, y) {
	  // eslint-disable-next-line no-self-compare
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

	// `Object.is` method
	// https://tc39.github.io/ecma262/#sec-object.is
	_export({
	  target: 'Object',
	  stat: true
	}, {
	  is: sameValue
	});

	var nativeIsExtensible = Object.isExtensible;
	var FAILS_ON_PRIMITIVES$4 = fails(function () {
	  nativeIsExtensible(1);
	});

	// `Object.isExtensible` method
	// https://tc39.github.io/ecma262/#sec-object.isextensible
	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$4
	}, {
	  isExtensible: function isExtensible(it) {
	    return isObject(it) ? nativeIsExtensible ? nativeIsExtensible(it) : true : false;
	  }
	});

	var nativeIsFrozen = Object.isFrozen;
	var FAILS_ON_PRIMITIVES$5 = fails(function () {
	  nativeIsFrozen(1);
	});

	// `Object.isFrozen` method
	// https://tc39.github.io/ecma262/#sec-object.isfrozen
	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$5
	}, {
	  isFrozen: function isFrozen(it) {
	    return isObject(it) ? nativeIsFrozen ? nativeIsFrozen(it) : false : true;
	  }
	});

	var nativeIsSealed = Object.isSealed;
	var FAILS_ON_PRIMITIVES$6 = fails(function () {
	  nativeIsSealed(1);
	});

	// `Object.isSealed` method
	// https://tc39.github.io/ecma262/#sec-object.issealed
	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$6
	}, {
	  isSealed: function isSealed(it) {
	    return isObject(it) ? nativeIsSealed ? nativeIsSealed(it) : false : true;
	  }
	});

	var FAILS_ON_PRIMITIVES$7 = fails(function () {
	  objectKeys(1);
	});

	// `Object.keys` method
	// https://tc39.github.io/ecma262/#sec-object.keys
	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$7
	}, {
	  keys: function keys(it) {
	    return objectKeys(toObject(it));
	  }
	});

	var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;

	// `Object.prototype.__lookupGetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupGetter__
	if (descriptors) {
	  _export({
	    target: 'Object',
	    proto: true,
	    forced: objectPrototypeAccessorsForced
	  }, {
	    __lookupGetter__: function __lookupGetter__(P) {
	      var O = toObject(this);
	      var key = toPrimitive(P, true);
	      var desc;
	      do {
	        if (desc = getOwnPropertyDescriptor$3(O, key)) return desc.get;
	      } while (O = objectGetPrototypeOf(O));
	    }
	  });
	}

	var getOwnPropertyDescriptor$4 = objectGetOwnPropertyDescriptor.f;

	// `Object.prototype.__lookupSetter__` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupSetter__
	if (descriptors) {
	  _export({
	    target: 'Object',
	    proto: true,
	    forced: objectPrototypeAccessorsForced
	  }, {
	    __lookupSetter__: function __lookupSetter__(P) {
	      var O = toObject(this);
	      var key = toPrimitive(P, true);
	      var desc;
	      do {
	        if (desc = getOwnPropertyDescriptor$4(O, key)) return desc.set;
	      } while (O = objectGetPrototypeOf(O));
	    }
	  });
	}

	var onFreeze$1 = internalMetadata.onFreeze;


	var nativePreventExtensions = Object.preventExtensions;
	var FAILS_ON_PRIMITIVES$8 = fails(function () {
	  nativePreventExtensions(1);
	});

	// `Object.preventExtensions` method
	// https://tc39.github.io/ecma262/#sec-object.preventextensions
	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$8,
	  sham: !freezing
	}, {
	  preventExtensions: function preventExtensions(it) {
	    return nativePreventExtensions && isObject(it) ? nativePreventExtensions(onFreeze$1(it)) : it;
	  }
	});

	var onFreeze$2 = internalMetadata.onFreeze;


	var nativeSeal = Object.seal;
	var FAILS_ON_PRIMITIVES$9 = fails(function () {
	  nativeSeal(1);
	});

	// `Object.seal` method
	// https://tc39.github.io/ecma262/#sec-object.seal
	_export({
	  target: 'Object',
	  stat: true,
	  forced: FAILS_ON_PRIMITIVES$9,
	  sham: !freezing
	}, {
	  seal: function seal(it) {
	    return nativeSeal && isObject(it) ? nativeSeal(onFreeze$2(it)) : it;
	  }
	});

	// `Object.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-object.setprototypeof
	_export({
	  target: 'Object',
	  stat: true
	}, {
	  setPrototypeOf: objectSetPrototypeOf
	});

	// `Object.prototype.toString` method implementation
	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	var objectToString = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	// `Object.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
	if (!toStringTagSupport) {
	  redefine(Object.prototype, 'toString', objectToString, {
	    unsafe: true
	  });
	}

	var $values = objectToArray.values;

	// `Object.values` method
	// https://tc39.github.io/ecma262/#sec-object.values
	_export({
	  target: 'Object',
	  stat: true
	}, {
	  values: function values(O) {
	    return $values(O);
	  }
	});

	// `parseFloat` method
	// https://tc39.github.io/ecma262/#sec-parsefloat-string
	_export({
	  global: true,
	  forced: parseFloat != numberParseFloat
	}, {
	  parseFloat: numberParseFloat
	});

	// `parseInt` method
	// https://tc39.github.io/ecma262/#sec-parseint-string-radix
	_export({
	  global: true,
	  forced: parseInt != numberParseInt
	}, {
	  parseInt: numberParseInt
	});

	var nativePromiseConstructor = global_1.Promise;

	var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

	var location = global_1.location;
	var set$2 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$2 = global_1.process;
	var MessageChannel = global_1.MessageChannel;
	var Dispatch = global_1.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;
	var run = function run(id) {
	  // eslint-disable-next-line no-prototype-builtins
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var runner = function runner(id) {
	  return function () {
	    run(id);
	  };
	};
	var listener = function listener(event) {
	  run(event.data);
	};
	var post = function post(id) {
	  // old engines have not location.origin
	  global_1.postMessage(id + '', location.protocol + '//' + location.host);
	};

	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!set$2 || !clear) {
	  set$2 = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func
	      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clear = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (classofRaw(process$2) == 'process') {
	    defer = function defer(id) {
	      process$2.nextTick(runner(id));
	    };
	    // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function defer(id) {
	      Dispatch.now(runner(id));
	    };
	    // Browsers with MessageChannel, includes WebWorkers
	    // except iOS - https://github.com/zloirock/core-js/issues/624
	  } else if (MessageChannel && !engineIsIos) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = functionBindContext(port.postMessage, port, 1);
	    // Browsers with postMessage, skip WebWorkers
	    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (global_1.addEventListener && typeof postMessage == 'function' && !global_1.importScripts && !fails(post) && location.protocol !== 'file:') {
	    defer = post;
	    global_1.addEventListener('message', listener, false);
	    // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function defer(id) {
	      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run(id);
	      };
	    };
	    // Rest old browsers
	  } else {
	    defer = function defer(id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}
	var task = {
	  set: set$2,
	  clear: clear
	};

	var getOwnPropertyDescriptor$5 = objectGetOwnPropertyDescriptor.f;

	var macrotask = task.set;

	var MutationObserver$1 = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var process$3 = global_1.process;
	var Promise$1 = global_1.Promise;
	var IS_NODE = classofRaw(process$3) == 'process';
	// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$5(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
	var flush, head, last, notify, toggle, node, promise, then;

	// modern engines have queueMicrotask method
	if (!queueMicrotask) {
	  flush = function flush() {
	    var parent, fn;
	    if (IS_NODE && (parent = process$3.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (error) {
	        if (head) notify();else last = undefined;
	        throw error;
	      }
	    }
	    last = undefined;
	    if (parent) parent.enter();
	  };

	  // Node.js
	  if (IS_NODE) {
	    notify = function notify() {
	      process$3.nextTick(flush);
	    };
	    // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  } else if (MutationObserver$1 && !engineIsIos) {
	    toggle = true;
	    node = document.createTextNode('');
	    new MutationObserver$1(flush).observe(node, {
	      characterData: true
	    });
	    notify = function notify() {
	      node.data = toggle = !toggle;
	    };
	    // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise = Promise$1.resolve(undefined);
	    then = promise.then;
	    notify = function notify() {
	      then.call(promise, flush);
	    };
	    // for other environments - macrotask based on:
	    // - setImmediate
	    // - MessageChannel
	    // - window.postMessag
	    // - onreadystatechange
	    // - setTimeout
	  } else {
	    notify = function notify() {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global_1, flush);
	    };
	  }
	}
	var microtask = queueMicrotask || function (fn) {
	  var task = {
	    fn: fn,
	    next: undefined
	  };
	  if (last) last.next = task;
	  if (!head) {
	    head = task;
	    notify();
	  }
	  last = task;
	};

	var PromiseCapability = function PromiseCapability(C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction$1(resolve);
	  this.reject = aFunction$1(reject);
	};

	// 25.4.1.5 NewPromiseCapability(C)
	var f$7 = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability = {
		f: f$7
	};

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var hostReportErrors = function (a, b) {
	  var console = global_1.console;
	  if (console && console.error) {
	    arguments.length === 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform = function (exec) {
	  try {
	    return {
	      error: false,
	      value: exec()
	    };
	  } catch (error) {
	    return {
	      error: true,
	      value: error
	    };
	  }
	};

	var task$1 = task.set;









	var SPECIES$5 = wellKnownSymbol('species');
	var PROMISE = 'Promise';
	var getInternalState$3 = internalState.get;
	var setInternalState$4 = internalState.set;
	var getInternalPromiseState = internalState.getterFor(PROMISE);
	var PromiseConstructor = nativePromiseConstructor;
	var TypeError$1 = global_1.TypeError;
	var document$2 = global_1.document;
	var process$4 = global_1.process;
	var $fetch = getBuiltIn('fetch');
	var newPromiseCapability$1 = newPromiseCapability.f;
	var newGenericPromiseCapability = newPromiseCapability$1;
	var IS_NODE$1 = classofRaw(process$4) == 'process';
	var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
	var FORCED$c = isForced_1(PROMISE, function () {
	  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
	  if (!GLOBAL_CORE_JS_PROMISE) {
	    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	    // We can't detect it synchronously, so just check versions
	    if (engineV8Version === 66) return true;
	    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
	  }
	  // We can't use @@species feature detection in V8 since it causes
	  // deoptimization and performance degradation
	  // https://github.com/zloirock/core-js/issues/679
	  if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
	  // Detect correctness of subclassing with @@species support
	  var promise = PromiseConstructor.resolve(1);
	  var FakePromise = function FakePromise(exec) {
	    exec(function () {/* empty */}, function () {/* empty */});
	  };
	  var constructor = promise.constructor = {};
	  constructor[SPECIES$5] = FakePromise;
	  return !(promise.then(function () {/* empty */}) instanceof FakePromise);
	});
	var INCORRECT_ITERATION$1 = FORCED$c || !checkCorrectnessOfIteration(function (iterable) {
	  PromiseConstructor.all(iterable)['catch'](function () {/* empty */});
	});

	// helpers
	var isThenable = function isThenable(it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var notify$1 = function notify(promise, state, isReject) {
	  if (state.notified) return;
	  state.notified = true;
	  var chain = state.reactions;
	  microtask(function () {
	    var value = state.value;
	    var ok = state.state == FULFILLED;
	    var index = 0;
	    // variable length - can't use forEach
	    while (chain.length > index) {
	      var reaction = chain[index++];
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
	            state.rejection = HANDLED;
	          }
	          if (handler === true) result = value;else {
	            if (domain) domain.enter();
	            result = handler(value); // can throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (error) {
	        if (domain && !exited) domain.exit();
	        reject(error);
	      }
	    }
	    state.reactions = [];
	    state.notified = false;
	    if (isReject && !state.rejection) onUnhandled(promise, state);
	  });
	};
	var dispatchEvent = function dispatchEvent(name, promise, reason) {
	  var event, handler;
	  if (DISPATCH_EVENT) {
	    event = document$2.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global_1.dispatchEvent(event);
	  } else event = {
	    promise: promise,
	    reason: reason
	  };
	  if (handler = global_1['on' + name]) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
	};
	var onUnhandled = function onUnhandled(promise, state) {
	  task$1.call(global_1, function () {
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;
	    if (IS_UNHANDLED) {
	      result = perform(function () {
	        if (IS_NODE$1) {
	          process$4.emit('unhandledRejection', value, promise);
	        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) throw result.value;
	    }
	  });
	};
	var isUnhandled = function isUnhandled(state) {
	  return state.rejection !== HANDLED && !state.parent;
	};
	var onHandleUnhandled = function onHandleUnhandled(promise, state) {
	  task$1.call(global_1, function () {
	    if (IS_NODE$1) {
	      process$4.emit('rejectionHandled', promise);
	    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
	  });
	};
	var bind = function bind(fn, promise, state, unwrap) {
	  return function (value) {
	    fn(promise, state, value, unwrap);
	  };
	};
	var internalReject = function internalReject(promise, state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  state.value = value;
	  state.state = REJECTED;
	  notify$1(promise, state, true);
	};
	var internalResolve = function internalResolve(promise, state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  try {
	    if (promise === value) throw TypeError$1("Promise can't be resolved itself");
	    var then = isThenable(value);
	    if (then) {
	      microtask(function () {
	        var wrapper = {
	          done: false
	        };
	        try {
	          then.call(value, bind(internalResolve, promise, wrapper, state), bind(internalReject, promise, wrapper, state));
	        } catch (error) {
	          internalReject(promise, wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify$1(promise, state, false);
	    }
	  } catch (error) {
	    internalReject(promise, {
	      done: false
	    }, error, state);
	  }
	};

	// constructor polyfill
	if (FORCED$c) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromiseConstructor, PROMISE);
	    aFunction$1(executor);
	    Internal.call(this);
	    var state = getInternalState$3(this);
	    try {
	      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
	    } catch (error) {
	      internalReject(this, state, error);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars
	  Internal = function Promise(executor) {
	    setInternalState$4(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: [],
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };
	  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
	    // `Promise.prototype.then` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = IS_NODE$1 ? process$4.domain : undefined;
	      state.parent = true;
	      state.reactions.push(reaction);
	      if (state.state != PENDING) notify$1(this, state, false);
	      return reaction.promise;
	    },
	    // `Promise.prototype.catch` method
	    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
	    'catch': function _catch(onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function OwnPromiseCapability() {
	    var promise = new Internal();
	    var state = getInternalState$3(promise);
	    this.promise = promise;
	    this.resolve = bind(internalResolve, promise, state);
	    this.reject = bind(internalReject, promise, state);
	  };
	  newPromiseCapability.f = newPromiseCapability$1 = function newPromiseCapability(C) {
	    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
	  };
	  if ( typeof nativePromiseConstructor == 'function') {
	    nativeThen = nativePromiseConstructor.prototype.then;

	    // wrap native Promise#then for native async functions
	    redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
	      var that = this;
	      return new PromiseConstructor(function (resolve, reject) {
	        nativeThen.call(that, resolve, reject);
	      }).then(onFulfilled, onRejected);
	      // https://github.com/zloirock/core-js/issues/640
	    }, {
	      unsafe: true
	    });

	    // wrap fetch result
	    if (typeof $fetch == 'function') _export({
	      global: true,
	      enumerable: true,
	      forced: true
	    }, {
	      // eslint-disable-next-line no-unused-vars
	      fetch: function fetch(input /* , init */) {
	        return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
	      }
	    });
	  }
	}
	_export({
	  global: true,
	  wrap: true,
	  forced: FORCED$c
	}, {
	  Promise: PromiseConstructor
	});
	setToStringTag(PromiseConstructor, PROMISE, false);
	setSpecies(PROMISE);
	PromiseWrapper = getBuiltIn(PROMISE);

	// statics
	_export({
	  target: PROMISE,
	  stat: true,
	  forced: FORCED$c
	}, {
	  // `Promise.reject` method
	  // https://tc39.github.io/ecma262/#sec-promise.reject
	  reject: function reject(r) {
	    var capability = newPromiseCapability$1(this);
	    capability.reject.call(undefined, r);
	    return capability.promise;
	  }
	});
	_export({
	  target: PROMISE,
	  stat: true,
	  forced:  FORCED$c
	}, {
	  // `Promise.resolve` method
	  // https://tc39.github.io/ecma262/#sec-promise.resolve
	  resolve: function resolve(x) {
	    return promiseResolve( this, x);
	  }
	});
	_export({
	  target: PROMISE,
	  stat: true,
	  forced: INCORRECT_ITERATION$1
	}, {
	  // `Promise.all` method
	  // https://tc39.github.io/ecma262/#sec-promise.all
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate_1(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        $promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  },
	  // `Promise.race` method
	  // https://tc39.github.io/ecma262/#sec-promise.race
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction$1(C.resolve);
	      iterate_1(iterable, function (promise) {
	        $promiseResolve.call(C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
	var NON_GENERIC = !!nativePromiseConstructor && fails(function () {
	  nativePromiseConstructor.prototype['finally'].call({
	    then: function then() {/* empty */}
	  }, function () {/* empty */});
	});

	// `Promise.prototype.finally` method
	// https://tc39.github.io/ecma262/#sec-promise.prototype.finally
	_export({
	  target: 'Promise',
	  proto: true,
	  real: true,
	  forced: NON_GENERIC
	}, {
	  'finally': function _finally(onFinally) {
	    var C = speciesConstructor(this, getBuiltIn('Promise'));
	    var isFunction = typeof onFinally == 'function';
	    return this.then(isFunction ? function (x) {
	      return promiseResolve(C, onFinally()).then(function () {
	        return x;
	      });
	    } : onFinally, isFunction ? function (e) {
	      return promiseResolve(C, onFinally()).then(function () {
	        throw e;
	      });
	    } : onFinally);
	  }
	});

	// patch native Promise.prototype for native async functions
	if ( typeof nativePromiseConstructor == 'function' && !nativePromiseConstructor.prototype['finally']) {
	  redefine(nativePromiseConstructor.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
	}

	var nativeApply = getBuiltIn('Reflect', 'apply');
	var functionApply = Function.apply;

	// MS Edge argumentsList argument is optional
	var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
	  nativeApply(function () {/* empty */});
	});

	// `Reflect.apply` method
	// https://tc39.github.io/ecma262/#sec-reflect.apply
	_export({
	  target: 'Reflect',
	  stat: true,
	  forced: OPTIONAL_ARGUMENTS_LIST
	}, {
	  apply: function apply(target, thisArgument, argumentsList) {
	    aFunction$1(target);
	    anObject(argumentsList);
	    return nativeApply ? nativeApply(target, thisArgument, argumentsList) : functionApply.call(target, thisArgument, argumentsList);
	  }
	});

	var nativeConstruct = getBuiltIn('Reflect', 'construct');

	// `Reflect.construct` method
	// https://tc39.github.io/ecma262/#sec-reflect.construct
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function () {
	  function F() {/* empty */}
	  return !(nativeConstruct(function () {/* empty */}, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function () {
	  nativeConstruct(function () {/* empty */});
	});
	var FORCED$d = NEW_TARGET_BUG || ARGS_BUG;
	_export({
	  target: 'Reflect',
	  stat: true,
	  forced: FORCED$d,
	  sham: FORCED$d
	}, {
	  construct: function construct(Target, args /* , newTarget */) {
	    aFunction$1(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction$1(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0:
	          return new Target();
	        case 1:
	          return new Target(args[0]);
	        case 2:
	          return new Target(args[0], args[1]);
	        case 3:
	          return new Target(args[0], args[1], args[2]);
	        case 4:
	          return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (functionBind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = objectCreate(isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	var ERROR_INSTEAD_OF_FALSE = fails(function () {
	  // eslint-disable-next-line no-undef
	  Reflect.defineProperty(objectDefineProperty.f({}, 1, {
	    value: 1
	  }), 1, {
	    value: 2
	  });
	});

	// `Reflect.defineProperty` method
	// https://tc39.github.io/ecma262/#sec-reflect.defineproperty
	_export({
	  target: 'Reflect',
	  stat: true,
	  forced: ERROR_INSTEAD_OF_FALSE,
	  sham: !descriptors
	}, {
	  defineProperty: function defineProperty(target, propertyKey, attributes) {
	    anObject(target);
	    var key = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      objectDefineProperty.f(target, key, attributes);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	var getOwnPropertyDescriptor$6 = objectGetOwnPropertyDescriptor.f;

	// `Reflect.deleteProperty` method
	// https://tc39.github.io/ecma262/#sec-reflect.deleteproperty
	_export({
	  target: 'Reflect',
	  stat: true
	}, {
	  deleteProperty: function deleteProperty(target, propertyKey) {
	    var descriptor = getOwnPropertyDescriptor$6(anObject(target), propertyKey);
	    return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
	  }
	});

	// `Reflect.get` method
	// https://tc39.github.io/ecma262/#sec-reflect.get
	function get$2(target, propertyKey /* , receiver */) {
	  var receiver = arguments.length < 3 ? target : arguments[2];
	  var descriptor, prototype;
	  if (anObject(target) === receiver) return target[propertyKey];
	  if (descriptor = objectGetOwnPropertyDescriptor.f(target, propertyKey)) return has(descriptor, 'value') ? descriptor.value : descriptor.get === undefined ? undefined : descriptor.get.call(receiver);
	  if (isObject(prototype = objectGetPrototypeOf(target))) return get$2(prototype, propertyKey, receiver);
	}
	_export({
	  target: 'Reflect',
	  stat: true
	}, {
	  get: get$2
	});

	// `Reflect.getOwnPropertyDescriptor` method
	// https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor
	_export({
	  target: 'Reflect',
	  stat: true,
	  sham: !descriptors
	}, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
	    return objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
	  }
	});

	// `Reflect.getPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-reflect.getprototypeof
	_export({
	  target: 'Reflect',
	  stat: true,
	  sham: !correctPrototypeGetter
	}, {
	  getPrototypeOf: function getPrototypeOf(target) {
	    return objectGetPrototypeOf(anObject(target));
	  }
	});

	// `Reflect.has` method
	// https://tc39.github.io/ecma262/#sec-reflect.has
	_export({
	  target: 'Reflect',
	  stat: true
	}, {
	  has: function has(target, propertyKey) {
	    return propertyKey in target;
	  }
	});

	var objectIsExtensible = Object.isExtensible;

	// `Reflect.isExtensible` method
	// https://tc39.github.io/ecma262/#sec-reflect.isextensible
	_export({
	  target: 'Reflect',
	  stat: true
	}, {
	  isExtensible: function isExtensible(target) {
	    anObject(target);
	    return objectIsExtensible ? objectIsExtensible(target) : true;
	  }
	});

	// `Reflect.ownKeys` method
	// https://tc39.github.io/ecma262/#sec-reflect.ownkeys
	_export({
	  target: 'Reflect',
	  stat: true
	}, {
	  ownKeys: ownKeys
	});

	// `Reflect.preventExtensions` method
	// https://tc39.github.io/ecma262/#sec-reflect.preventextensions
	_export({
	  target: 'Reflect',
	  stat: true,
	  sham: !freezing
	}, {
	  preventExtensions: function preventExtensions(target) {
	    anObject(target);
	    try {
	      var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
	      if (objectPreventExtensions) objectPreventExtensions(target);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	// `Reflect.set` method
	// https://tc39.github.io/ecma262/#sec-reflect.set
	function set$3(target, propertyKey, V /* , receiver */) {
	  var receiver = arguments.length < 4 ? target : arguments[3];
	  var ownDescriptor = objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
	  var existingDescriptor, prototype;
	  if (!ownDescriptor) {
	    if (isObject(prototype = objectGetPrototypeOf(target))) {
	      return set$3(prototype, propertyKey, V, receiver);
	    }
	    ownDescriptor = createPropertyDescriptor(0);
	  }
	  if (has(ownDescriptor, 'value')) {
	    if (ownDescriptor.writable === false || !isObject(receiver)) return false;
	    if (existingDescriptor = objectGetOwnPropertyDescriptor.f(receiver, propertyKey)) {
	      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
	      existingDescriptor.value = V;
	      objectDefineProperty.f(receiver, propertyKey, existingDescriptor);
	    } else objectDefineProperty.f(receiver, propertyKey, createPropertyDescriptor(0, V));
	    return true;
	  }
	  return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);
	}

	// MS Edge 17-18 Reflect.set allows setting the property to object
	// with non-writable property on the prototype
	var MS_EDGE_BUG = fails(function () {
	  var object = objectDefineProperty.f({}, 'a', {
	    configurable: true
	  });
	  // eslint-disable-next-line no-undef
	  return Reflect.set(objectGetPrototypeOf(object), 'a', 1, object) !== false;
	});
	_export({
	  target: 'Reflect',
	  stat: true,
	  forced: MS_EDGE_BUG
	}, {
	  set: set$3
	});

	// `Reflect.setPrototypeOf` method
	// https://tc39.github.io/ecma262/#sec-reflect.setprototypeof
	if (objectSetPrototypeOf) _export({
	  target: 'Reflect',
	  stat: true
	}, {
	  setPrototypeOf: function setPrototypeOf(target, proto) {
	    anObject(target);
	    aPossiblePrototype(proto);
	    try {
	      objectSetPrototypeOf(target, proto);
	      return true;
	    } catch (error) {
	      return false;
	    }
	  }
	});

	var MATCH = wellKnownSymbol('match');

	// `IsRegExp` abstract operation
	// https://tc39.github.io/ecma262/#sec-isregexp
	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	// `RegExp.prototype.flags` getter implementation
	// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
	var regexpFlags = function () {
	  var that = anObject(this);
	  var result = '';
	  if (that.global) result += 'g';
	  if (that.ignoreCase) result += 'i';
	  if (that.multiline) result += 'm';
	  if (that.dotAll) result += 's';
	  if (that.unicode) result += 'u';
	  if (that.sticky) result += 'y';
	  return result;
	};

	// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
	// so we use an intermediate function.
	function RE(s, f) {
	  return RegExp(s, f);
	}
	var UNSUPPORTED_Y = fails(function () {
	  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
	  var re = RE('a', 'y');
	  re.lastIndex = 2;
	  return re.exec('abcd') != null;
	});
	var BROKEN_CARET = fails(function () {
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
	  var re = RE('^r', 'gy');
	  re.lastIndex = 2;
	  return re.exec('str') != null;
	});

	var regexpStickyHelpers = {
		UNSUPPORTED_Y: UNSUPPORTED_Y,
		BROKEN_CARET: BROKEN_CARET
	};

	var defineProperty$a = objectDefineProperty.f;
	var getOwnPropertyNames$2 = objectGetOwnPropertyNames.f;





	var setInternalState$5 = internalState.set;


	var MATCH$1 = wellKnownSymbol('match');
	var NativeRegExp = global_1.RegExp;
	var RegExpPrototype = NativeRegExp.prototype;
	var re1 = /a/g;
	var re2 = /a/g;

	// "new" should create a new object, old webkit bug
	var CORRECT_NEW = new NativeRegExp(re1) !== re1;
	var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y;
	var FORCED$e = descriptors && isForced_1('RegExp', !CORRECT_NEW || UNSUPPORTED_Y$1 || fails(function () {
	  re2[MATCH$1] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
	}));

	// `RegExp` constructor
	// https://tc39.github.io/ecma262/#sec-regexp-constructor
	if (FORCED$e) {
	  var RegExpWrapper = function RegExp(pattern, flags) {
	    var thisIsRegExp = this instanceof RegExpWrapper;
	    var patternIsRegExp = isRegexp(pattern);
	    var flagsAreUndefined = flags === undefined;
	    var sticky;
	    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
	      return pattern;
	    }
	    if (CORRECT_NEW) {
	      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
	    } else if (pattern instanceof RegExpWrapper) {
	      if (flagsAreUndefined) flags = regexpFlags.call(pattern);
	      pattern = pattern.source;
	    }
	    if (UNSUPPORTED_Y$1) {
	      sticky = !!flags && flags.indexOf('y') > -1;
	      if (sticky) flags = flags.replace(/y/g, '');
	    }
	    var result = inheritIfRequired(CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
	    if (UNSUPPORTED_Y$1 && sticky) setInternalState$5(result, {
	      sticky: sticky
	    });
	    return result;
	  };
	  var proxy = function proxy(key) {
	    key in RegExpWrapper || defineProperty$a(RegExpWrapper, key, {
	      configurable: true,
	      get: function get() {
	        return NativeRegExp[key];
	      },
	      set: function set(it) {
	        NativeRegExp[key] = it;
	      }
	    });
	  };
	  var keys$3 = getOwnPropertyNames$2(NativeRegExp);
	  var index = 0;
	  while (keys$3.length > index) proxy(keys$3[index++]);
	  RegExpPrototype.constructor = RegExpWrapper;
	  RegExpWrapper.prototype = RegExpPrototype;
	  redefine(global_1, 'RegExp', RegExpWrapper);
	}

	// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
	setSpecies('RegExp');

	var nativeExec = RegExp.prototype.exec;
	// This always refers to the native implementation, because the
	// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
	// which loads this file before patching the method.
	var nativeReplace = String.prototype.replace;
	var patchedExec = nativeExec;
	var UPDATES_LAST_INDEX_WRONG = function () {
	  var re1 = /a/;
	  var re2 = /b*/g;
	  nativeExec.call(re1, 'a');
	  nativeExec.call(re2, 'a');
	  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
	}();
	var UNSUPPORTED_Y$2 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

	// nonparticipating capturing group, copied from es5-shim's String#split patch.
	var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
	var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$2;
	if (PATCH) {
	  patchedExec = function exec(str) {
	    var re = this;
	    var lastIndex, reCopy, match, i;
	    var sticky = UNSUPPORTED_Y$2 && re.sticky;
	    var flags = regexpFlags.call(re);
	    var source = re.source;
	    var charsAdded = 0;
	    var strCopy = str;
	    if (sticky) {
	      flags = flags.replace('y', '');
	      if (flags.indexOf('g') === -1) {
	        flags += 'g';
	      }
	      strCopy = String(str).slice(re.lastIndex);
	      // Support anchored sticky behavior.
	      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
	        source = '(?: ' + source + ')';
	        strCopy = ' ' + strCopy;
	        charsAdded++;
	      }
	      // ^(? + rx + ) is needed, in combination with some str slicing, to
	      // simulate the 'y' flag.
	      reCopy = new RegExp('^(?:' + source + ')', flags);
	    }
	    if (NPCG_INCLUDED) {
	      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
	    }
	    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
	    match = nativeExec.call(sticky ? reCopy : re, strCopy);
	    if (sticky) {
	      if (match) {
	        match.input = match.input.slice(charsAdded);
	        match[0] = match[0].slice(charsAdded);
	        match.index = re.lastIndex;
	        re.lastIndex += match[0].length;
	      } else re.lastIndex = 0;
	    } else if (UPDATES_LAST_INDEX_WRONG && match) {
	      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
	    }
	    if (NPCG_INCLUDED && match && match.length > 1) {
	      // Fix browsers whose `exec` methods don't consistently return `undefined`
	      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
	      nativeReplace.call(match[0], reCopy, function () {
	        for (i = 1; i < arguments.length - 2; i++) {
	          if (arguments[i] === undefined) match[i] = undefined;
	        }
	      });
	    }
	    return match;
	  };
	}
	var regexpExec = patchedExec;

	_export({
	  target: 'RegExp',
	  proto: true,
	  forced: /./.exec !== regexpExec
	}, {
	  exec: regexpExec
	});

	var UNSUPPORTED_Y$3 = regexpStickyHelpers.UNSUPPORTED_Y;

	// `RegExp.prototype.flags` getter
	// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
	if (descriptors && (/./g.flags != 'g' || UNSUPPORTED_Y$3)) {
	  objectDefineProperty.f(RegExp.prototype, 'flags', {
	    configurable: true,
	    get: regexpFlags
	  });
	}

	var TO_STRING$1 = 'toString';
	var RegExpPrototype$1 = RegExp.prototype;
	var nativeToString = RegExpPrototype$1[TO_STRING$1];
	var NOT_GENERIC = fails(function () {
	  return nativeToString.call({
	    source: 'a',
	    flags: 'b'
	  }) != '/a/b';
	});
	// FF44- RegExp#toString has a wrong name
	var INCORRECT_NAME = nativeToString.name != TO_STRING$1;

	// `RegExp.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
	if (NOT_GENERIC || INCORRECT_NAME) {
	  redefine(RegExp.prototype, TO_STRING$1, function toString() {
	    var R = anObject(this);
	    var p = String(R.source);
	    var rf = R.flags;
	    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype$1) ? regexpFlags.call(R) : rf);
	    return '/' + p + '/' + f;
	  }, {
	    unsafe: true
	  });
	}

	// `Set` constructor
	// https://tc39.github.io/ecma262/#sec-set-objects
	var es_set = collection('Set', function (init) {
	  return function Set() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	}, collectionStrong);

	// `String.prototype.{ codePointAt, at }` methods implementation
	var createMethod$6 = function createMethod(CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = String(requireObjectCoercible($this));
	    var position = toInteger(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = S.charCodeAt(position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};
	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$6(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$6(true)
	};

	var codeAt = stringMultibyte.codeAt;

	// `String.prototype.codePointAt` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
	_export({
	  target: 'String',
	  proto: true
	}, {
	  codePointAt: function codePointAt(pos) {
	    return codeAt(this, pos);
	  }
	});

	var notARegexp = function (it) {
	  if (isRegexp(it)) {
	    throw TypeError("The method doesn't accept regular expressions");
	  }
	  return it;
	};

	var MATCH$2 = wellKnownSymbol('match');
	var correctIsRegexpLogic = function (METHOD_NAME) {
	  var regexp = /./;
	  try {
	    '/./'[METHOD_NAME](regexp);
	  } catch (e) {
	    try {
	      regexp[MATCH$2] = false;
	      return '/./'[METHOD_NAME](regexp);
	    } catch (f) {/* empty */}
	  }
	  return false;
	};

	var getOwnPropertyDescriptor$7 = objectGetOwnPropertyDescriptor.f;





	var nativeEndsWith = ''.endsWith;
	var min$5 = Math.min;
	var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('endsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG =  !CORRECT_IS_REGEXP_LOGIC && !!function () {
	  var descriptor = getOwnPropertyDescriptor$7(String.prototype, 'endsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.endsWith` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.endswith
	_export({
	  target: 'String',
	  proto: true,
	  forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
	}, {
	  endsWith: function endsWith(searchString /* , endPosition = @length */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
	    var len = toLength(that.length);
	    var end = endPosition === undefined ? len : min$5(toLength(endPosition), len);
	    var search = String(searchString);
	    return nativeEndsWith ? nativeEndsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
	  }
	});

	var fromCharCode = String.fromCharCode;
	var nativeFromCodePoint = String.fromCodePoint;

	// length should be 1, old FF problem
	var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1;

	// `String.fromCodePoint` method
	// https://tc39.github.io/ecma262/#sec-string.fromcodepoint
	_export({
	  target: 'String',
	  stat: true,
	  forced: INCORRECT_LENGTH
	}, {
	  fromCodePoint: function fromCodePoint(x) {
	    // eslint-disable-line no-unused-vars
	    var elements = [];
	    var length = arguments.length;
	    var i = 0;
	    var code;
	    while (length > i) {
	      code = +arguments[i++];
	      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point');
	      elements.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00));
	    }
	    return elements.join('');
	  }
	});

	// `String.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.includes
	_export({
	  target: 'String',
	  proto: true,
	  forced: !correctIsRegexpLogic('includes')
	}, {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~String(requireObjectCoercible(this)).indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var charAt = stringMultibyte.charAt;


	var STRING_ITERATOR = 'String Iterator';
	var setInternalState$6 = internalState.set;
	var getInternalState$4 = internalState.getterFor(STRING_ITERATOR);

	// `String.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String', function (iterated) {
	  setInternalState$6(this, {
	    type: STRING_ITERATOR,
	    string: String(iterated),
	    index: 0
	  });
	  // `%StringIteratorPrototype%.next` method
	  // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState$4(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return {
	    value: undefined,
	    done: true
	  };
	  point = charAt(string, index);
	  state.index += point.length;
	  return {
	    value: point,
	    done: false
	  };
	});

	// TODO: Remove from `core-js@4` since it's moved to entry points






	var SPECIES$6 = wellKnownSymbol('species');
	var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
	  // #replace needs built-in support for named groups.
	  // #match works fine because it just return the exec results, even if it has
	  // a "grops" property.
	  var re = /./;
	  re.exec = function () {
	    var result = [];
	    result.groups = {
	      a: '7'
	    };
	    return result;
	  };
	  return ''.replace(re, '$<a>') !== '7';
	});

	// IE <= 11 replaces $0 with the whole match, as if it was $&
	// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
	var REPLACE_KEEPS_$0 = function () {
	  return 'a'.replace(/./, '$0') === '$0';
	}();
	var REPLACE = wellKnownSymbol('replace');
	// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
	var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
	  if (/./[REPLACE]) {
	    return /./[REPLACE]('a', '$0') === '';
	  }
	  return false;
	}();

	// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
	// Weex JS has frozen built-in prototypes, so use try / catch wrapper
	var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
	  var re = /(?:)/;
	  var originalExec = re.exec;
	  re.exec = function () {
	    return originalExec.apply(this, arguments);
	  };
	  var result = 'ab'.split(re);
	  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
	});
	var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
	  var SYMBOL = wellKnownSymbol(KEY);
	  var DELEGATES_TO_SYMBOL = !fails(function () {
	    // String methods call symbol-named RegEp methods
	    var O = {};
	    O[SYMBOL] = function () {
	      return 7;
	    };
	    return ''[KEY](O) != 7;
	  });
	  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
	    // Symbol-named RegExp methods call .exec
	    var execCalled = false;
	    var re = /a/;
	    if (KEY === 'split') {
	      // We can't use real regex here since it causes deoptimization
	      // and serious performance degradation in V8
	      // https://github.com/zloirock/core-js/issues/306
	      re = {};
	      // RegExp[@@split] doesn't call the regex's exec method, but first creates
	      // a new one. We need to return the patched regex when creating the new one.
	      re.constructor = {};
	      re.constructor[SPECIES$6] = function () {
	        return re;
	      };
	      re.flags = '';
	      re[SYMBOL] = /./[SYMBOL];
	    }
	    re.exec = function () {
	      execCalled = true;
	      return null;
	    };
	    re[SYMBOL]('');
	    return !execCalled;
	  });
	  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
	    var nativeRegExpMethod = /./[SYMBOL];
	    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
	      if (regexp.exec === regexpExec) {
	        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
	          // The native String method already delegates to @@method (this
	          // polyfilled function), leasing to infinite recursion.
	          // We avoid it by directly calling the native @@method method.
	          return {
	            done: true,
	            value: nativeRegExpMethod.call(regexp, str, arg2)
	          };
	        }
	        return {
	          done: true,
	          value: nativeMethod.call(str, regexp, arg2)
	        };
	      }
	      return {
	        done: false
	      };
	    }, {
	      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
	      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
	    });
	    var stringMethod = methods[0];
	    var regexMethod = methods[1];
	    redefine(String.prototype, KEY, stringMethod);
	    redefine(RegExp.prototype, SYMBOL, length == 2
	    // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	    ? function (string, arg) {
	      return regexMethod.call(string, this, arg);
	    }
	    // 21.2.5.6 RegExp.prototype[@@match](string)
	    // 21.2.5.9 RegExp.prototype[@@search](string)
	    : function (string) {
	      return regexMethod.call(string, this);
	    });
	  }
	  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
	};

	var charAt$1 = stringMultibyte.charAt;

	// `AdvanceStringIndex` abstract operation
	// https://tc39.github.io/ecma262/#sec-advancestringindex
	var advanceStringIndex = function (S, index, unicode) {
	  return index + (unicode ? charAt$1(S, index).length : 1);
	};

	// `RegExpExec` abstract operation
	// https://tc39.github.io/ecma262/#sec-regexpexec
	var regexpExecAbstract = function (R, S) {
	  var exec = R.exec;
	  if (typeof exec === 'function') {
	    var result = exec.call(R, S);
	    if (typeof result !== 'object') {
	      throw TypeError('RegExp exec method returned something other than an Object or null');
	    }
	    return result;
	  }
	  if (classofRaw(R) !== 'RegExp') {
	    throw TypeError('RegExp#exec called on incompatible receiver');
	  }
	  return regexpExec.call(R, S);
	};

	// @@match logic
	fixRegexpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
	  return [
	  // `String.prototype.match` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.match
	  function match(regexp) {
	    var O = requireObjectCoercible(this);
	    var matcher = regexp == undefined ? undefined : regexp[MATCH];
	    return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  },
	  // `RegExp.prototype[@@match]` method
	  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
	  function (regexp) {
	    var res = maybeCallNative(nativeMatch, regexp, this);
	    if (res.done) return res.value;
	    var rx = anObject(regexp);
	    var S = String(this);
	    if (!rx.global) return regexpExecAbstract(rx, S);
	    var fullUnicode = rx.unicode;
	    rx.lastIndex = 0;
	    var A = [];
	    var n = 0;
	    var result;
	    while ((result = regexpExecAbstract(rx, S)) !== null) {
	      var matchStr = String(result[0]);
	      A[n] = matchStr;
	      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	      n++;
	    }
	    return n === 0 ? null : A;
	  }];
	});

	// https://github.com/zloirock/core-js/issues/280


	// eslint-disable-next-line unicorn/no-unsafe-regex
	var stringPadWebkitBug = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(engineUserAgent);

	var $padEnd = stringPad.end;


	// `String.prototype.padEnd` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.padend
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringPadWebkitBug
	}, {
	  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
	    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var $padStart = stringPad.start;


	// `String.prototype.padStart` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.padstart
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringPadWebkitBug
	}, {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// `String.raw` method
	// https://tc39.github.io/ecma262/#sec-string.raw
	_export({
	  target: 'String',
	  stat: true
	}, {
	  raw: function raw(template) {
	    var rawTemplate = toIndexedObject(template.raw);
	    var literalSegments = toLength(rawTemplate.length);
	    var argumentsLength = arguments.length;
	    var elements = [];
	    var i = 0;
	    while (literalSegments > i) {
	      elements.push(String(rawTemplate[i++]));
	      if (i < argumentsLength) elements.push(String(arguments[i]));
	    }
	    return elements.join('');
	  }
	});

	// `String.prototype.repeat` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
	_export({
	  target: 'String',
	  proto: true
	}, {
	  repeat: stringRepeat
	});

	var max$3 = Math.max;
	var min$6 = Math.min;
	var floor$6 = Math.floor;
	var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
	var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
	var maybeToString = function maybeToString(it) {
	  return it === undefined ? it : String(it);
	};

	// @@replace logic
	fixRegexpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
	  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
	  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
	  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
	  return [
	  // `String.prototype.replace` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
	  function replace(searchValue, replaceValue) {
	    var O = requireObjectCoercible(this);
	    var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
	  },
	  // `RegExp.prototype[@@replace]` method
	  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
	  function (regexp, replaceValue) {
	    if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
	      var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
	      if (res.done) return res.value;
	    }
	    var rx = anObject(regexp);
	    var S = String(this);
	    var functionalReplace = typeof replaceValue === 'function';
	    if (!functionalReplace) replaceValue = String(replaceValue);
	    var global = rx.global;
	    if (global) {
	      var fullUnicode = rx.unicode;
	      rx.lastIndex = 0;
	    }
	    var results = [];
	    while (true) {
	      var result = regexpExecAbstract(rx, S);
	      if (result === null) break;
	      results.push(result);
	      if (!global) break;
	      var matchStr = String(result[0]);
	      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
	    }
	    var accumulatedResult = '';
	    var nextSourcePosition = 0;
	    for (var i = 0; i < results.length; i++) {
	      result = results[i];
	      var matched = String(result[0]);
	      var position = max$3(min$6(toInteger(result.index), S.length), 0);
	      var captures = [];
	      // NOTE: This is equivalent to
	      //   captures = result.slice(1).map(maybeToString)
	      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
	      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
	      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
	      for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
	      var namedCaptures = result.groups;
	      if (functionalReplace) {
	        var replacerArgs = [matched].concat(captures, position, S);
	        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
	        var replacement = String(replaceValue.apply(undefined, replacerArgs));
	      } else {
	        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
	      }
	      if (position >= nextSourcePosition) {
	        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
	        nextSourcePosition = position + matched.length;
	      }
	    }
	    return accumulatedResult + S.slice(nextSourcePosition);
	  }];

	  // https://tc39.github.io/ecma262/#sec-getsubstitution
	  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
	    var tailPos = position + matched.length;
	    var m = captures.length;
	    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
	    if (namedCaptures !== undefined) {
	      namedCaptures = toObject(namedCaptures);
	      symbols = SUBSTITUTION_SYMBOLS;
	    }
	    return nativeReplace.call(replacement, symbols, function (match, ch) {
	      var capture;
	      switch (ch.charAt(0)) {
	        case '$':
	          return '$';
	        case '&':
	          return matched;
	        case '`':
	          return str.slice(0, position);
	        case "'":
	          return str.slice(tailPos);
	        case '<':
	          capture = namedCaptures[ch.slice(1, -1)];
	          break;
	        default:
	          // \d\d?
	          var n = +ch;
	          if (n === 0) return match;
	          if (n > m) {
	            var f = floor$6(n / 10);
	            if (f === 0) return match;
	            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
	            return match;
	          }
	          capture = captures[n - 1];
	      }
	      return capture === undefined ? '' : capture;
	    });
	  }
	});

	// @@search logic
	fixRegexpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
	  return [
	  // `String.prototype.search` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.search
	  function search(regexp) {
	    var O = requireObjectCoercible(this);
	    var searcher = regexp == undefined ? undefined : regexp[SEARCH];
	    return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  },
	  // `RegExp.prototype[@@search]` method
	  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
	  function (regexp) {
	    var res = maybeCallNative(nativeSearch, regexp, this);
	    if (res.done) return res.value;
	    var rx = anObject(regexp);
	    var S = String(this);
	    var previousLastIndex = rx.lastIndex;
	    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
	    var result = regexpExecAbstract(rx, S);
	    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
	    return result === null ? -1 : result.index;
	  }];
	});

	var arrayPush = [].push;
	var min$7 = Math.min;
	var MAX_UINT32 = 0xFFFFFFFF;

	// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
	var SUPPORTS_Y = !fails(function () {
	  return !RegExp(MAX_UINT32, 'y');
	});

	// @@split logic
	fixRegexpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
	  var internalSplit;
	  if ('abbc'.split(/(b)*/)[1] == 'c' || 'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
	    // based on es5-shim implementation, need to rework it
	    internalSplit = function internalSplit(separator, limit) {
	      var string = String(requireObjectCoercible(this));
	      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	      if (lim === 0) return [];
	      if (separator === undefined) return [string];
	      // If `separator` is not a regex, use native split
	      if (!isRegexp(separator)) {
	        return nativeSplit.call(string, separator, lim);
	      }
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var match, lastIndex, lastLength;
	      while (match = regexpExec.call(separatorCopy, string)) {
	        lastIndex = separatorCopy.lastIndex;
	        if (lastIndex > lastLastIndex) {
	          output.push(string.slice(lastLastIndex, match.index));
	          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
	          lastLength = match[0].length;
	          lastLastIndex = lastIndex;
	          if (output.length >= lim) break;
	        }
	        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
	      }
	      if (lastLastIndex === string.length) {
	        if (lastLength || !separatorCopy.test('')) output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output.length > lim ? output.slice(0, lim) : output;
	    };
	    // Chakra, V8
	  } else if ('0'.split(undefined, 0).length) {
	    internalSplit = function internalSplit(separator, limit) {
	      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
	    };
	  } else internalSplit = nativeSplit;
	  return [
	  // `String.prototype.split` method
	  // https://tc39.github.io/ecma262/#sec-string.prototype.split
	  function split(separator, limit) {
	    var O = requireObjectCoercible(this);
	    var splitter = separator == undefined ? undefined : separator[SPLIT];
	    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
	  },
	  // `RegExp.prototype[@@split]` method
	  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
	  //
	  // NOTE: This cannot be properly polyfilled in engines that don't support
	  // the 'y' flag.
	  function (regexp, limit) {
	    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
	    if (res.done) return res.value;
	    var rx = anObject(regexp);
	    var S = String(this);
	    var C = speciesConstructor(rx, RegExp);
	    var unicodeMatching = rx.unicode;
	    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g');

	    // ^(? + rx + ) is needed, in combination with some S slicing, to
	    // simulate the 'y' flag.
	    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
	    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
	    if (lim === 0) return [];
	    if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
	    var p = 0;
	    var q = 0;
	    var A = [];
	    while (q < S.length) {
	      splitter.lastIndex = SUPPORTS_Y ? q : 0;
	      var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
	      var e;
	      if (z === null || (e = min$7(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
	        q = advanceStringIndex(S, q, unicodeMatching);
	      } else {
	        A.push(S.slice(p, q));
	        if (A.length === lim) return A;
	        for (var i = 1; i <= z.length - 1; i++) {
	          A.push(z[i]);
	          if (A.length === lim) return A;
	        }
	        q = p = e;
	      }
	    }
	    A.push(S.slice(p));
	    return A;
	  }];
	}, !SUPPORTS_Y);

	var getOwnPropertyDescriptor$8 = objectGetOwnPropertyDescriptor.f;





	var nativeStartsWith = ''.startsWith;
	var min$8 = Math.min;
	var CORRECT_IS_REGEXP_LOGIC$1 = correctIsRegexpLogic('startsWith');
	// https://github.com/zloirock/core-js/pull/702
	var MDN_POLYFILL_BUG$1 =  !CORRECT_IS_REGEXP_LOGIC$1 && !!function () {
	  var descriptor = getOwnPropertyDescriptor$8(String.prototype, 'startsWith');
	  return descriptor && !descriptor.writable;
	}();

	// `String.prototype.startsWith` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.startswith
	_export({
	  target: 'String',
	  proto: true,
	  forced: !MDN_POLYFILL_BUG$1 && !CORRECT_IS_REGEXP_LOGIC$1
	}, {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var index = toLength(min$8(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
	  }
	});

	var non = "\u200B\x85\u180E";

	// check that a method works with the correct list
	// of whitespaces and has a correct name
	var stringTrimForced = function (METHOD_NAME) {
	  return fails(function () {
	    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
	  });
	};

	var $trim = stringTrim.trim;


	// `String.prototype.trim` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.trim
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringTrimForced('trim')
	}, {
	  trim: function trim() {
	    return $trim(this);
	  }
	});

	var $trimEnd = stringTrim.end;

	var FORCED$f = stringTrimForced('trimEnd');
	var trimEnd = FORCED$f ? function trimEnd() {
	  return $trimEnd(this);
	} : ''.trimEnd;

	// `String.prototype.{ trimEnd, trimRight }` methods
	// https://github.com/tc39/ecmascript-string-left-right-trim
	_export({
	  target: 'String',
	  proto: true,
	  forced: FORCED$f
	}, {
	  trimEnd: trimEnd,
	  trimRight: trimEnd
	});

	var $trimStart = stringTrim.start;

	var FORCED$g = stringTrimForced('trimStart');
	var trimStart = FORCED$g ? function trimStart() {
	  return $trimStart(this);
	} : ''.trimStart;

	// `String.prototype.{ trimStart, trimLeft }` methods
	// https://github.com/tc39/ecmascript-string-left-right-trim
	_export({
	  target: 'String',
	  proto: true,
	  forced: FORCED$g
	}, {
	  trimStart: trimStart,
	  trimLeft: trimStart
	});

	var quot = /"/g;

	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	// https://tc39.github.io/ecma262/#sec-createhtml
	var createHtml = function (string, tag, attribute, value) {
	  var S = String(requireObjectCoercible(string));
	  var p1 = '<' + tag;
	  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};

	// check the existence of a method, lowercase
	// of a tag and escaping quotes in arguments
	var stringHtmlForced = function (METHOD_NAME) {
	  return fails(function () {
	    var test = ''[METHOD_NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  });
	};

	// `String.prototype.anchor` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.anchor
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('anchor')
	}, {
	  anchor: function anchor(name) {
	    return createHtml(this, 'a', 'name', name);
	  }
	});

	// `String.prototype.big` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.big
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('big')
	}, {
	  big: function big() {
	    return createHtml(this, 'big', '', '');
	  }
	});

	// `String.prototype.blink` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.blink
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('blink')
	}, {
	  blink: function blink() {
	    return createHtml(this, 'blink', '', '');
	  }
	});

	// `String.prototype.bold` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.bold
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('bold')
	}, {
	  bold: function bold() {
	    return createHtml(this, 'b', '', '');
	  }
	});

	// `String.prototype.fixed` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.fixed
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('fixed')
	}, {
	  fixed: function fixed() {
	    return createHtml(this, 'tt', '', '');
	  }
	});

	// `String.prototype.fontcolor` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.fontcolor
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('fontcolor')
	}, {
	  fontcolor: function fontcolor(color) {
	    return createHtml(this, 'font', 'color', color);
	  }
	});

	// `String.prototype.fontsize` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.fontsize
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('fontsize')
	}, {
	  fontsize: function fontsize(size) {
	    return createHtml(this, 'font', 'size', size);
	  }
	});

	// `String.prototype.italics` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.italics
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('italics')
	}, {
	  italics: function italics() {
	    return createHtml(this, 'i', '', '');
	  }
	});

	// `String.prototype.link` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.link
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('link')
	}, {
	  link: function link(url) {
	    return createHtml(this, 'a', 'href', url);
	  }
	});

	// `String.prototype.small` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.small
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('small')
	}, {
	  small: function small() {
	    return createHtml(this, 'small', '', '');
	  }
	});

	// `String.prototype.strike` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.strike
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('strike')
	}, {
	  strike: function strike() {
	    return createHtml(this, 'strike', '', '');
	  }
	});

	// `String.prototype.sub` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.sub
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('sub')
	}, {
	  sub: function sub() {
	    return createHtml(this, 'sub', '', '');
	  }
	});

	// `String.prototype.sup` method
	// https://tc39.github.io/ecma262/#sec-string.prototype.sup
	_export({
	  target: 'String',
	  proto: true,
	  forced: stringHtmlForced('sup')
	}, {
	  sup: function sup() {
	    return createHtml(this, 'sup', '', '');
	  }
	});

	/* eslint-disable no-new */



	var NATIVE_ARRAY_BUFFER_VIEWS$2 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
	var ArrayBuffer$3 = global_1.ArrayBuffer;
	var Int8Array$2 = global_1.Int8Array;
	var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$2 || !fails(function () {
	  Int8Array$2(1);
	}) || !fails(function () {
	  new Int8Array$2(-1);
	}) || !checkCorrectnessOfIteration(function (iterable) {
	  new Int8Array$2();
	  new Int8Array$2(null);
	  new Int8Array$2(1.5);
	  new Int8Array$2(iterable);
	}, true) || fails(function () {
	  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
	  return new Int8Array$2(new ArrayBuffer$3(2), 1, undefined).length !== 1;
	});

	var toPositiveInteger = function (it) {
	  var result = toInteger(it);
	  if (result < 0) throw RangeError("The argument can't be less than 0");
	  return result;
	};

	var toOffset = function (it, BYTES) {
	  var offset = toPositiveInteger(it);
	  if (offset % BYTES) throw RangeError('Wrong offset');
	  return offset;
	};

	var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;
	var typedArrayFrom = function from(source /* , mapfn, thisArg */) {
	  var O = toObject(source);
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var i, length, result, step, iterator, next;
	  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    O = [];
	    while (!(step = next.call(iterator)).done) {
	      O.push(step.value);
	    }
	  }
	  if (mapping && argumentsLength > 2) {
	    mapfn = functionBindContext(mapfn, arguments[2], 2);
	  }
	  length = toLength(O.length);
	  result = new (aTypedArrayConstructor$1(this))(length);
	  for (i = 0; length > i; i++) {
	    result[i] = mapping ? mapfn(O[i], i) : O[i];
	  }
	  return result;
	};

	var typedArrayConstructor = createCommonjsModule(function (module) {



















	var getOwnPropertyNames = objectGetOwnPropertyNames.f;

	var forEach = arrayIteration.forEach;





	var getInternalState = internalState.get;
	var setInternalState = internalState.set;
	var nativeDefineProperty = objectDefineProperty.f;
	var nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	var round = Math.round;
	var RangeError = global_1.RangeError;
	var ArrayBuffer = arrayBuffer.ArrayBuffer;
	var DataView = arrayBuffer.DataView;
	var NATIVE_ARRAY_BUFFER_VIEWS = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
	var TYPED_ARRAY_TAG = arrayBufferViewCore.TYPED_ARRAY_TAG;
	var TypedArray = arrayBufferViewCore.TypedArray;
	var TypedArrayPrototype = arrayBufferViewCore.TypedArrayPrototype;
	var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;
	var isTypedArray = arrayBufferViewCore.isTypedArray;
	var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
	var WRONG_LENGTH = 'Wrong length';
	var fromList = function fromList(C, list) {
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor(C))(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	};
	var addGetter = function addGetter(it, key) {
	  nativeDefineProperty(it, key, {
	    get: function get() {
	      return getInternalState(this)[key];
	    }
	  });
	};
	var isArrayBuffer = function isArrayBuffer(it) {
	  var klass;
	  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
	};
	var isTypedArrayIndex = function isTypedArrayIndex(target, key) {
	  return isTypedArray(target) && typeof key != 'symbol' && key in target && String(+key) == String(key);
	};
	var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
	  return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
	};
	var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
	  if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject(descriptor) && has(descriptor, 'value') && !has(descriptor, 'get') && !has(descriptor, 'set')
	  // TODO: add validation descriptor w/o calling accessors
	  && !descriptor.configurable && (!has(descriptor, 'writable') || descriptor.writable) && (!has(descriptor, 'enumerable') || descriptor.enumerable)) {
	    target[key] = descriptor.value;
	    return target;
	  }
	  return nativeDefineProperty(target, key, descriptor);
	};
	if (descriptors) {
	  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	    objectGetOwnPropertyDescriptor.f = wrappedGetOwnPropertyDescriptor;
	    objectDefineProperty.f = wrappedDefineProperty;
	    addGetter(TypedArrayPrototype, 'buffer');
	    addGetter(TypedArrayPrototype, 'byteOffset');
	    addGetter(TypedArrayPrototype, 'byteLength');
	    addGetter(TypedArrayPrototype, 'length');
	  }
	  _export({
	    target: 'Object',
	    stat: true,
	    forced: !NATIVE_ARRAY_BUFFER_VIEWS
	  }, {
	    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
	    defineProperty: wrappedDefineProperty
	  });
	  module.exports = function (TYPE, wrapper, CLAMPED) {
	    var BYTES = TYPE.match(/\d+$/)[0] / 8;
	    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
	    var GETTER = 'get' + TYPE;
	    var SETTER = 'set' + TYPE;
	    var NativeTypedArrayConstructor = global_1[CONSTRUCTOR_NAME];
	    var TypedArrayConstructor = NativeTypedArrayConstructor;
	    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
	    var exported = {};
	    var getter = function getter(that, index) {
	      var data = getInternalState(that);
	      return data.view[GETTER](index * BYTES + data.byteOffset, true);
	    };
	    var setter = function setter(that, index, value) {
	      var data = getInternalState(that);
	      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
	      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
	    };
	    var addElement = function addElement(that, index) {
	      nativeDefineProperty(that, index, {
	        get: function get() {
	          return getter(this, index);
	        },
	        set: function set(value) {
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
	      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
	        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
	        var index = 0;
	        var byteOffset = 0;
	        var buffer, byteLength, length;
	        if (!isObject(data)) {
	          length = toIndex(data);
	          byteLength = length * BYTES;
	          buffer = new ArrayBuffer(byteLength);
	        } else if (isArrayBuffer(data)) {
	          buffer = data;
	          byteOffset = toOffset(offset, BYTES);
	          var $len = data.byteLength;
	          if ($length === undefined) {
	            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
	            byteLength = $len - byteOffset;
	            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if (isTypedArray(data)) {
	          return fromList(TypedArrayConstructor, data);
	        } else {
	          return typedArrayFrom.call(TypedArrayConstructor, data);
	        }
	        setInternalState(that, {
	          buffer: buffer,
	          byteOffset: byteOffset,
	          byteLength: byteLength,
	          length: length,
	          view: new DataView(buffer)
	        });
	        while (index < length) addElement(that, index++);
	      });
	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = objectCreate(TypedArrayPrototype);
	    } else if (typedArrayConstructorsRequireWrappers) {
	      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
	        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
	        return inheritIfRequired(function () {
	          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
	          if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
	          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
	          return typedArrayFrom.call(TypedArrayConstructor, data);
	        }(), dummy, TypedArrayConstructor);
	      });
	      if (objectSetPrototypeOf) objectSetPrototypeOf(TypedArrayConstructor, TypedArray);
	      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
	        if (!(key in TypedArrayConstructor)) {
	          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
	        }
	      });
	      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
	    }
	    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
	    }
	    if (TYPED_ARRAY_TAG) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
	    }
	    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
	    _export({
	      global: true,
	      forced: TypedArrayConstructor != NativeTypedArrayConstructor,
	      sham: !NATIVE_ARRAY_BUFFER_VIEWS
	    }, exported);
	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
	      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
	    }
	    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
	      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
	    }
	    setSpecies(CONSTRUCTOR_NAME);
	  };
	} else module.exports = function () {/* empty */};
	});

	// `Float32Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Float32', function (init) {
	  return function Float32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Float64Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Float64', function (init) {
	  return function Float64Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int8Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int8', function (init) {
	  return function Int8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int16Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int16', function (init) {
	  return function Int16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Int32Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Int32', function (init) {
	  return function Int32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint8ClampedArray` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint8', function (init) {
	  return function Uint8ClampedArray(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	}, true);

	// `Uint16Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint16', function (init) {
	  return function Uint16Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	// `Uint32Array` constructor
	// https://tc39.github.io/ecma262/#sec-typedarray-objects
	typedArrayConstructor('Uint32', function (init) {
	  return function Uint32Array(data, byteOffset, length) {
	    return init(this, data, byteOffset, length);
	  };
	});

	var aTypedArray$1 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$1 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.copyWithin` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
	exportTypedArrayMethod$1('copyWithin', function copyWithin(target, start /* , end */) {
	  return arrayCopyWithin.call(aTypedArray$1(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	});

	var $every$1 = arrayIteration.every;
	var aTypedArray$2 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$2 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.every` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
	exportTypedArrayMethod$2('every', function every(callbackfn /* , thisArg */) {
	  return $every$1(aTypedArray$2(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$3 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$3 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.fill` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
	// eslint-disable-next-line no-unused-vars
	exportTypedArrayMethod$3('fill', function fill(value /* , start, end */) {
	  return arrayFill.apply(aTypedArray$3(this), arguments);
	});

	var $filter$1 = arrayIteration.filter;

	var aTypedArray$4 = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$2 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$4 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.filter` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
	exportTypedArrayMethod$4('filter', function filter(callbackfn /* , thisArg */) {
	  var list = $filter$1(aTypedArray$4(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  var C = speciesConstructor(this, this.constructor);
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor$2(C))(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	});

	var $find$1 = arrayIteration.find;
	var aTypedArray$5 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$5 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.find` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
	exportTypedArrayMethod$5('find', function find(predicate /* , thisArg */) {
	  return $find$1(aTypedArray$5(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $findIndex$1 = arrayIteration.findIndex;
	var aTypedArray$6 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$6 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.findIndex` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
	exportTypedArrayMethod$6('findIndex', function findIndex(predicate /* , thisArg */) {
	  return $findIndex$1(aTypedArray$6(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $forEach$2 = arrayIteration.forEach;
	var aTypedArray$7 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$7 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.forEach` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
	exportTypedArrayMethod$7('forEach', function forEach(callbackfn /* , thisArg */) {
	  $forEach$2(aTypedArray$7(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var exportTypedArrayStaticMethod$1 = arrayBufferViewCore.exportTypedArrayStaticMethod;


	// `%TypedArray%.from` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.from
	exportTypedArrayStaticMethod$1('from', typedArrayFrom, typedArrayConstructorsRequireWrappers);

	var $includes$1 = arrayIncludes.includes;
	var aTypedArray$8 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$8 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.includes` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
	exportTypedArrayMethod$8('includes', function includes(searchElement /* , fromIndex */) {
	  return $includes$1(aTypedArray$8(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $indexOf$1 = arrayIncludes.indexOf;
	var aTypedArray$9 = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$9 = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.indexOf` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
	exportTypedArrayMethod$9('indexOf', function indexOf(searchElement /* , fromIndex */) {
	  return $indexOf$1(aTypedArray$9(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	});

	var ITERATOR$5 = wellKnownSymbol('iterator');
	var Uint8Array = global_1.Uint8Array;
	var arrayValues = es_array_iterator.values;
	var arrayKeys = es_array_iterator.keys;
	var arrayEntries = es_array_iterator.entries;
	var aTypedArray$a = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$a = arrayBufferViewCore.exportTypedArrayMethod;
	var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR$5];
	var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);
	var typedArrayValues = function values() {
	  return arrayValues.call(aTypedArray$a(this));
	};

	// `%TypedArray%.prototype.entries` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
	exportTypedArrayMethod$a('entries', function entries() {
	  return arrayEntries.call(aTypedArray$a(this));
	});
	// `%TypedArray%.prototype.keys` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
	exportTypedArrayMethod$a('keys', function keys() {
	  return arrayKeys.call(aTypedArray$a(this));
	});
	// `%TypedArray%.prototype.values` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
	exportTypedArrayMethod$a('values', typedArrayValues, !CORRECT_ITER_NAME);
	// `%TypedArray%.prototype[@@iterator]` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
	exportTypedArrayMethod$a(ITERATOR$5, typedArrayValues, !CORRECT_ITER_NAME);

	var aTypedArray$b = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$b = arrayBufferViewCore.exportTypedArrayMethod;
	var $join = [].join;

	// `%TypedArray%.prototype.join` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
	// eslint-disable-next-line no-unused-vars
	exportTypedArrayMethod$b('join', function join(separator) {
	  return $join.apply(aTypedArray$b(this), arguments);
	});

	var aTypedArray$c = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$c = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.lastIndexOf` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
	// eslint-disable-next-line no-unused-vars
	exportTypedArrayMethod$c('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
	  return arrayLastIndexOf.apply(aTypedArray$c(this), arguments);
	});

	var $map$1 = arrayIteration.map;

	var aTypedArray$d = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$3 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$d = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.map` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
	exportTypedArrayMethod$d('map', function map(mapfn /* , thisArg */) {
	  return $map$1(aTypedArray$d(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
	    return new (aTypedArrayConstructor$3(speciesConstructor(O, O.constructor)))(length);
	  });
	});

	var aTypedArrayConstructor$4 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayStaticMethod$2 = arrayBufferViewCore.exportTypedArrayStaticMethod;

	// `%TypedArray%.of` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.of
	exportTypedArrayStaticMethod$2('of', function of( /* ...items */
	) {
	  var index = 0;
	  var length = arguments.length;
	  var result = new (aTypedArrayConstructor$4(this))(length);
	  while (length > index) result[index] = arguments[index++];
	  return result;
	}, typedArrayConstructorsRequireWrappers);

	var $reduce$1 = arrayReduce.left;
	var aTypedArray$e = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$e = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.reduce` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
	exportTypedArrayMethod$e('reduce', function reduce(callbackfn /* , initialValue */) {
	  return $reduce$1(aTypedArray$e(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	});

	var $reduceRight$1 = arrayReduce.right;
	var aTypedArray$f = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$f = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.reduceRicht` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
	exportTypedArrayMethod$f('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
	  return $reduceRight$1(aTypedArray$f(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$g = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$g = arrayBufferViewCore.exportTypedArrayMethod;
	var floor$7 = Math.floor;

	// `%TypedArray%.prototype.reverse` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
	exportTypedArrayMethod$g('reverse', function reverse() {
	  var that = this;
	  var length = aTypedArray$g(that).length;
	  var middle = floor$7(length / 2);
	  var index = 0;
	  var value;
	  while (index < middle) {
	    value = that[index];
	    that[index++] = that[--length];
	    that[length] = value;
	  }
	  return that;
	});

	var aTypedArray$h = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$h = arrayBufferViewCore.exportTypedArrayMethod;
	var FORCED$h = fails(function () {
	  // eslint-disable-next-line no-undef
	  new Int8Array(1).set({});
	});

	// `%TypedArray%.prototype.set` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
	exportTypedArrayMethod$h('set', function set(arrayLike /* , offset */) {
	  aTypedArray$h(this);
	  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
	  var length = this.length;
	  var src = toObject(arrayLike);
	  var len = toLength(src.length);
	  var index = 0;
	  if (len + offset > length) throw RangeError('Wrong length');
	  while (index < len) this[offset + index] = src[index++];
	}, FORCED$h);

	var aTypedArray$i = arrayBufferViewCore.aTypedArray;
	var aTypedArrayConstructor$5 = arrayBufferViewCore.aTypedArrayConstructor;
	var exportTypedArrayMethod$i = arrayBufferViewCore.exportTypedArrayMethod;
	var $slice = [].slice;
	var FORCED$i = fails(function () {
	  // eslint-disable-next-line no-undef
	  new Int8Array(1).slice();
	});

	// `%TypedArray%.prototype.slice` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
	exportTypedArrayMethod$i('slice', function slice(start, end) {
	  var list = $slice.call(aTypedArray$i(this), start, end);
	  var C = speciesConstructor(this, this.constructor);
	  var index = 0;
	  var length = list.length;
	  var result = new (aTypedArrayConstructor$5(C))(length);
	  while (length > index) result[index] = list[index++];
	  return result;
	}, FORCED$i);

	var $some$1 = arrayIteration.some;
	var aTypedArray$j = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$j = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.some` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
	exportTypedArrayMethod$j('some', function some(callbackfn /* , thisArg */) {
	  return $some$1(aTypedArray$j(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	});

	var aTypedArray$k = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$k = arrayBufferViewCore.exportTypedArrayMethod;
	var $sort = [].sort;

	// `%TypedArray%.prototype.sort` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
	exportTypedArrayMethod$k('sort', function sort(comparefn) {
	  return $sort.call(aTypedArray$k(this), comparefn);
	});

	var aTypedArray$l = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$l = arrayBufferViewCore.exportTypedArrayMethod;

	// `%TypedArray%.prototype.subarray` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
	exportTypedArrayMethod$l('subarray', function subarray(begin, end) {
	  var O = aTypedArray$l(this);
	  var length = O.length;
	  var beginIndex = toAbsoluteIndex(begin, length);
	  return new (speciesConstructor(O, O.constructor))(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
	});

	var Int8Array$3 = global_1.Int8Array;
	var aTypedArray$m = arrayBufferViewCore.aTypedArray;
	var exportTypedArrayMethod$m = arrayBufferViewCore.exportTypedArrayMethod;
	var $toLocaleString = [].toLocaleString;
	var $slice$1 = [].slice;

	// iOS Safari 6.x fails here
	var TO_LOCALE_STRING_BUG = !!Int8Array$3 && fails(function () {
	  $toLocaleString.call(new Int8Array$3(1));
	});
	var FORCED$j = fails(function () {
	  return [1, 2].toLocaleString() != new Int8Array$3([1, 2]).toLocaleString();
	}) || !fails(function () {
	  Int8Array$3.prototype.toLocaleString.call([1, 2]);
	});

	// `%TypedArray%.prototype.toLocaleString` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
	exportTypedArrayMethod$m('toLocaleString', function toLocaleString() {
	  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice$1.call(aTypedArray$m(this)) : aTypedArray$m(this), arguments);
	}, FORCED$j);

	var exportTypedArrayMethod$n = arrayBufferViewCore.exportTypedArrayMethod;


	var Uint8Array$1 = global_1.Uint8Array;
	var Uint8ArrayPrototype = Uint8Array$1 && Uint8Array$1.prototype || {};
	var arrayToString = [].toString;
	var arrayJoin = [].join;
	if (fails(function () {
	  arrayToString.call({});
	})) {
	  arrayToString = function toString() {
	    return arrayJoin.call(this);
	  };
	}
	var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

	// `%TypedArray%.prototype.toString` method
	// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
	exportTypedArrayMethod$n('toString', arrayToString, IS_NOT_ARRAY_METHOD);

	var getWeakData = internalMetadata.getWeakData;







	var setInternalState$7 = internalState.set;
	var internalStateGetterFor$1 = internalState.getterFor;
	var find = arrayIteration.find;
	var findIndex = arrayIteration.findIndex;
	var id$1 = 0;

	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function uncaughtFrozenStore(store) {
	  return store.frozen || (store.frozen = new UncaughtFrozenStore());
	};
	var UncaughtFrozenStore = function UncaughtFrozenStore() {
	  this.entries = [];
	};
	var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
	  return find(store.entries, function (it) {
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function get(key) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) return entry[1];
	  },
	  has: function has(key) {
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function set(key, value) {
	    var entry = findUncaughtFrozen(this, key);
	    if (entry) entry[1] = value;else this.entries.push([key, value]);
	  },
	  'delete': function _delete(key) {
	    var index = findIndex(this.entries, function (it) {
	      return it[0] === key;
	    });
	    if (~index) this.entries.splice(index, 1);
	    return !!~index;
	  }
	};
	var collectionWeak = {
	  getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, CONSTRUCTOR_NAME);
	      setInternalState$7(that, {
	        type: CONSTRUCTOR_NAME,
	        id: id$1++,
	        frozen: undefined
	      });
	      if (iterable != undefined) iterate_1(iterable, that[ADDER], that, IS_MAP);
	    });
	    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
	    var define = function define(that, key, value) {
	      var state = getInternalState(that);
	      var data = getWeakData(anObject(key), true);
	      if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;
	      return that;
	    };
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function _delete(key) {
	        var state = getInternalState(this);
	        if (!isObject(key)) return false;
	        var data = getWeakData(key);
	        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
	        return data && has(data, state.id) && delete data[state.id];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has$1(key) {
	        var state = getInternalState(this);
	        if (!isObject(key)) return false;
	        var data = getWeakData(key);
	        if (data === true) return uncaughtFrozenStore(state).has(key);
	        return data && has(data, state.id);
	      }
	    });
	    redefineAll(C.prototype, IS_MAP ? {
	      // 23.3.3.3 WeakMap.prototype.get(key)
	      get: function get(key) {
	        var state = getInternalState(this);
	        if (isObject(key)) {
	          var data = getWeakData(key);
	          if (data === true) return uncaughtFrozenStore(state).get(key);
	          return data ? data[state.id] : undefined;
	        }
	      },
	      // 23.3.3.5 WeakMap.prototype.set(key, value)
	      set: function set(key, value) {
	        return define(this, key, value);
	      }
	    } : {
	      // 23.4.3.1 WeakSet.prototype.add(value)
	      add: function add(value) {
	        return define(this, value, true);
	      }
	    });
	    return C;
	  }
	};

	var es_weakMap = createCommonjsModule(function (module) {







	var enforceIternalState = internalState.enforce;

	var IS_IE11 = !global_1.ActiveXObject && 'ActiveXObject' in global_1;
	var isExtensible = Object.isExtensible;
	var InternalWeakMap;
	var wrapper = function wrapper(init) {
	  return function WeakMap() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	};

	// `WeakMap` constructor
	// https://tc39.github.io/ecma262/#sec-weakmap-constructor
	var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak);

	// IE11 WeakMap frozen keys fix
	// We can't use feature detection because it crash some old IE builds
	// https://github.com/zloirock/core-js/issues/485
	if (nativeWeakMap && IS_IE11) {
	  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
	  internalMetadata.REQUIRED = true;
	  var WeakMapPrototype = $WeakMap.prototype;
	  var nativeDelete = WeakMapPrototype['delete'];
	  var nativeHas = WeakMapPrototype.has;
	  var nativeGet = WeakMapPrototype.get;
	  var nativeSet = WeakMapPrototype.set;
	  redefineAll(WeakMapPrototype, {
	    'delete': function _delete(key) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeDelete.call(this, key) || state.frozen['delete'](key);
	      }
	      return nativeDelete.call(this, key);
	    },
	    has: function has(key) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeHas.call(this, key) || state.frozen.has(key);
	      }
	      return nativeHas.call(this, key);
	    },
	    get: function get(key) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
	      }
	      return nativeGet.call(this, key);
	    },
	    set: function set(key, value) {
	      if (isObject(key) && !isExtensible(key)) {
	        var state = enforceIternalState(this);
	        if (!state.frozen) state.frozen = new InternalWeakMap();
	        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
	      } else nativeSet.call(this, key, value);
	      return this;
	    }
	  });
	}
	});

	// `WeakSet` constructor
	// https://tc39.github.io/ecma262/#sec-weakset-constructor
	collection('WeakSet', function (init) {
	  return function WeakSet() {
	    return init(this, arguments.length ? arguments[0] : undefined);
	  };
	}, collectionWeak);

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	for (var COLLECTION_NAME in domIterables) {
	  var Collection = global_1[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype;
	  // some Chrome versions have non-configurable methods on DOMTokenList
	  if (CollectionPrototype && CollectionPrototype.forEach !== arrayForEach) try {
	    createNonEnumerableProperty(CollectionPrototype, 'forEach', arrayForEach);
	  } catch (error) {
	    CollectionPrototype.forEach = arrayForEach;
	  }
	}

	var ITERATOR$6 = wellKnownSymbol('iterator');
	var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');
	var ArrayValues = es_array_iterator.values;
	for (var COLLECTION_NAME$1 in domIterables) {
	  var Collection$1 = global_1[COLLECTION_NAME$1];
	  var CollectionPrototype$1 = Collection$1 && Collection$1.prototype;
	  if (CollectionPrototype$1) {
	    // some Chrome versions have non-configurable methods on DOMTokenList
	    if (CollectionPrototype$1[ITERATOR$6] !== ArrayValues) try {
	      createNonEnumerableProperty(CollectionPrototype$1, ITERATOR$6, ArrayValues);
	    } catch (error) {
	      CollectionPrototype$1[ITERATOR$6] = ArrayValues;
	    }
	    if (!CollectionPrototype$1[TO_STRING_TAG$4]) {
	      createNonEnumerableProperty(CollectionPrototype$1, TO_STRING_TAG$4, COLLECTION_NAME$1);
	    }
	    if (domIterables[COLLECTION_NAME$1]) for (var METHOD_NAME in es_array_iterator) {
	      // some Chrome versions have non-configurable methods on DOMTokenList
	      if (CollectionPrototype$1[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
	        createNonEnumerableProperty(CollectionPrototype$1, METHOD_NAME, es_array_iterator[METHOD_NAME]);
	      } catch (error) {
	        CollectionPrototype$1[METHOD_NAME] = es_array_iterator[METHOD_NAME];
	      }
	    }
	  }
	}

	var FORCED$k = !global_1.setImmediate || !global_1.clearImmediate;

	// http://w3c.github.io/setImmediate/
	_export({
	  global: true,
	  bind: true,
	  enumerable: true,
	  forced: FORCED$k
	}, {
	  // `setImmediate` method
	  // http://w3c.github.io/setImmediate/#si-setImmediate
	  setImmediate: task.set,
	  // `clearImmediate` method
	  // http://w3c.github.io/setImmediate/#si-clearImmediate
	  clearImmediate: task.clear
	});

	var process$5 = global_1.process;
	var isNode = classofRaw(process$5) == 'process';

	// `queueMicrotask` method
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask
	_export({
	  global: true,
	  enumerable: true,
	  noTargetGet: true
	}, {
	  queueMicrotask: function queueMicrotask(fn) {
	    var domain = isNode && process$5.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

	var slice$1 = [].slice;
	var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check

	var wrap$1 = function wrap(scheduler) {
	  return function (handler, timeout /* , ...arguments */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice$1.call(arguments, 2) : undefined;
	    return scheduler(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func
	      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
	    } : handler, timeout);
	  };
	};

	// ie9- setTimeout & setInterval additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
	_export({
	  global: true,
	  bind: true,
	  forced: MSIE
	}, {
	  // `setTimeout` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
	  setTimeout: wrap$1(global_1.setTimeout),
	  // `setInterval` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
	  setInterval: wrap$1(global_1.setInterval)
	});

	var ITERATOR$7 = wellKnownSymbol('iterator');
	var nativeUrl = !fails(function () {
	  var url = new URL('b?a=1&b=2&c=3', 'http://a');
	  var searchParams = url.searchParams;
	  var result = '';
	  url.pathname = 'c%20d';
	  searchParams.forEach(function (value, key) {
	    searchParams['delete']('b');
	    result += key + value;
	  });
	  return isPure && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR$7]
	  // throws in Edge
	  || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
	  // not punycoded in Edge
	  || new URL('http://ÑÐµÑÑ').host !== 'xn--e1aybc'
	  // not escaped in Chrome 62-
	  || new URL('http://a#Ð±').hash !== '#%D0%B1'
	  // fails in Chrome 66-
	  || result !== 'a1c3'
	  // throws in Safari
	  || new URL('http://x', undefined).host !== 'x';
	});

	// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
	var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
	var base = 36;
	var tMin = 1;
	var tMax = 26;
	var skew = 38;
	var damp = 700;
	var initialBias = 72;
	var initialN = 128; // 0x80
	var delimiter = '-'; // '\x2D'
	var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
	var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
	var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
	var baseMinusTMin = base - tMin;
	var floor$8 = Math.floor;
	var stringFromCharCode = String.fromCharCode;

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 */
	var ucs2decode = function ucs2decode(string) {
	  var output = [];
	  var counter = 0;
	  var length = string.length;
	  while (counter < length) {
	    var value = string.charCodeAt(counter++);
	    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
	      // It's a high surrogate, and there is a next character.
	      var extra = string.charCodeAt(counter++);
	      if ((extra & 0xFC00) == 0xDC00) {
	        // Low surrogate.
	        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	      } else {
	        // It's an unmatched surrogate; only append this code unit, in case the
	        // next code unit is the high surrogate of a surrogate pair.
	        output.push(value);
	        counter--;
	      }
	    } else {
	      output.push(value);
	    }
	  }
	  return output;
	};

	/**
	 * Converts a digit/integer into a basic code point.
	 */
	var digitToBasic = function digitToBasic(digit) {
	  //  0..25 map to ASCII a..z or A..Z
	  // 26..35 map to ASCII 0..9
	  return digit + 22 + 75 * (digit < 26);
	};

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 */
	var adapt = function adapt(delta, numPoints, firstTime) {
	  var k = 0;
	  delta = firstTime ? floor$8(delta / damp) : delta >> 1;
	  delta += floor$8(delta / numPoints);
	  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
	    delta = floor$8(delta / baseMinusTMin);
	  }
	  return floor$8(k + (baseMinusTMin + 1) * delta / (delta + skew));
	};

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 */
	// eslint-disable-next-line  max-statements
	var encode = function encode(input) {
	  var output = [];

	  // Convert the input in UCS-2 to an array of Unicode code points.
	  input = ucs2decode(input);

	  // Cache the length.
	  var inputLength = input.length;

	  // Initialize the state.
	  var n = initialN;
	  var delta = 0;
	  var bias = initialBias;
	  var i, currentValue;

	  // Handle the basic code points.
	  for (i = 0; i < input.length; i++) {
	    currentValue = input[i];
	    if (currentValue < 0x80) {
	      output.push(stringFromCharCode(currentValue));
	    }
	  }
	  var basicLength = output.length; // number of basic code points.
	  var handledCPCount = basicLength; // number of code points that have been handled;

	  // Finish the basic string with a delimiter unless it's empty.
	  if (basicLength) {
	    output.push(delimiter);
	  }

	  // Main encoding loop:
	  while (handledCPCount < inputLength) {
	    // All non-basic code points < n have been handled already. Find the next larger one:
	    var m = maxInt;
	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue >= n && currentValue < m) {
	        m = currentValue;
	      }
	    }

	    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
	    var handledCPCountPlusOne = handledCPCount + 1;
	    if (m - n > floor$8((maxInt - delta) / handledCPCountPlusOne)) {
	      throw RangeError(OVERFLOW_ERROR);
	    }
	    delta += (m - n) * handledCPCountPlusOne;
	    n = m;
	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue < n && ++delta > maxInt) {
	        throw RangeError(OVERFLOW_ERROR);
	      }
	      if (currentValue == n) {
	        // Represent delta as a generalized variable-length integer.
	        var q = delta;
	        for /* no condition */
	        (var k = base;; k += base) {
	          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
	          if (q < t) break;
	          var qMinusT = q - t;
	          var baseMinusT = base - t;
	          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
	          q = floor$8(qMinusT / baseMinusT);
	        }
	        output.push(stringFromCharCode(digitToBasic(q)));
	        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
	        delta = 0;
	        ++handledCPCount;
	      }
	    }
	    ++delta;
	    ++n;
	  }
	  return output.join('');
	};
	var stringPunycodeToAscii = function (input) {
	  var encoded = [];
	  var labels = input.toLowerCase().replace(regexSeparators, ".").split('.');
	  var i, label;
	  for (i = 0; i < labels.length; i++) {
	    label = labels[i];
	    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
	  }
	  return encoded.join('.');
	};

	var getIterator = function (it) {
	  var iteratorMethod = getIteratorMethod(it);
	  if (typeof iteratorMethod != 'function') {
	    throw TypeError(String(it) + ' is not iterable');
	  }
	  return anObject(iteratorMethod.call(it));
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`




















	var $fetch$1 = getBuiltIn('fetch');
	var Headers = getBuiltIn('Headers');
	var ITERATOR$8 = wellKnownSymbol('iterator');
	var URL_SEARCH_PARAMS = 'URLSearchParams';
	var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
	var setInternalState$8 = internalState.set;
	var getInternalParamsState = internalState.getterFor(URL_SEARCH_PARAMS);
	var getInternalIteratorState = internalState.getterFor(URL_SEARCH_PARAMS_ITERATOR);
	var plus = /\+/g;
	var sequences = Array(4);
	var percentSequence = function percentSequence(bytes) {
	  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
	};
	var percentDecode = function percentDecode(sequence) {
	  try {
	    return decodeURIComponent(sequence);
	  } catch (error) {
	    return sequence;
	  }
	};
	var deserialize = function deserialize(it) {
	  var result = it.replace(plus, ' ');
	  var bytes = 4;
	  try {
	    return decodeURIComponent(result);
	  } catch (error) {
	    while (bytes) {
	      result = result.replace(percentSequence(bytes--), percentDecode);
	    }
	    return result;
	  }
	};
	var find$1 = /[!'()~]|%20/g;
	var replace = {
	  '!': '%21',
	  "'": '%27',
	  '(': '%28',
	  ')': '%29',
	  '~': '%7E',
	  '%20': '+'
	};
	var replacer = function replacer(match) {
	  return replace[match];
	};
	var serialize = function serialize(it) {
	  return encodeURIComponent(it).replace(find$1, replacer);
	};
	var parseSearchParams = function parseSearchParams(result, query) {
	  if (query) {
	    var attributes = query.split('&');
	    var index = 0;
	    var attribute, entry;
	    while (index < attributes.length) {
	      attribute = attributes[index++];
	      if (attribute.length) {
	        entry = attribute.split('=');
	        result.push({
	          key: deserialize(entry.shift()),
	          value: deserialize(entry.join('='))
	        });
	      }
	    }
	  }
	};
	var updateSearchParams = function updateSearchParams(query) {
	  this.entries.length = 0;
	  parseSearchParams(this.entries, query);
	};
	var validateArgumentsLength = function validateArgumentsLength(passed, required) {
	  if (passed < required) throw TypeError('Not enough arguments');
	};
	var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
	  setInternalState$8(this, {
	    type: URL_SEARCH_PARAMS_ITERATOR,
	    iterator: getIterator(getInternalParamsState(params).entries),
	    kind: kind
	  });
	}, 'Iterator', function next() {
	  var state = getInternalIteratorState(this);
	  var kind = state.kind;
	  var step = state.iterator.next();
	  var entry = step.value;
	  if (!step.done) {
	    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
	  }
	  return step;
	});

	// `URLSearchParams` constructor
	// https://url.spec.whatwg.org/#interface-urlsearchparams
	var URLSearchParamsConstructor = function URLSearchParams( /* init */
	) {
	  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
	  var init = arguments.length > 0 ? arguments[0] : undefined;
	  var that = this;
	  var entries = [];
	  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
	  setInternalState$8(that, {
	    type: URL_SEARCH_PARAMS,
	    entries: entries,
	    updateURL: function updateURL() {/* empty */},
	    updateSearchParams: updateSearchParams
	  });
	  if (init !== undefined) {
	    if (isObject(init)) {
	      iteratorMethod = getIteratorMethod(init);
	      if (typeof iteratorMethod === 'function') {
	        iterator = iteratorMethod.call(init);
	        next = iterator.next;
	        while (!(step = next.call(iterator)).done) {
	          entryIterator = getIterator(anObject(step.value));
	          entryNext = entryIterator.next;
	          if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done) throw TypeError('Expected sequence with length 2');
	          entries.push({
	            key: first.value + '',
	            value: second.value + ''
	          });
	        }
	      } else for (key in init) if (has(init, key)) entries.push({
	        key: key,
	        value: init[key] + ''
	      });
	    } else {
	      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
	    }
	  }
	};
	var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
	redefineAll(URLSearchParamsPrototype, {
	  // `URLSearchParams.prototype.appent` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
	  append: function append(name, value) {
	    validateArgumentsLength(arguments.length, 2);
	    var state = getInternalParamsState(this);
	    state.entries.push({
	      key: name + '',
	      value: value + ''
	    });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.delete` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
	  'delete': function _delete(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var key = name + '';
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index].key === key) entries.splice(index, 1);else index++;
	    }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.get` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
	  get: function get(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) return entries[index].value;
	    }
	    return null;
	  },
	  // `URLSearchParams.prototype.getAll` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
	  getAll: function getAll(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var result = [];
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) result.push(entries[index].value);
	    }
	    return result;
	  },
	  // `URLSearchParams.prototype.has` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
	  has: function has(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index++].key === key) return true;
	    }
	    return false;
	  },
	  // `URLSearchParams.prototype.set` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
	  set: function set(name, value) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var found = false;
	    var key = name + '';
	    var val = value + '';
	    var index = 0;
	    var entry;
	    for (; index < entries.length; index++) {
	      entry = entries[index];
	      if (entry.key === key) {
	        if (found) entries.splice(index--, 1);else {
	          found = true;
	          entry.value = val;
	        }
	      }
	    }
	    if (!found) entries.push({
	      key: key,
	      value: val
	    });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.sort` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
	  sort: function sort() {
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    // Array#sort is not stable in some engines
	    var slice = entries.slice();
	    var entry, entriesIndex, sliceIndex;
	    entries.length = 0;
	    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
	      entry = slice[sliceIndex];
	      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
	        if (entries[entriesIndex].key > entry.key) {
	          entries.splice(entriesIndex, 0, entry);
	          break;
	        }
	      }
	      if (entriesIndex === sliceIndex) entries.push(entry);
	    }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.forEach` method
	  forEach: function forEach(callback /* , thisArg */) {
	    var entries = getInternalParamsState(this).entries;
	    var boundFunction = functionBindContext(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var index = 0;
	    var entry;
	    while (index < entries.length) {
	      entry = entries[index++];
	      boundFunction(entry.value, entry.key, this);
	    }
	  },
	  // `URLSearchParams.prototype.keys` method
	  keys: function keys() {
	    return new URLSearchParamsIterator(this, 'keys');
	  },
	  // `URLSearchParams.prototype.values` method
	  values: function values() {
	    return new URLSearchParamsIterator(this, 'values');
	  },
	  // `URLSearchParams.prototype.entries` method
	  entries: function entries() {
	    return new URLSearchParamsIterator(this, 'entries');
	  }
	}, {
	  enumerable: true
	});

	// `URLSearchParams.prototype[@@iterator]` method
	redefine(URLSearchParamsPrototype, ITERATOR$8, URLSearchParamsPrototype.entries);

	// `URLSearchParams.prototype.toString` method
	// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
	redefine(URLSearchParamsPrototype, 'toString', function toString() {
	  var entries = getInternalParamsState(this).entries;
	  var result = [];
	  var index = 0;
	  var entry;
	  while (index < entries.length) {
	    entry = entries[index++];
	    result.push(serialize(entry.key) + '=' + serialize(entry.value));
	  }
	  return result.join('&');
	}, {
	  enumerable: true
	});
	setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
	_export({
	  global: true,
	  forced: !nativeUrl
	}, {
	  URLSearchParams: URLSearchParamsConstructor
	});

	// Wrap `fetch` for correct work with polyfilled `URLSearchParams`
	// https://github.com/zloirock/core-js/issues/674
	if (!nativeUrl && typeof $fetch$1 == 'function' && typeof Headers == 'function') {
	  _export({
	    global: true,
	    enumerable: true,
	    forced: true
	  }, {
	    fetch: function fetch(input /* , init */) {
	      var args = [input];
	      var init, body, headers;
	      if (arguments.length > 1) {
	        init = arguments[1];
	        if (isObject(init)) {
	          body = init.body;
	          if (classof(body) === URL_SEARCH_PARAMS) {
	            headers = init.headers ? new Headers(init.headers) : new Headers();
	            if (!headers.has('content-type')) {
	              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	            }
	            init = objectCreate(init, {
	              body: createPropertyDescriptor(0, String(body)),
	              headers: createPropertyDescriptor(0, headers)
	            });
	          }
	        }
	        args.push(init);
	      }
	      return $fetch$1.apply(this, args);
	    }
	  });
	}
	var web_urlSearchParams = {
	  URLSearchParams: URLSearchParamsConstructor,
	  getState: getInternalParamsState
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`











	var codeAt$1 = stringMultibyte.codeAt;




	var NativeURL = global_1.URL;
	var URLSearchParams$1 = web_urlSearchParams.URLSearchParams;
	var getInternalSearchParamsState = web_urlSearchParams.getState;
	var setInternalState$9 = internalState.set;
	var getInternalURLState = internalState.getterFor('URL');
	var floor$9 = Math.floor;
	var pow$4 = Math.pow;
	var INVALID_AUTHORITY = 'Invalid authority';
	var INVALID_SCHEME = 'Invalid scheme';
	var INVALID_HOST = 'Invalid host';
	var INVALID_PORT = 'Invalid port';
	var ALPHA = /[A-Za-z]/;
	var ALPHANUMERIC = /[\d+-.A-Za-z]/;
	var DIGIT = /\d/;
	var HEX_START = /^(0x|0X)/;
	var OCT = /^[0-7]+$/;
	var DEC = /^\d+$/;
	var HEX = /^[\dA-Fa-f]+$/;
	// eslint-disable-next-line no-control-regex
	var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
	// eslint-disable-next-line no-control-regex
	var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
	// eslint-disable-next-line no-control-regex
	var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
	// eslint-disable-next-line no-control-regex
	var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
	var EOF;
	var parseHost = function parseHost(url, input) {
	  var result, codePoints, index;
	  if (input.charAt(0) == '[') {
	    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
	    result = parseIPv6(input.slice(1, -1));
	    if (!result) return INVALID_HOST;
	    url.host = result;
	    // opaque host
	  } else if (!isSpecial(url)) {
	    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
	    result = '';
	    codePoints = arrayFrom(input);
	    for (index = 0; index < codePoints.length; index++) {
	      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
	    }
	    url.host = result;
	  } else {
	    input = stringPunycodeToAscii(input);
	    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
	    result = parseIPv4(input);
	    if (result === null) return INVALID_HOST;
	    url.host = result;
	  }
	};
	var parseIPv4 = function parseIPv4(input) {
	  var parts = input.split('.');
	  var partsLength, numbers, index, part, radix, number, ipv4;
	  if (parts.length && parts[parts.length - 1] == '') {
	    parts.pop();
	  }
	  partsLength = parts.length;
	  if (partsLength > 4) return input;
	  numbers = [];
	  for (index = 0; index < partsLength; index++) {
	    part = parts[index];
	    if (part == '') return input;
	    radix = 10;
	    if (part.length > 1 && part.charAt(0) == '0') {
	      radix = HEX_START.test(part) ? 16 : 8;
	      part = part.slice(radix == 8 ? 1 : 2);
	    }
	    if (part === '') {
	      number = 0;
	    } else {
	      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
	      number = parseInt(part, radix);
	    }
	    numbers.push(number);
	  }
	  for (index = 0; index < partsLength; index++) {
	    number = numbers[index];
	    if (index == partsLength - 1) {
	      if (number >= pow$4(256, 5 - partsLength)) return null;
	    } else if (number > 255) return null;
	  }
	  ipv4 = numbers.pop();
	  for (index = 0; index < numbers.length; index++) {
	    ipv4 += numbers[index] * pow$4(256, 3 - index);
	  }
	  return ipv4;
	};

	// eslint-disable-next-line max-statements
	var parseIPv6 = function parseIPv6(input) {
	  var address = [0, 0, 0, 0, 0, 0, 0, 0];
	  var pieceIndex = 0;
	  var compress = null;
	  var pointer = 0;
	  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;
	  var _char = function _char() {
	    return input.charAt(pointer);
	  };
	  if (_char() == ':') {
	    if (input.charAt(1) != ':') return;
	    pointer += 2;
	    pieceIndex++;
	    compress = pieceIndex;
	  }
	  while (_char()) {
	    if (pieceIndex == 8) return;
	    if (_char() == ':') {
	      if (compress !== null) return;
	      pointer++;
	      pieceIndex++;
	      compress = pieceIndex;
	      continue;
	    }
	    value = length = 0;
	    while (length < 4 && HEX.test(_char())) {
	      value = value * 16 + parseInt(_char(), 16);
	      pointer++;
	      length++;
	    }
	    if (_char() == '.') {
	      if (length == 0) return;
	      pointer -= length;
	      if (pieceIndex > 6) return;
	      numbersSeen = 0;
	      while (_char()) {
	        ipv4Piece = null;
	        if (numbersSeen > 0) {
	          if (_char() == '.' && numbersSeen < 4) pointer++;else return;
	        }
	        if (!DIGIT.test(_char())) return;
	        while (DIGIT.test(_char())) {
	          number = parseInt(_char(), 10);
	          if (ipv4Piece === null) ipv4Piece = number;else if (ipv4Piece == 0) return;else ipv4Piece = ipv4Piece * 10 + number;
	          if (ipv4Piece > 255) return;
	          pointer++;
	        }
	        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
	        numbersSeen++;
	        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
	      }
	      if (numbersSeen != 4) return;
	      break;
	    } else if (_char() == ':') {
	      pointer++;
	      if (!_char()) return;
	    } else if (_char()) return;
	    address[pieceIndex++] = value;
	  }
	  if (compress !== null) {
	    swaps = pieceIndex - compress;
	    pieceIndex = 7;
	    while (pieceIndex != 0 && swaps > 0) {
	      swap = address[pieceIndex];
	      address[pieceIndex--] = address[compress + swaps - 1];
	      address[compress + --swaps] = swap;
	    }
	  } else if (pieceIndex != 8) return;
	  return address;
	};
	var findLongestZeroSequence = function findLongestZeroSequence(ipv6) {
	  var maxIndex = null;
	  var maxLength = 1;
	  var currStart = null;
	  var currLength = 0;
	  var index = 0;
	  for (; index < 8; index++) {
	    if (ipv6[index] !== 0) {
	      if (currLength > maxLength) {
	        maxIndex = currStart;
	        maxLength = currLength;
	      }
	      currStart = null;
	      currLength = 0;
	    } else {
	      if (currStart === null) currStart = index;
	      ++currLength;
	    }
	  }
	  if (currLength > maxLength) {
	    maxIndex = currStart;
	    maxLength = currLength;
	  }
	  return maxIndex;
	};
	var serializeHost = function serializeHost(host) {
	  var result, index, compress, ignore0;
	  // ipv4
	  if (typeof host == 'number') {
	    result = [];
	    for (index = 0; index < 4; index++) {
	      result.unshift(host % 256);
	      host = floor$9(host / 256);
	    }
	    return result.join('.');
	    // ipv6
	  } else if (typeof host == 'object') {
	    result = '';
	    compress = findLongestZeroSequence(host);
	    for (index = 0; index < 8; index++) {
	      if (ignore0 && host[index] === 0) continue;
	      if (ignore0) ignore0 = false;
	      if (compress === index) {
	        result += index ? ':' : '::';
	        ignore0 = true;
	      } else {
	        result += host[index].toString(16);
	        if (index < 7) result += ':';
	      }
	    }
	    return '[' + result + ']';
	  }
	  return host;
	};
	var C0ControlPercentEncodeSet = {};
	var fragmentPercentEncodeSet = objectAssign({}, C0ControlPercentEncodeSet, {
	  ' ': 1,
	  '"': 1,
	  '<': 1,
	  '>': 1,
	  '`': 1
	});
	var pathPercentEncodeSet = objectAssign({}, fragmentPercentEncodeSet, {
	  '#': 1,
	  '?': 1,
	  '{': 1,
	  '}': 1
	});
	var userinfoPercentEncodeSet = objectAssign({}, pathPercentEncodeSet, {
	  '/': 1,
	  ':': 1,
	  ';': 1,
	  '=': 1,
	  '@': 1,
	  '[': 1,
	  '\\': 1,
	  ']': 1,
	  '^': 1,
	  '|': 1
	});
	var percentEncode = function percentEncode(_char2, set) {
	  var code = codeAt$1(_char2, 0);
	  return code > 0x20 && code < 0x7F && !has(set, _char2) ? _char2 : encodeURIComponent(_char2);
	};
	var specialSchemes = {
	  ftp: 21,
	  file: null,
	  http: 80,
	  https: 443,
	  ws: 80,
	  wss: 443
	};
	var isSpecial = function isSpecial(url) {
	  return has(specialSchemes, url.scheme);
	};
	var includesCredentials = function includesCredentials(url) {
	  return url.username != '' || url.password != '';
	};
	var cannotHaveUsernamePasswordPort = function cannotHaveUsernamePasswordPort(url) {
	  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
	};
	var isWindowsDriveLetter = function isWindowsDriveLetter(string, normalized) {
	  var second;
	  return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|');
	};
	var startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(string) {
	  var third;
	  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || (third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#');
	};
	var shortenURLsPath = function shortenURLsPath(url) {
	  var path = url.path;
	  var pathSize = path.length;
	  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
	    path.pop();
	  }
	};
	var isSingleDot = function isSingleDot(segment) {
	  return segment === '.' || segment.toLowerCase() === '%2e';
	};
	var isDoubleDot = function isDoubleDot(segment) {
	  segment = segment.toLowerCase();
	  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
	};

	// States:
	var SCHEME_START = {};
	var SCHEME = {};
	var NO_SCHEME = {};
	var SPECIAL_RELATIVE_OR_AUTHORITY = {};
	var PATH_OR_AUTHORITY = {};
	var RELATIVE = {};
	var RELATIVE_SLASH = {};
	var SPECIAL_AUTHORITY_SLASHES = {};
	var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
	var AUTHORITY = {};
	var HOST = {};
	var HOSTNAME = {};
	var PORT = {};
	var FILE = {};
	var FILE_SLASH = {};
	var FILE_HOST = {};
	var PATH_START = {};
	var PATH = {};
	var CANNOT_BE_A_BASE_URL_PATH = {};
	var QUERY = {};
	var FRAGMENT = {};

	// eslint-disable-next-line max-statements
	var parseURL = function parseURL(url, input, stateOverride, base) {
	  var state = stateOverride || SCHEME_START;
	  var pointer = 0;
	  var buffer = '';
	  var seenAt = false;
	  var seenBracket = false;
	  var seenPasswordToken = false;
	  var codePoints, _char3, bufferCodePoints, failure;
	  if (!stateOverride) {
	    url.scheme = '';
	    url.username = '';
	    url.password = '';
	    url.host = null;
	    url.port = null;
	    url.path = [];
	    url.query = null;
	    url.fragment = null;
	    url.cannotBeABaseURL = false;
	    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
	  }
	  input = input.replace(TAB_AND_NEW_LINE, '');
	  codePoints = arrayFrom(input);
	  while (pointer <= codePoints.length) {
	    _char3 = codePoints[pointer];
	    switch (state) {
	      case SCHEME_START:
	        if (_char3 && ALPHA.test(_char3)) {
	          buffer += _char3.toLowerCase();
	          state = SCHEME;
	        } else if (!stateOverride) {
	          state = NO_SCHEME;
	          continue;
	        } else return INVALID_SCHEME;
	        break;
	      case SCHEME:
	        if (_char3 && (ALPHANUMERIC.test(_char3) || _char3 == '+' || _char3 == '-' || _char3 == '.')) {
	          buffer += _char3.toLowerCase();
	        } else if (_char3 == ':') {
	          if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host)) return;
	          url.scheme = buffer;
	          if (stateOverride) {
	            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
	            return;
	          }
	          buffer = '';
	          if (url.scheme == 'file') {
	            state = FILE;
	          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
	            state = SPECIAL_RELATIVE_OR_AUTHORITY;
	          } else if (isSpecial(url)) {
	            state = SPECIAL_AUTHORITY_SLASHES;
	          } else if (codePoints[pointer + 1] == '/') {
	            state = PATH_OR_AUTHORITY;
	            pointer++;
	          } else {
	            url.cannotBeABaseURL = true;
	            url.path.push('');
	            state = CANNOT_BE_A_BASE_URL_PATH;
	          }
	        } else if (!stateOverride) {
	          buffer = '';
	          state = NO_SCHEME;
	          pointer = 0;
	          continue;
	        } else return INVALID_SCHEME;
	        break;
	      case NO_SCHEME:
	        if (!base || base.cannotBeABaseURL && _char3 != '#') return INVALID_SCHEME;
	        if (base.cannotBeABaseURL && _char3 == '#') {
	          url.scheme = base.scheme;
	          url.path = base.path.slice();
	          url.query = base.query;
	          url.fragment = '';
	          url.cannotBeABaseURL = true;
	          state = FRAGMENT;
	          break;
	        }
	        state = base.scheme == 'file' ? FILE : RELATIVE;
	        continue;
	      case SPECIAL_RELATIVE_OR_AUTHORITY:
	        if (_char3 == '/' && codePoints[pointer + 1] == '/') {
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	          pointer++;
	        } else {
	          state = RELATIVE;
	          continue;
	        }
	        break;
	      case PATH_OR_AUTHORITY:
	        if (_char3 == '/') {
	          state = AUTHORITY;
	          break;
	        } else {
	          state = PATH;
	          continue;
	        }
	      case RELATIVE:
	        url.scheme = base.scheme;
	        if (_char3 == EOF) {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = base.query;
	        } else if (_char3 == '/' || _char3 == '\\' && isSpecial(url)) {
	          state = RELATIVE_SLASH;
	        } else if (_char3 == '?') {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = '';
	          state = QUERY;
	        } else if (_char3 == '#') {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = base.query;
	          url.fragment = '';
	          state = FRAGMENT;
	        } else {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.path.pop();
	          state = PATH;
	          continue;
	        }
	        break;
	      case RELATIVE_SLASH:
	        if (isSpecial(url) && (_char3 == '/' || _char3 == '\\')) {
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	        } else if (_char3 == '/') {
	          state = AUTHORITY;
	        } else {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          state = PATH;
	          continue;
	        }
	        break;
	      case SPECIAL_AUTHORITY_SLASHES:
	        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	        if (_char3 != '/' || buffer.charAt(pointer + 1) != '/') continue;
	        pointer++;
	        break;
	      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
	        if (_char3 != '/' && _char3 != '\\') {
	          state = AUTHORITY;
	          continue;
	        }
	        break;
	      case AUTHORITY:
	        if (_char3 == '@') {
	          if (seenAt) buffer = '%40' + buffer;
	          seenAt = true;
	          bufferCodePoints = arrayFrom(buffer);
	          for (var i = 0; i < bufferCodePoints.length; i++) {
	            var codePoint = bufferCodePoints[i];
	            if (codePoint == ':' && !seenPasswordToken) {
	              seenPasswordToken = true;
	              continue;
	            }
	            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
	            if (seenPasswordToken) url.password += encodedCodePoints;else url.username += encodedCodePoints;
	          }
	          buffer = '';
	        } else if (_char3 == EOF || _char3 == '/' || _char3 == '?' || _char3 == '#' || _char3 == '\\' && isSpecial(url)) {
	          if (seenAt && buffer == '') return INVALID_AUTHORITY;
	          pointer -= arrayFrom(buffer).length + 1;
	          buffer = '';
	          state = HOST;
	        } else buffer += _char3;
	        break;
	      case HOST:
	      case HOSTNAME:
	        if (stateOverride && url.scheme == 'file') {
	          state = FILE_HOST;
	          continue;
	        } else if (_char3 == ':' && !seenBracket) {
	          if (buffer == '') return INVALID_HOST;
	          failure = parseHost(url, buffer);
	          if (failure) return failure;
	          buffer = '';
	          state = PORT;
	          if (stateOverride == HOSTNAME) return;
	        } else if (_char3 == EOF || _char3 == '/' || _char3 == '?' || _char3 == '#' || _char3 == '\\' && isSpecial(url)) {
	          if (isSpecial(url) && buffer == '') return INVALID_HOST;
	          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
	          failure = parseHost(url, buffer);
	          if (failure) return failure;
	          buffer = '';
	          state = PATH_START;
	          if (stateOverride) return;
	          continue;
	        } else {
	          if (_char3 == '[') seenBracket = true;else if (_char3 == ']') seenBracket = false;
	          buffer += _char3;
	        }
	        break;
	      case PORT:
	        if (DIGIT.test(_char3)) {
	          buffer += _char3;
	        } else if (_char3 == EOF || _char3 == '/' || _char3 == '?' || _char3 == '#' || _char3 == '\\' && isSpecial(url) || stateOverride) {
	          if (buffer != '') {
	            var port = parseInt(buffer, 10);
	            if (port > 0xFFFF) return INVALID_PORT;
	            url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
	            buffer = '';
	          }
	          if (stateOverride) return;
	          state = PATH_START;
	          continue;
	        } else return INVALID_PORT;
	        break;
	      case FILE:
	        url.scheme = 'file';
	        if (_char3 == '/' || _char3 == '\\') state = FILE_SLASH;else if (base && base.scheme == 'file') {
	          if (_char3 == EOF) {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = base.query;
	          } else if (_char3 == '?') {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = '';
	            state = QUERY;
	          } else if (_char3 == '#') {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = base.query;
	            url.fragment = '';
	            state = FRAGMENT;
	          } else {
	            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
	              url.host = base.host;
	              url.path = base.path.slice();
	              shortenURLsPath(url);
	            }
	            state = PATH;
	            continue;
	          }
	        } else {
	          state = PATH;
	          continue;
	        }
	        break;
	      case FILE_SLASH:
	        if (_char3 == '/' || _char3 == '\\') {
	          state = FILE_HOST;
	          break;
	        }
	        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
	          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);else url.host = base.host;
	        }
	        state = PATH;
	        continue;
	      case FILE_HOST:
	        if (_char3 == EOF || _char3 == '/' || _char3 == '\\' || _char3 == '?' || _char3 == '#') {
	          if (!stateOverride && isWindowsDriveLetter(buffer)) {
	            state = PATH;
	          } else if (buffer == '') {
	            url.host = '';
	            if (stateOverride) return;
	            state = PATH_START;
	          } else {
	            failure = parseHost(url, buffer);
	            if (failure) return failure;
	            if (url.host == 'localhost') url.host = '';
	            if (stateOverride) return;
	            buffer = '';
	            state = PATH_START;
	          }
	          continue;
	        } else buffer += _char3;
	        break;
	      case PATH_START:
	        if (isSpecial(url)) {
	          state = PATH;
	          if (_char3 != '/' && _char3 != '\\') continue;
	        } else if (!stateOverride && _char3 == '?') {
	          url.query = '';
	          state = QUERY;
	        } else if (!stateOverride && _char3 == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (_char3 != EOF) {
	          state = PATH;
	          if (_char3 != '/') continue;
	        }
	        break;
	      case PATH:
	        if (_char3 == EOF || _char3 == '/' || _char3 == '\\' && isSpecial(url) || !stateOverride && (_char3 == '?' || _char3 == '#')) {
	          if (isDoubleDot(buffer)) {
	            shortenURLsPath(url);
	            if (_char3 != '/' && !(_char3 == '\\' && isSpecial(url))) {
	              url.path.push('');
	            }
	          } else if (isSingleDot(buffer)) {
	            if (_char3 != '/' && !(_char3 == '\\' && isSpecial(url))) {
	              url.path.push('');
	            }
	          } else {
	            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
	              if (url.host) url.host = '';
	              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
	            }
	            url.path.push(buffer);
	          }
	          buffer = '';
	          if (url.scheme == 'file' && (_char3 == EOF || _char3 == '?' || _char3 == '#')) {
	            while (url.path.length > 1 && url.path[0] === '') {
	              url.path.shift();
	            }
	          }
	          if (_char3 == '?') {
	            url.query = '';
	            state = QUERY;
	          } else if (_char3 == '#') {
	            url.fragment = '';
	            state = FRAGMENT;
	          }
	        } else {
	          buffer += percentEncode(_char3, pathPercentEncodeSet);
	        }
	        break;
	      case CANNOT_BE_A_BASE_URL_PATH:
	        if (_char3 == '?') {
	          url.query = '';
	          state = QUERY;
	        } else if (_char3 == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (_char3 != EOF) {
	          url.path[0] += percentEncode(_char3, C0ControlPercentEncodeSet);
	        }
	        break;
	      case QUERY:
	        if (!stateOverride && _char3 == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (_char3 != EOF) {
	          if (_char3 == "'" && isSpecial(url)) url.query += '%27';else if (_char3 == '#') url.query += '%23';else url.query += percentEncode(_char3, C0ControlPercentEncodeSet);
	        }
	        break;
	      case FRAGMENT:
	        if (_char3 != EOF) url.fragment += percentEncode(_char3, fragmentPercentEncodeSet);
	        break;
	    }
	    pointer++;
	  }
	};

	// `URL` constructor
	// https://url.spec.whatwg.org/#url-class
	var URLConstructor = function URL(url /* , base */) {
	  var that = anInstance(this, URLConstructor, 'URL');
	  var base = arguments.length > 1 ? arguments[1] : undefined;
	  var urlString = String(url);
	  var state = setInternalState$9(that, {
	    type: 'URL'
	  });
	  var baseState, failure;
	  if (base !== undefined) {
	    if (base instanceof URLConstructor) baseState = getInternalURLState(base);else {
	      failure = parseURL(baseState = {}, String(base));
	      if (failure) throw TypeError(failure);
	    }
	  }
	  failure = parseURL(state, urlString, null, baseState);
	  if (failure) throw TypeError(failure);
	  var searchParams = state.searchParams = new URLSearchParams$1();
	  var searchParamsState = getInternalSearchParamsState(searchParams);
	  searchParamsState.updateSearchParams(state.query);
	  searchParamsState.updateURL = function () {
	    state.query = String(searchParams) || null;
	  };
	  if (!descriptors) {
	    that.href = serializeURL.call(that);
	    that.origin = getOrigin.call(that);
	    that.protocol = getProtocol.call(that);
	    that.username = getUsername.call(that);
	    that.password = getPassword.call(that);
	    that.host = getHost.call(that);
	    that.hostname = getHostname.call(that);
	    that.port = getPort.call(that);
	    that.pathname = getPathname.call(that);
	    that.search = getSearch.call(that);
	    that.searchParams = getSearchParams.call(that);
	    that.hash = getHash.call(that);
	  }
	};
	var URLPrototype = URLConstructor.prototype;
	var serializeURL = function serializeURL() {
	  var url = getInternalURLState(this);
	  var scheme = url.scheme;
	  var username = url.username;
	  var password = url.password;
	  var host = url.host;
	  var port = url.port;
	  var path = url.path;
	  var query = url.query;
	  var fragment = url.fragment;
	  var output = scheme + ':';
	  if (host !== null) {
	    output += '//';
	    if (includesCredentials(url)) {
	      output += username + (password ? ':' + password : '') + '@';
	    }
	    output += serializeHost(host);
	    if (port !== null) output += ':' + port;
	  } else if (scheme == 'file') output += '//';
	  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
	  if (query !== null) output += '?' + query;
	  if (fragment !== null) output += '#' + fragment;
	  return output;
	};
	var getOrigin = function getOrigin() {
	  var url = getInternalURLState(this);
	  var scheme = url.scheme;
	  var port = url.port;
	  if (scheme == 'blob') try {
	    return new URL(scheme.path[0]).origin;
	  } catch (error) {
	    return 'null';
	  }
	  if (scheme == 'file' || !isSpecial(url)) return 'null';
	  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
	};
	var getProtocol = function getProtocol() {
	  return getInternalURLState(this).scheme + ':';
	};
	var getUsername = function getUsername() {
	  return getInternalURLState(this).username;
	};
	var getPassword = function getPassword() {
	  return getInternalURLState(this).password;
	};
	var getHost = function getHost() {
	  var url = getInternalURLState(this);
	  var host = url.host;
	  var port = url.port;
	  return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
	};
	var getHostname = function getHostname() {
	  var host = getInternalURLState(this).host;
	  return host === null ? '' : serializeHost(host);
	};
	var getPort = function getPort() {
	  var port = getInternalURLState(this).port;
	  return port === null ? '' : String(port);
	};
	var getPathname = function getPathname() {
	  var url = getInternalURLState(this);
	  var path = url.path;
	  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
	};
	var getSearch = function getSearch() {
	  var query = getInternalURLState(this).query;
	  return query ? '?' + query : '';
	};
	var getSearchParams = function getSearchParams() {
	  return getInternalURLState(this).searchParams;
	};
	var getHash = function getHash() {
	  var fragment = getInternalURLState(this).fragment;
	  return fragment ? '#' + fragment : '';
	};
	var accessorDescriptor = function accessorDescriptor(getter, setter) {
	  return {
	    get: getter,
	    set: setter,
	    configurable: true,
	    enumerable: true
	  };
	};
	if (descriptors) {
	  objectDefineProperties(URLPrototype, {
	    // `URL.prototype.href` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-href
	    href: accessorDescriptor(serializeURL, function (href) {
	      var url = getInternalURLState(this);
	      var urlString = String(href);
	      var failure = parseURL(url, urlString);
	      if (failure) throw TypeError(failure);
	      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
	    }),
	    // `URL.prototype.origin` getter
	    // https://url.spec.whatwg.org/#dom-url-origin
	    origin: accessorDescriptor(getOrigin),
	    // `URL.prototype.protocol` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-protocol
	    protocol: accessorDescriptor(getProtocol, function (protocol) {
	      var url = getInternalURLState(this);
	      parseURL(url, String(protocol) + ':', SCHEME_START);
	    }),
	    // `URL.prototype.username` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-username
	    username: accessorDescriptor(getUsername, function (username) {
	      var url = getInternalURLState(this);
	      var codePoints = arrayFrom(String(username));
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      url.username = '';
	      for (var i = 0; i < codePoints.length; i++) {
	        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	      }
	    }),
	    // `URL.prototype.password` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-password
	    password: accessorDescriptor(getPassword, function (password) {
	      var url = getInternalURLState(this);
	      var codePoints = arrayFrom(String(password));
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      url.password = '';
	      for (var i = 0; i < codePoints.length; i++) {
	        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	      }
	    }),
	    // `URL.prototype.host` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-host
	    host: accessorDescriptor(getHost, function (host) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      parseURL(url, String(host), HOST);
	    }),
	    // `URL.prototype.hostname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hostname
	    hostname: accessorDescriptor(getHostname, function (hostname) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      parseURL(url, String(hostname), HOSTNAME);
	    }),
	    // `URL.prototype.port` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-port
	    port: accessorDescriptor(getPort, function (port) {
	      var url = getInternalURLState(this);
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      port = String(port);
	      if (port == '') url.port = null;else parseURL(url, port, PORT);
	    }),
	    // `URL.prototype.pathname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-pathname
	    pathname: accessorDescriptor(getPathname, function (pathname) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      url.path = [];
	      parseURL(url, pathname + '', PATH_START);
	    }),
	    // `URL.prototype.search` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-search
	    search: accessorDescriptor(getSearch, function (search) {
	      var url = getInternalURLState(this);
	      search = String(search);
	      if (search == '') {
	        url.query = null;
	      } else {
	        if ('?' == search.charAt(0)) search = search.slice(1);
	        url.query = '';
	        parseURL(url, search, QUERY);
	      }
	      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
	    }),
	    // `URL.prototype.searchParams` getter
	    // https://url.spec.whatwg.org/#dom-url-searchparams
	    searchParams: accessorDescriptor(getSearchParams),
	    // `URL.prototype.hash` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hash
	    hash: accessorDescriptor(getHash, function (hash) {
	      var url = getInternalURLState(this);
	      hash = String(hash);
	      if (hash == '') {
	        url.fragment = null;
	        return;
	      }
	      if ('#' == hash.charAt(0)) hash = hash.slice(1);
	      url.fragment = '';
	      parseURL(url, hash, FRAGMENT);
	    })
	  });
	}

	// `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson
	redefine(URLPrototype, 'toJSON', function toJSON() {
	  return serializeURL.call(this);
	}, {
	  enumerable: true
	});

	// `URL.prototype.toString` method
	// https://url.spec.whatwg.org/#URL-stringification-behavior
	redefine(URLPrototype, 'toString', function toString() {
	  return serializeURL.call(this);
	}, {
	  enumerable: true
	});
	if (NativeURL) {
	  var nativeCreateObjectURL = NativeURL.createObjectURL;
	  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
	  // `URL.createObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
	  // eslint-disable-next-line no-unused-vars
	  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
	    return nativeCreateObjectURL.apply(NativeURL, arguments);
	  });
	  // `URL.revokeObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
	  // eslint-disable-next-line no-unused-vars
	  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
	    return nativeRevokeObjectURL.apply(NativeURL, arguments);
	  });
	}
	setToStringTag(URLConstructor, 'URL');
	_export({
	  global: true,
	  forced: !nativeUrl,
	  sham: !descriptors
	}, {
	  URL: URLConstructor
	});

	// `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson
	_export({
	  target: 'URL',
	  proto: true,
	  enumerable: true
	}, {
	  toJSON: function toJSON() {
	    return URL.prototype.toString.call(this);
	  }
	});

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function ownKeys$1(object, enumerableOnly) {
	  var keys = Object.keys(object);

	  if (Object.getOwnPropertySymbols) {
	    var symbols = Object.getOwnPropertySymbols(object);
	    if (enumerableOnly) symbols = symbols.filter(function (sym) {
	      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
	    });
	    keys.push.apply(keys, symbols);
	  }

	  return keys;
	}

	function _objectSpread2(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};

	    if (i % 2) {
	      ownKeys$1(Object(source), true).forEach(function (key) {
	        _defineProperty(target, key, source[key]);
	      });
	    } else if (Object.getOwnPropertyDescriptors) {
	      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
	    } else {
	      ownKeys$1(Object(source)).forEach(function (key) {
	        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
	      });
	    }
	  }

	  return target;
	}

	(function () {
	  function buggy() {
	    function detect() {
	      var a = [0, 1];
	      a.reverse();
	      return a[0] === 0;
	    }
	    return detect() || detect();
	  }
	  if (!buggy()) return;
	  Array.prototype._reverse = Array.prototype.reverse;
	  Array.prototype.reverse = function reverse() {
	    if (Array.isArray(this)) this.length = this.length;
	    return Array.prototype._reverse.call(this);
	  };
	  var nonenum = {
	    enumerable: false
	  };
	  Object.defineProperties(Array.prototype, {
	    _reverse: nonenum,
	    reverse: nonenum
	  });
	})();

	var runtime_1 = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var runtime = function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var defineProperty = Object.defineProperty || function (obj, key, desc) {
	    obj[key] = desc.value;
	  };
	  var undefined$1; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	  function define(obj, key, value) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	    return obj[key];
	  }
	  try {
	    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
	    define({}, "");
	  } catch (err) {
	    define = function define(obj, key, value) {
	      return obj[key] = value;
	    };
	  }
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    defineProperty(generator, "_invoke", {
	      value: makeInvokeMethod(innerFn, self, context)
	    });
	    return generator;
	  }
	  exports.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return {
	        type: "normal",
	        arg: fn.call(obj, arg)
	      };
	    } catch (err) {
	      return {
	        type: "throw",
	        arg: err
	      };
	    }
	  }
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  define(IteratorPrototype, iteratorSymbol, function () {
	    return this;
	  });
	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = GeneratorFunctionPrototype;
	  defineProperty(Gp, "constructor", {
	    value: GeneratorFunctionPrototype,
	    configurable: true
	  });
	  defineProperty(GeneratorFunctionPrototype, "constructor", {
	    value: GeneratorFunction,
	    configurable: true
	  });
	  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function (method) {
	      define(prototype, method, function (arg) {
	        return this._invoke(method, arg);
	      });
	    });
	  }
	  exports.isGeneratorFunction = function (genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor ? ctor === GeneratorFunction ||
	    // For the native GeneratorFunction constructor, the best we can
	    // do is to check its .name property.
	    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
	  };
	  exports.mark = function (genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      define(genFun, toStringTagSymbol, "GeneratorFunction");
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  exports.awrap = function (arg) {
	    return {
	      __await: arg
	    };
	  };
	  function AsyncIterator(generator, PromiseImpl) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
	          return PromiseImpl.resolve(value.__await).then(function (value) {
	            invoke("next", value, resolve, reject);
	          }, function (err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	        return PromiseImpl.resolve(value).then(function (unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function (error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }
	    var previousPromise;
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new PromiseImpl(function (resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	      return previousPromise =
	      // If enqueue has been called before, then we want to wait until
	      // all previous Promises have been resolved before calling invoke,
	      // so that results are always delivered in the correct order. If
	      // enqueue has not been called before, then it is important to
	      // call invoke immediately, without waiting on a callback to fire,
	      // so that the async generator function has the opportunity to do
	      // any necessary setup in a predictable way. This predictability
	      // is why the Promise constructor synchronously invokes its
	      // executor callback, and why async functions synchronously
	      // execute code before the first await. Since we implement simple
	      // async functions in terms of async generators, it is especially
	      // important to get this right, even though it requires care.
	      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
	      // Avoid propagating failures to Promises returned by later
	      // invocations of the iterator.
	      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    defineProperty(this, "_invoke", {
	      value: enqueue
	    });
	  }
	  defineIteratorMethods(AsyncIterator.prototype);
	  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
	    return this;
	  });
	  exports.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
	    if (PromiseImpl === void 0) PromiseImpl = Promise;
	    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
	    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
	    : iter.next().then(function (result) {
	      return result.done ? result.value : iter.next();
	    });
	  };
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	      context.method = method;
	      context.arg = arg;
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }
	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;
	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }
	          context.dispatchException(context.arg);
	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }
	        state = GenStateExecuting;
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done ? GenStateCompleted : GenStateSuspendedYield;
	          if (record.arg === ContinueSentinel) {
	            continue;
	          }
	          return {
	            value: record.arg,
	            done: context.done
	          };
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var methodName = context.method;
	    var method = delegate.iterator[methodName];
	    if (method === undefined$1) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method, or a missing .next mehtod, always terminate the
	      // yield* loop.
	      context.delegate = null;

	      // Note: ["return"] must be used for ES3 parsing compatibility.
	      if (methodName === "throw" && delegate.iterator["return"]) {
	        // If the delegate iterator has a return method, give it a
	        // chance to clean up.
	        context.method = "return";
	        context.arg = undefined$1;
	        maybeInvokeDelegate(delegate, context);
	        if (context.method === "throw") {
	          // If maybeInvokeDelegate(context) changed context.method from
	          // "return" to "throw", let that override the TypeError below.
	          return ContinueSentinel;
	        }
	      }
	      if (methodName !== "return") {
	        context.method = "throw";
	        context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method");
	      }
	      return ContinueSentinel;
	    }
	    var record = tryCatch(method, delegate.iterator, context.arg);
	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	    var info = record.arg;
	    if (!info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }
	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }
	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	  define(Gp, toStringTagSymbol, "Generator");

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  define(Gp, iteratorSymbol, function () {
	    return this;
	  });
	  define(Gp, "toString", function () {
	    return "[object Generator]";
	  });
	  function pushTryEntry(locs) {
	    var entry = {
	      tryLoc: locs[0]
	    };
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	    this.tryEntries.push(entry);
	  }
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{
	      tryLoc: "root"
	    }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	  exports.keys = function (val) {
	    var object = Object(val);
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	      if (!isNaN(iterable.length)) {
	        var i = -1,
	          next = function next() {
	            while (++i < iterable.length) {
	              if (hasOwn.call(iterable, i)) {
	                next.value = iterable[i];
	                next.done = false;
	                return next;
	              }
	            }
	            next.value = undefined$1;
	            next.done = true;
	            return next;
	          };
	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return {
	      next: doneResult
	    };
	  }
	  exports.values = values;
	  function doneResult() {
	    return {
	      value: undefined$1,
	      done: true
	    };
	  }
	  Context.prototype = {
	    constructor: Context,
	    reset: function reset(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;
	      this.method = "next";
	      this.arg = undefined$1;
	      this.tryEntries.forEach(resetTryEntry);
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },
	    stop: function stop() {
	      this.done = true;
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	      return this.rval;
	    },
	    dispatchException: function dispatchException(exception) {
	      if (this.done) {
	        throw exception;
	      }
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined$1;
	        }
	        return !!caught;
	      }
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	    abrupt: function abrupt(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }
	      return this.complete(record);
	    },
	    complete: function complete(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	      if (record.type === "break" || record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	      return ContinueSentinel;
	    },
	    finish: function finish(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	    "catch": function _catch(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined$1;
	      }
	      return ContinueSentinel;
	    }
	  };

	  // Regardless of whether this script is executing as a CommonJS module
	  // or not, return the runtime object so that we can declare the variable
	  // regeneratorRuntime in the outer scope, which allows this module to be
	  // injected easily by `bin/regenerator --include-runtime script.js`.
	  return exports;
	}(
	// If this script is executing as a CommonJS module, use module.exports
	// as the regeneratorRuntime namespace. Otherwise create a new empty
	// object. Either way, the resulting object will be used to initialize
	// the regeneratorRuntime variable at the top of this file.
	 module.exports );
	try {
	  regeneratorRuntime = runtime;
	} catch (accidentalStrictMode) {
	  // This module should not be running in strict mode, so the above
	  // assignment should always work unless something is misconfigured. Just
	  // in case runtime.js accidentally runs in strict mode, in modern engines
	  // we can explicitly access globalThis. In older engines we can escape
	  // strict mode using a global Function call. This could conceivably fail
	  // if a Content Security Policy forbids using Function, but in that case
	  // the proper solution is to fix the accidental strict mode problem. If
	  // you've misconfigured your bundler to force strict mode and applied a
	  // CSP to forbid Function, and you're not willing to fix either of those
	  // problems, please detail your unique predicament in a GitHub issue.
	  if (typeof globalThis === "object") {
	    globalThis.regeneratorRuntime = runtime;
	  } else {
	    Function("r", "regeneratorRuntime = r")(runtime);
	  }
	}
	});

	var PAGE_DID_ACTIVATE = 'PAGE_DID_ACTIVATE';
	var PAGE_WILL_ACTIVATE = 'PAGE_WILL_ACTIVATE';
	var PAGE_DID_DEACTIVATE = 'PAGE_DID_DEACTIVATE';
	var PAGE_WILL_DEACTIVATE = 'PAGE_WILL_DEACTIVATE';
	var PAGE_DID_PRELOAD = 'PAGE_DID_PRELOAD';
	var PAGE_DID_PREPARE = 'PAGE_DID_PREPARE';
	var PAGE_SCHEDULE_UNPREPARE = 'PAGE_SCHEDULE_UNPREPARE';
	var PAGE_DID_UNPREPARE = 'PAGE_DID_UNPREPARE';
	var PAGE_DID_RESIZE = 'PAGE_DID_RESIZE';
	var ENHANCE = 'PAGE_ENHANCE';
	var CLEANUP = 'PAGE_CLEANUP';
	var UPDATE_PAGE_ATTRIBUTE = 'UPDATE_PAGE_ATTRIBUTE';
	var UPDATE_PAGE_LINK = 'UPDATE_PAGE_LINK';
	function pageWillActivate() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref.id,
	    position = _ref.position;
	  return pageAction(PAGE_WILL_ACTIVATE, id, {
	    position: position
	  });
	}
	function pageDidActivate() {
	  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref2.id;
	  return pageAction(PAGE_DID_ACTIVATE, id);
	}
	function pageWillDeactivate() {
	  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref3.id;
	  return pageAction(PAGE_WILL_DEACTIVATE, id);
	}
	function pageDidDeactivate() {
	  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref4.id;
	  return pageAction(PAGE_DID_DEACTIVATE, id);
	}
	function pageDidPreload() {
	  var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref5.id;
	  return pageAction(PAGE_DID_PRELOAD, id);
	}
	function pageDidPrepare() {
	  var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref6.id;
	  return pageAction(PAGE_DID_PREPARE, id);
	}
	function pageScheduleUnprepare() {
	  var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref7.id;
	  return pageAction(PAGE_SCHEDULE_UNPREPARE, id);
	}
	function pageDidUnprepare() {
	  var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref8.id;
	  return pageAction(PAGE_DID_UNPREPARE, id);
	}
	function pageDidResize() {
	  var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref9.id;
	  return pageAction(PAGE_DID_RESIZE, id);
	}
	function enhance() {
	  var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref10.id;
	  return pageAction(ENHANCE, id);
	}
	function cleanup() {
	  var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref11.id;
	  return pageAction(CLEANUP, id);
	}
	function updatePageAttribute() {
	  var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    id = _ref12.id,
	    name = _ref12.name,
	    value = _ref12.value;
	  return pageAction(UPDATE_PAGE_ATTRIBUTE, id, {
	    name: name,
	    value: value
	  });
	}
	function updatePageLink() {
	  var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    pageId = _ref13.pageId,
	    linkId = _ref13.linkId,
	    name = _ref13.name,
	    value = _ref13.value;
	  return pageAction(UPDATE_PAGE_LINK, pageId, {
	    linkId: linkId,
	    name: name,
	    value: value
	  });
	}
	function pageAction(type, pageId) {
	  var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  return {
	    type: type,
	    meta: {
	      collectionName: 'pages',
	      itemId: pageId
	    },
	    payload: payload
	  };
	}

	var LOAD = 'SETTINGS_LOAD';
	var UPDATE = 'SETTINGS_UPDATE';
	function load(_ref) {
	  var settings = _ref.settings;
	  return {
	    type: LOAD,
	    payload: {
	      settings: settings
	    }
	  };
	}
	function update(_ref2) {
	  var property = _ref2.property,
	    value = _ref2.value;
	  return {
	    type: UPDATE,
	    payload: {
	      property: property,
	      value: value
	    }
	  };
	}



	var actions = /*#__PURE__*/Object.freeze({
		__proto__: null,
		updatePageAttribute: updatePageAttribute,
		updatePageLink: updatePageLink,
		updateSetting: update
	});

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    _typeof = function _typeof(obj) {
	      return typeof obj;
	    };
	  } else {
	    _typeof = function _typeof(obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (_typeof(call) === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
	  if (Reflect.construct.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	var classnames = createCommonjsModule(function (module) {
	/*!
		Copyright (c) 2018 Jed Watson.
		Licensed under the MIT License (MIT), see
		http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {

	  var hasOwn = {}.hasOwnProperty;
	  function classNames() {
	    var classes = '';
	    for (var i = 0; i < arguments.length; i++) {
	      var arg = arguments[i];
	      if (arg) {
	        classes = appendClass(classes, parseValue(arg));
	      }
	    }
	    return classes;
	  }
	  function parseValue(arg) {
	    if (typeof arg === 'string' || typeof arg === 'number') {
	      return arg;
	    }
	    if (typeof arg !== 'object') {
	      return '';
	    }
	    if (Array.isArray(arg)) {
	      return classNames.apply(null, arg);
	    }
	    if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
	      return arg.toString();
	    }
	    var classes = '';
	    for (var key in arg) {
	      if (hasOwn.call(arg, key) && arg[key]) {
	        classes = appendClass(classes, key);
	      }
	    }
	    return classes;
	  }
	  function appendClass(value, newClass) {
	    if (!newClass) {
	      return value;
	    }
	    if (value) {
	      return value + ' ' + newClass;
	    }
	    return value + newClass;
	  }
	  if ( module.exports) {
	    classNames["default"] = classNames;
	    module.exports = classNames;
	  } else {
	    window.classNames = classNames;
	  }
	})();
	});

	function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }

	/**
	 * @desc Used to build the default page structure. Requires
	 * {@link pageflow.react.components.PageBackground|PageBackground} and either
	 * {@link pageflow.react.components.PageForeground|PageForeground} or
	 * {@link pageflow.react.components.PageContent|PageContent} as children.
	 *
	 * @alias pageflow.react.components.PageWrapper
	 * @class
	 * @since 0.1
	 *
	 * @prop className
	 *   Additional class names.
	 *
	 * @example
	 *
	 * <PageWrapper>
	 *   <PageBackground>
	 *      <PageBackgroundImage page={page} />
	 *      <PageShadow page={page} />
	 *   </PageBackground>
	 *
	 *    <PageForeground>
	 *      <PageScroller>
	 *        <PageHeader page={page} />
	 *        <PageText page={page} />
	 *      </PageScroller>
	 *    </PageForeground>
	 *  </PageWrapper>
	 *
	 * @example
	 *
	 * <PageWrapper>
	 *   <PageBackground>
	 *      <PageBackgroundImage page={page} />
	 *      <PageShadow page={page} />
	 *   </PageBackground>
	 *
	 *    <PageContent>
	 *      <PageHeader page={page} />
	 *      <PageText page={page} />
	 *    </PageContent>
	 *  </PageWrapper>
	 */
	var _default = /*#__PURE__*/function (_Component) {
	  _inherits(_default, _Component);
	  function _default() {
	    _classCallCheck(this, _default);
	    return _callSuper(this, _default, arguments);
	  }
	  _createClass(_default, [{
	    key: "render",
	    value: function render() {
	      return /*#__PURE__*/React.createElement("div", {
	        className: classnames('content_and_background', this.props.className)
	      }, this.props.children);
	    }
	  }]);
	  return _default;
	}(React$1.Component);

	/**
	 * @desc Use inside {@link
	 * pageflow.react.components.PageWrapper|PageWrapper} to build the
	 * default page structure.
	 *
	 * @prop pageHasPlayerControls
	 *   Set to true if player controls are present on the page. This can
	 *   be used by themes to apply different styles to the background.
	 *
	 * @alias pageflow.react.components.PageBackground
	 * @class
	 * @since 0.1
	 */
	function PageBackground(props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: className(props)
	  }, props.children);
	}
	function className(_ref) {
	  var pageHasPlayerControls = _ref.pageHasPlayerControls;
	  return classnames('page_background', {
	    'page_background-for_page_with_player_controls': pageHasPlayerControls
	  });
	}

	var striptags = createCommonjsModule(function (module) {

	(function (global) {
	  // minimal symbol polyfill for IE11 and others
	  if (typeof Symbol !== 'function') {
	    var Symbol = function Symbol(name) {
	      return name;
	    };
	    Symbol.nonNative = true;
	  }
	  var STATE_PLAINTEXT = Symbol('plaintext');
	  var STATE_HTML = Symbol('html');
	  var STATE_COMMENT = Symbol('comment');
	  var ALLOWED_TAGS_REGEX = /<(\w*)>/g;
	  var NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;
	  function striptags(html, allowable_tags, tag_replacement) {
	    html = html || '';
	    allowable_tags = allowable_tags || [];
	    tag_replacement = tag_replacement || '';
	    var context = init_context(allowable_tags, tag_replacement);
	    return striptags_internal(html, context);
	  }
	  function init_striptags_stream(allowable_tags, tag_replacement) {
	    allowable_tags = allowable_tags || [];
	    tag_replacement = tag_replacement || '';
	    var context = init_context(allowable_tags, tag_replacement);
	    return function striptags_stream(html) {
	      return striptags_internal(html || '', context);
	    };
	  }
	  striptags.init_streaming_mode = init_striptags_stream;
	  function init_context(allowable_tags, tag_replacement) {
	    allowable_tags = parse_allowable_tags(allowable_tags);
	    return {
	      allowable_tags: allowable_tags,
	      tag_replacement: tag_replacement,
	      state: STATE_PLAINTEXT,
	      tag_buffer: '',
	      depth: 0,
	      in_quote_char: ''
	    };
	  }
	  function striptags_internal(html, context) {
	    if (typeof html != "string") {
	      throw new TypeError("'html' parameter must be a string");
	    }
	    var allowable_tags = context.allowable_tags;
	    var tag_replacement = context.tag_replacement;
	    var state = context.state;
	    var tag_buffer = context.tag_buffer;
	    var depth = context.depth;
	    var in_quote_char = context.in_quote_char;
	    var output = '';
	    for (var idx = 0, length = html.length; idx < length; idx++) {
	      var _char = html[idx];
	      if (state === STATE_PLAINTEXT) {
	        switch (_char) {
	          case '<':
	            state = STATE_HTML;
	            tag_buffer += _char;
	            break;
	          default:
	            output += _char;
	            break;
	        }
	      } else if (state === STATE_HTML) {
	        switch (_char) {
	          case '<':
	            // ignore '<' if inside a quote
	            if (in_quote_char) {
	              break;
	            }

	            // we're seeing a nested '<'
	            depth++;
	            break;
	          case '>':
	            // ignore '>' if inside a quote
	            if (in_quote_char) {
	              break;
	            }

	            // something like this is happening: '<<>>'
	            if (depth) {
	              depth--;
	              break;
	            }

	            // this is closing the tag in tag_buffer
	            in_quote_char = '';
	            state = STATE_PLAINTEXT;
	            tag_buffer += '>';
	            if (allowable_tags.has(normalize_tag(tag_buffer))) {
	              output += tag_buffer;
	            } else {
	              output += tag_replacement;
	            }
	            tag_buffer = '';
	            break;
	          case '"':
	          case '\'':
	            // catch both single and double quotes

	            if (_char === in_quote_char) {
	              in_quote_char = '';
	            } else {
	              in_quote_char = in_quote_char || _char;
	            }
	            tag_buffer += _char;
	            break;
	          case '-':
	            if (tag_buffer === '<!-') {
	              state = STATE_COMMENT;
	            }
	            tag_buffer += _char;
	            break;
	          case ' ':
	          case '\n':
	            if (tag_buffer === '<') {
	              state = STATE_PLAINTEXT;
	              output += '< ';
	              tag_buffer = '';
	              break;
	            }
	            tag_buffer += _char;
	            break;
	          default:
	            tag_buffer += _char;
	            break;
	        }
	      } else if (state === STATE_COMMENT) {
	        switch (_char) {
	          case '>':
	            if (tag_buffer.slice(-2) == '--') {
	              // close the comment
	              state = STATE_PLAINTEXT;
	            }
	            tag_buffer = '';
	            break;
	          default:
	            tag_buffer += _char;
	            break;
	        }
	      }
	    }

	    // save the context for future iterations
	    context.state = state;
	    context.tag_buffer = tag_buffer;
	    context.depth = depth;
	    context.in_quote_char = in_quote_char;
	    return output;
	  }
	  function parse_allowable_tags(allowable_tags) {
	    var tag_set = new Set();
	    if (typeof allowable_tags === 'string') {
	      var match;
	      while (match = ALLOWED_TAGS_REGEX.exec(allowable_tags)) {
	        tag_set.add(match[1]);
	      }
	    } else if (!Symbol.nonNative && typeof allowable_tags[Symbol.iterator] === 'function') {
	      tag_set = new Set(allowable_tags);
	    } else if (typeof allowable_tags.forEach === 'function') {
	      // IE11 compatible
	      allowable_tags.forEach(tag_set.add, tag_set);
	    }
	    return tag_set;
	  }
	  function normalize_tag(tag_buffer) {
	    var match = NORMALIZE_TAG_REGEX.exec(tag_buffer);
	    return match ? match[1].toLowerCase() : null;
	  }
	  if ( module.exports) {
	    // Node
	    module.exports = striptags;
	  } else {
	    // Browser
	    global.striptags = striptags;
	  }
	})(commonjsGlobal);
	});

	function isBlank(html) {
	  return !!striptags(html).match(/^\s*$/);
	}

	function camelize(snakeCase) {
	  return snakeCase.replace(/_[a-z]/g, function (match) {
	    return match[1].toUpperCase();
	  });
	}
	camelize.keys = function (object) {
	  return Object.keys(object).reduce(function (result, key) {
	    result[camelize(key)] = object[key];
	    return result;
	  }, {});
	};
	camelize.deep = function (object) {
	  if (Array.isArray(object)) {
	    return object.map(camelize.deep);
	  } else if (typeof object === 'object' && object) {
	    return Object.keys(object).reduce(function (result, key) {
	      result[camelize(key)] = camelize.deep(object[key]);
	      return result;
	    }, {});
	  } else {
	    return object;
	  }
	};
	camelize.concat = function () {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	  return args.filter(function (part) {
	    return part;
	  }).reduce(function (result, part) {
	    return result + part[0].toUpperCase() + part.slice(1);
	  });
	};

	function combine (selectors) {
	  return function () {
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    return Object.keys(selectors).reduce(function (result, key) {
	      if (typeof selectors[key] == 'function') {
	        result[key] = selectors[key].apply(selectors, args);
	      } else {
	        result[key] = selectors[key];
	      }
	      return result;
	    }, {});
	  };
	}

	function _arrayLikeToArray(arr, len) {
	  if (len == null || len > arr.length) len = arr.length;

	  for (var i = 0, arr2 = new Array(len); i < len; i++) {
	    arr2[i] = arr[i];
	  }

	  return arr2;
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
	}

	function _iterableToArray(iter) {
	  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
	}

	function _unsupportedIterableToArray(o, minLen) {
	  if (!o) return;
	  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
	  var n = Object.prototype.toString.call(o).slice(8, -1);
	  if (n === "Object" && o.constructor) n = o.constructor.name;
	  if (n === "Map" || n === "Set") return Array.from(n);
	  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
	}

	var lib = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.defaultMemoize = defaultMemoize;
	exports.createSelectorCreator = createSelectorCreator;
	exports.createStructuredSelector = createStructuredSelector;
	function _toConsumableArray(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	}
	function defaultEqualityCheck(a, b) {
	  return a === b;
	}
	function defaultMemoize(func) {
	  var equalityCheck = arguments.length <= 1 || arguments[1] === undefined ? defaultEqualityCheck : arguments[1];
	  var lastArgs = null;
	  var lastResult = null;
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    if (lastArgs === null || lastArgs.length !== args.length || !args.every(function (value, index) {
	      return equalityCheck(value, lastArgs[index]);
	    })) {
	      lastResult = func.apply(undefined, args);
	    }
	    lastArgs = args;
	    return lastResult;
	  };
	}
	function getDependencies(funcs) {
	  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
	  if (!dependencies.every(function (dep) {
	    return typeof dep === 'function';
	  })) {
	    var dependencyTypes = dependencies.map(function (dep) {
	      return typeof dep;
	    }).join(', ');
	    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));
	  }
	  return dependencies;
	}
	function createSelectorCreator(memoize) {
	  for (var _len2 = arguments.length, memoizeOptions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    memoizeOptions[_key2 - 1] = arguments[_key2];
	  }
	  return function () {
	    for (var _len3 = arguments.length, funcs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	      funcs[_key3] = arguments[_key3];
	    }
	    var recomputations = 0;
	    var resultFunc = funcs.pop();
	    var dependencies = getDependencies(funcs);
	    var memoizedResultFunc = memoize.apply(undefined, [function () {
	      recomputations++;
	      return resultFunc.apply(undefined, arguments);
	    }].concat(memoizeOptions));
	    var selector = function selector(state, props) {
	      for (var _len4 = arguments.length, args = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
	        args[_key4 - 2] = arguments[_key4];
	      }
	      var params = dependencies.map(function (dependency) {
	        return dependency.apply(undefined, [state, props].concat(args));
	      });
	      return memoizedResultFunc.apply(undefined, _toConsumableArray(params));
	    };
	    selector.resultFunc = resultFunc;
	    selector.recomputations = function () {
	      return recomputations;
	    };
	    selector.resetRecomputations = function () {
	      return recomputations = 0;
	    };
	    return selector;
	  };
	}
	var createSelector = exports.createSelector = createSelectorCreator(defaultMemoize);
	function createStructuredSelector(selectors) {
	  var selectorCreator = arguments.length <= 1 || arguments[1] === undefined ? createSelector : arguments[1];
	  if (typeof selectors !== 'object') {
	    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));
	  }
	  var objectKeys = Object.keys(selectors);
	  return selectorCreator(objectKeys.map(function (key) {
	    return selectors[key];
	  }), function () {
	    for (var _len5 = arguments.length, values = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
	      values[_key5] = arguments[_key5];
	    }
	    return values.reduce(function (composition, value, index) {
	      composition[objectKeys[index]] = value;
	      return composition;
	    }, {});
	  });
	}
	});

	unwrapExports(lib);
	var lib_1 = lib.defaultMemoize;
	var lib_2 = lib.createSelectorCreator;
	var lib_3 = lib.createStructuredSelector;
	var lib_4 = lib.createSelector;

	var SELECTOR_FACTORY = Symbol('selectorFactory');
	var CREATE_SELECTOR = Symbol('createSelector');
	function memoizedSelector() {
	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }
	  return mark(function selectorCreator(stateOrCreateSelectorSymbol, props) {
	    var inputSelectors = args.slice(0, -1).map(unwrap);
	    var transform = args.slice(-1)[0];
	    var selector = lib_4.apply(void 0, _toConsumableArray(inputSelectors).concat([transform]));
	    if (stateOrCreateSelectorSymbol === CREATE_SELECTOR) {
	      return selector;
	    } else if (stateOrCreateSelectorSymbol) {
	      return selector(stateOrCreateSelectorSymbol, props);
	    } else {
	      throw 'Missing state argument for selector.';
	    }
	  });
	}
	function combine$1(selectors, name) {
	  return mark(function combinedSelectorCreator() {
	    return lib_3(unwrapAll(replaceScalarsWithConstantFunctions(selectors)));
	  });
	}
	function unwrapAll(selectors) {
	  return Object.keys(selectors).reduce(function (result, key) {
	    result[key] = unwrap(selectors[key]);
	    return result;
	  }, {});
	}
	function replaceScalarsWithConstantFunctions(object) {
	  return Object.keys(object).reduce(function (result, key) {
	    if (typeof object[key] == 'function') {
	      result[key] = object[key];
	    } else {
	      result[key] = function () {
	        return object[key];
	      };
	    }
	    return result;
	  }, {});
	}
	function unwrap(selector) {
	  if (typeof selector == 'function' && selector[SELECTOR_FACTORY]) {
	    return selector(CREATE_SELECTOR);
	  } else {
	    return selector;
	  }
	}
	function mark(selectorFactory) {
	  selectorFactory[SELECTOR_FACTORY] = true;
	  return selectorFactory;
	}

	function has$2(featureName) {
	  var browser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pageflow.browser;
	  return browser && browser.has(featureName);
	}

	function preloadBackgroundImage(element) {
	  var propertyValue = window.getComputedStyle(element).getPropertyValue('background-image');
	  if (propertyValue.match(/^url/)) {
	    var url = propertyValue.replace(/^url\(['"]?/, '').replace(/['"]?\)$/, '');
	    return preloadImage(url);
	  }
	}
	function preloadImage(url) {
	  return new Promise(function (resolve) {
	    var image = new Image();
	    image.onload = resolve;
	    image.onerror = resolve;
	    image.src = url;
	  });
	}

	function _callSuper$1(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }

	/**
	 * Display an element with a background image referenced by
	 * `ImageFile` id.
	 *
	 * @alias pageflow.react.components.BackgroundImage
	 * @since 0.1
	 *
	 * @prop fileId
	 *   The id of the image file to display.
	 *
	 * @prop position
	 *   Two element array of percent values specifying background position.
	 *
	 * @prop className
	 *   Additional CSS classes.
	 *
	 * @prop loaded
	 *   Used to lazy load images.
	 */
	var BackgroundImage = /*#__PURE__*/function (_React$Component) {
	  _inherits(BackgroundImage, _React$Component);
	  function BackgroundImage() {
	    _classCallCheck(this, BackgroundImage);
	    return _callSuper$1(this, BackgroundImage, arguments);
	  }
	  _createClass(BackgroundImage, [{
	    key: "render",
	    value: function render() {
	      var _this = this;
	      return /*#__PURE__*/React$1__default.createElement("div", {
	        className: this.cssClass(),
	        style: this.style(),
	        ref: function ref(element) {
	          return _this.element = element;
	        }
	      }, this.renderStructuredData());
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate(prevProps) {
	      if (this.props.loaded && !prevProps.loaded) {
	        preloadBackgroundImage(this.element);
	      }
	    }
	  }, {
	    key: "cssClass",
	    value: function cssClass() {
	      return classnames(this.props.className, this.props.loaded ? 'load_image' : null, this.imageCssClass());
	    }
	  }, {
	    key: "imageCssClass",
	    value: function imageCssClass() {
	      return [this.props.fileCollection == 'imageFiles' ? 'image' : 'video_poster', this.props.fileId || 'none'].join('_');
	    }
	  }, {
	    key: "style",
	    value: function style() {
	      return {
	        backgroundPosition: "".concat(this.positionCoordinate(0), "% ").concat(this.positionCoordinate(1), "%")
	      };
	    }
	  }, {
	    key: "positionCoordinate",
	    value: function positionCoordinate(index) {
	      var coordinate = this.props.position[index];
	      if (typeof coordinate === 'undefined') {
	        return 50;
	      }
	      return coordinate;
	    }
	  }, {
	    key: "renderStructuredData",
	    value: function renderStructuredData() {
	      if (this.props.structuredDataComponent) {
	        var StructuredDataComponent = this.props.structuredDataComponent;
	        return /*#__PURE__*/React$1__default.createElement(StructuredDataComponent, {
	          fileCollection: this.props.fileCollection,
	          fileId: this.props.fileId
	        });
	      }
	    }
	  }]);
	  return BackgroundImage;
	}(React$1__default.Component);
	BackgroundImage.defaultProps = {
	  position: [50, 50],
	  fileCollection: 'imageFiles'
	};

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Built-in value references. */
	var Symbol$2 = root.Symbol;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty$1.call(value, symToStringTag),
	    tag = value[symToStringTag];
	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}
	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString$1(value) {
	  return nativeObjectToString$1.call(value);
	}

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	  undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return symToStringTag$1 && symToStringTag$1 in Object(value) ? getRawTag(value) : objectToString$1(value);
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function (arg) {
	    return func(transform(arg));
	  };
	}

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	  objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty$2.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
	}

	function symbolObservablePonyfill(root) {
	  var result;
	  var Symbol = root.Symbol;
	  if (typeof Symbol === 'function') {
	    if (Symbol.observable) {
	      result = Symbol.observable;
	    } else {
	      result = Symbol('observable');
	      Symbol.observable = result;
	    }
	  } else {
	    result = '@@observable';
	  }
	  return result;
	}

	/* global window */
	var root$1;
	if (typeof self !== 'undefined') {
	  root$1 = self;
	} else if (typeof window !== 'undefined') {
	  root$1 = window;
	} else if (typeof global !== 'undefined') {
	  root$1 = global;
	} else if (typeof module !== 'undefined') {
	  root$1 = module;
	} else {
	  root$1 = Function('return this')();
	}
	var result = symbolObservablePonyfill(root$1);

	/**
	 * These are private action types reserved by Redux.
	 * For any unknown actions, you must return the current state.
	 * If the current state is undefined, you must return the initial state.
	 * Do not reference these action types directly in your code.
	 */
	var ActionTypes = {
	  INIT: '@@redux/INIT'

	  /**
	   * Creates a Redux store that holds the state tree.
	   * The only way to change the data in the store is to call `dispatch()` on it.
	   *
	   * There should only be a single store in your app. To specify how different
	   * parts of the state tree respond to actions, you may combine several reducers
	   * into a single reducer function by using `combineReducers`.
	   *
	   * @param {Function} reducer A function that returns the next state tree, given
	   * the current state tree and the action to handle.
	   *
	   * @param {any} [preloadedState] The initial state. You may optionally specify it
	   * to hydrate the state from the server in universal apps, or to restore a
	   * previously serialized user session.
	   * If you use `combineReducers` to produce the root reducer function, this must be
	   * an object with the same shape as `combineReducers` keys.
	   *
	   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
	   * to enhance the store with third-party capabilities such as middleware,
	   * time travel, persistence, etc. The only store enhancer that ships with Redux
	   * is `applyMiddleware()`.
	   *
	   * @returns {Store} A Redux store that lets you read the state, dispatch actions
	   * and subscribe to changes.
	   */
	};
	function createStore(reducer, preloadedState, enhancer) {
	  var _ref2;
	  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
	    enhancer = preloadedState;
	    preloadedState = undefined;
	  }
	  if (typeof enhancer !== 'undefined') {
	    if (typeof enhancer !== 'function') {
	      throw new Error('Expected the enhancer to be a function.');
	    }
	    return enhancer(createStore)(reducer, preloadedState);
	  }
	  if (typeof reducer !== 'function') {
	    throw new Error('Expected the reducer to be a function.');
	  }
	  var currentReducer = reducer;
	  var currentState = preloadedState;
	  var currentListeners = [];
	  var nextListeners = currentListeners;
	  var isDispatching = false;
	  function ensureCanMutateNextListeners() {
	    if (nextListeners === currentListeners) {
	      nextListeners = currentListeners.slice();
	    }
	  }

	  /**
	   * Reads the state tree managed by the store.
	   *
	   * @returns {any} The current state tree of your application.
	   */
	  function getState() {
	    return currentState;
	  }

	  /**
	   * Adds a change listener. It will be called any time an action is dispatched,
	   * and some part of the state tree may potentially have changed. You may then
	   * call `getState()` to read the current state tree inside the callback.
	   *
	   * You may call `dispatch()` from a change listener, with the following
	   * caveats:
	   *
	   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
	   * If you subscribe or unsubscribe while the listeners are being invoked, this
	   * will not have any effect on the `dispatch()` that is currently in progress.
	   * However, the next `dispatch()` call, whether nested or not, will use a more
	   * recent snapshot of the subscription list.
	   *
	   * 2. The listener should not expect to see all state changes, as the state
	   * might have been updated multiple times during a nested `dispatch()` before
	   * the listener is called. It is, however, guaranteed that all subscribers
	   * registered before the `dispatch()` started will be called with the latest
	   * state by the time it exits.
	   *
	   * @param {Function} listener A callback to be invoked on every dispatch.
	   * @returns {Function} A function to remove this change listener.
	   */
	  function subscribe(listener) {
	    if (typeof listener !== 'function') {
	      throw new Error('Expected listener to be a function.');
	    }
	    var isSubscribed = true;
	    ensureCanMutateNextListeners();
	    nextListeners.push(listener);
	    return function unsubscribe() {
	      if (!isSubscribed) {
	        return;
	      }
	      isSubscribed = false;
	      ensureCanMutateNextListeners();
	      var index = nextListeners.indexOf(listener);
	      nextListeners.splice(index, 1);
	    };
	  }

	  /**
	   * Dispatches an action. It is the only way to trigger a state change.
	   *
	   * The `reducer` function, used to create the store, will be called with the
	   * current state tree and the given `action`. Its return value will
	   * be considered the **next** state of the tree, and the change listeners
	   * will be notified.
	   *
	   * The base implementation only supports plain object actions. If you want to
	   * dispatch a Promise, an Observable, a thunk, or something else, you need to
	   * wrap your store creating function into the corresponding middleware. For
	   * example, see the documentation for the `redux-thunk` package. Even the
	   * middleware will eventually dispatch plain object actions using this method.
	   *
	   * @param {Object} action A plain object representing âwhat changedâ. It is
	   * a good idea to keep actions serializable so you can record and replay user
	   * sessions, or use the time travelling `redux-devtools`. An action must have
	   * a `type` property which may not be `undefined`. It is a good idea to use
	   * string constants for action types.
	   *
	   * @returns {Object} For convenience, the same action object you dispatched.
	   *
	   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
	   * return something else (for example, a Promise you can await).
	   */
	  function dispatch(action) {
	    if (!isPlainObject(action)) {
	      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
	    }
	    if (typeof action.type === 'undefined') {
	      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
	    }
	    if (isDispatching) {
	      throw new Error('Reducers may not dispatch actions.');
	    }
	    try {
	      isDispatching = true;
	      currentState = currentReducer(currentState, action);
	    } finally {
	      isDispatching = false;
	    }
	    var listeners = currentListeners = nextListeners;
	    for (var i = 0; i < listeners.length; i++) {
	      var listener = listeners[i];
	      listener();
	    }
	    return action;
	  }

	  /**
	   * Replaces the reducer currently used by the store to calculate the state.
	   *
	   * You might need this if your app implements code splitting and you want to
	   * load some of the reducers dynamically. You might also need this if you
	   * implement a hot reloading mechanism for Redux.
	   *
	   * @param {Function} nextReducer The reducer for the store to use instead.
	   * @returns {void}
	   */
	  function replaceReducer(nextReducer) {
	    if (typeof nextReducer !== 'function') {
	      throw new Error('Expected the nextReducer to be a function.');
	    }
	    currentReducer = nextReducer;
	    dispatch({
	      type: ActionTypes.INIT
	    });
	  }

	  /**
	   * Interoperability point for observable/reactive libraries.
	   * @returns {observable} A minimal observable of state changes.
	   * For more information, see the observable proposal:
	   * https://github.com/tc39/proposal-observable
	   */
	  function observable() {
	    var _ref;
	    var outerSubscribe = subscribe;
	    return _ref = {
	      /**
	       * The minimal observable subscription method.
	       * @param {Object} observer Any object that can be used as an observer.
	       * The observer object should have a `next` method.
	       * @returns {subscription} An object with an `unsubscribe` method that can
	       * be used to unsubscribe the observable from the store, and prevent further
	       * emission of values from the observable.
	       */
	      subscribe: function subscribe(observer) {
	        if (typeof observer !== 'object') {
	          throw new TypeError('Expected the observer to be an object.');
	        }
	        function observeState() {
	          if (observer.next) {
	            observer.next(getState());
	          }
	        }
	        observeState();
	        var unsubscribe = outerSubscribe(observeState);
	        return {
	          unsubscribe: unsubscribe
	        };
	      }
	    }, _ref[result] = function () {
	      return this;
	    }, _ref;
	  }

	  // When a store is created, an "INIT" action is dispatched so that every
	  // reducer returns their initial state. This effectively populates
	  // the initial state tree.
	  dispatch({
	    type: ActionTypes.INIT
	  });
	  return _ref2 = {
	    dispatch: dispatch,
	    subscribe: subscribe,
	    getState: getState,
	    replaceReducer: replaceReducer
	  }, _ref2[result] = observable, _ref2;
	}

	function getUndefinedStateErrorMessage(key, action) {
	  var actionType = action && action.type;
	  var actionName = actionType && '"' + actionType.toString() + '"' || 'an action';
	  return 'Given action ' + actionName + ', reducer "' + key + '" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';
	}
	function assertReducerShape(reducers) {
	  Object.keys(reducers).forEach(function (key) {
	    var reducer = reducers[key];
	    var initialState = reducer(undefined, {
	      type: ActionTypes.INIT
	    });
	    if (typeof initialState === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');
	    }
	    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');
	    if (typeof reducer(undefined, {
	      type: type
	    }) === 'undefined') {
	      throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ('Don\'t try to handle ' + ActionTypes.INIT + ' or other actions in "redux/*" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');
	    }
	  });
	}

	/**
	 * Turns an object whose values are different reducer functions, into a single
	 * reducer function. It will call every child reducer, and gather their results
	 * into a single state object, whose keys correspond to the keys of the passed
	 * reducer functions.
	 *
	 * @param {Object} reducers An object whose values correspond to different
	 * reducer functions that need to be combined into one. One handy way to obtain
	 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
	 * undefined for any action. Instead, they should return their initial state
	 * if the state passed to them was undefined, and the current state for any
	 * unrecognized action.
	 *
	 * @returns {Function} A reducer function that invokes every reducer inside the
	 * passed object, and builds a state object with the same shape.
	 */
	function combineReducers(reducers) {
	  var reducerKeys = Object.keys(reducers);
	  var finalReducers = {};
	  for (var i = 0; i < reducerKeys.length; i++) {
	    var key = reducerKeys[i];
	    if (typeof reducers[key] === 'function') {
	      finalReducers[key] = reducers[key];
	    }
	  }
	  var finalReducerKeys = Object.keys(finalReducers);
	  var shapeAssertionError = void 0;
	  try {
	    assertReducerShape(finalReducers);
	  } catch (e) {
	    shapeAssertionError = e;
	  }
	  return function combination() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments[1];
	    if (shapeAssertionError) {
	      throw shapeAssertionError;
	    }
	    var hasChanged = false;
	    var nextState = {};
	    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
	      var _key = finalReducerKeys[_i];
	      var reducer = finalReducers[_key];
	      var previousStateForKey = state[_key];
	      var nextStateForKey = reducer(previousStateForKey, action);
	      if (typeof nextStateForKey === 'undefined') {
	        var errorMessage = getUndefinedStateErrorMessage(_key, action);
	        throw new Error(errorMessage);
	      }
	      nextState[_key] = nextStateForKey;
	      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
	    }
	    return hasChanged ? nextState : state;
	  };
	}

	function bindActionCreator(actionCreator, dispatch) {
	  return function () {
	    return dispatch(actionCreator.apply(undefined, arguments));
	  };
	}

	/**
	 * Turns an object whose values are action creators, into an object with the
	 * same keys, but with every function wrapped into a `dispatch` call so they
	 * may be invoked directly. This is just a convenience method, as you can call
	 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
	 *
	 * For convenience, you can also pass a single function as the first argument,
	 * and get a function in return.
	 *
	 * @param {Function|Object} actionCreators An object whose values are action
	 * creator functions. One handy way to obtain it is to use ES6 `import * as`
	 * syntax. You may also pass a single function.
	 *
	 * @param {Function} dispatch The `dispatch` function available on your Redux
	 * store.
	 *
	 * @returns {Function|Object} The object mimicking the original object, but with
	 * every action creator wrapped into the `dispatch` call. If you passed a
	 * function as `actionCreators`, the return value will also be a single
	 * function.
	 */
	function bindActionCreators(actionCreators, dispatch) {
	  if (typeof actionCreators === 'function') {
	    return bindActionCreator(actionCreators, dispatch);
	  }
	  if (typeof actionCreators !== 'object' || actionCreators === null) {
	    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
	  }
	  var keys = Object.keys(actionCreators);
	  var boundActionCreators = {};
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    var actionCreator = actionCreators[key];
	    if (typeof actionCreator === 'function') {
	      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
	    }
	  }
	  return boundActionCreators;
	}

	/**
	 * Composes single-argument functions from right to left. The rightmost
	 * function can take multiple arguments as it provides the signature for
	 * the resulting composite function.
	 *
	 * @param {...Function} funcs The functions to compose.
	 * @returns {Function} A function obtained by composing the argument functions
	 * from right to left. For example, compose(f, g, h) is identical to doing
	 * (...args) => f(g(h(...args))).
	 */

	function compose() {
	  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
	    funcs[_key] = arguments[_key];
	  }
	  if (funcs.length === 0) {
	    return function (arg) {
	      return arg;
	    };
	  }
	  if (funcs.length === 1) {
	    return funcs[0];
	  }
	  return funcs.reduce(function (a, b) {
	    return function () {
	      return a(b.apply(undefined, arguments));
	    };
	  });
	}

	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	  return target;
	};

	/**
	 * Creates a store enhancer that applies middleware to the dispatch method
	 * of the Redux store. This is handy for a variety of tasks, such as expressing
	 * asynchronous actions in a concise manner, or logging every action payload.
	 *
	 * See `redux-thunk` package as an example of the Redux middleware.
	 *
	 * Because middleware is potentially asynchronous, this should be the first
	 * store enhancer in the composition chain.
	 *
	 * Note that each middleware will be given the `dispatch` and `getState` functions
	 * as named arguments.
	 *
	 * @param {...Function} middlewares The middleware chain to be applied.
	 * @returns {Function} A store enhancer applying the middleware.
	 */
	function applyMiddleware() {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	  return function (createStore) {
	    return function (reducer, preloadedState, enhancer) {
	      var store = createStore(reducer, preloadedState, enhancer);
	      var _dispatch = store.dispatch;
	      var chain = [];
	      var middlewareAPI = {
	        getState: store.getState,
	        dispatch: function dispatch(action) {
	          return _dispatch(action);
	        }
	      };
	      chain = middlewares.map(function (middleware) {
	        return middleware(middlewareAPI);
	      });
	      _dispatch = compose.apply(undefined, chain)(store.dispatch);
	      return _extends({}, store, {
	        dispatch: _dispatch
	      });
	    };
	  };
	}

	var commonPageStateReducer = combineReducers({
	  isPreloaded: isPreloaded,
	  isPrepared: isPrepared,
	  isActive: isActive,
	  isActivated: isActivated,
	  initialScrollerPosition: initialScrollerPosition
	});
	function isPreloaded() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case PAGE_DID_PRELOAD:
	      return true;
	    default:
	      return state;
	  }
	}
	function isPrepared() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case PAGE_DID_PREPARE:
	    case PAGE_WILL_ACTIVATE:
	      return true;
	    case PAGE_DID_UNPREPARE:
	      return false;
	    default:
	      return state;
	  }
	}
	function isActive() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case PAGE_WILL_ACTIVATE:
	      return true;
	    case PAGE_WILL_DEACTIVATE:
	      return false;
	    default:
	      return state;
	  }
	}
	function isActivated() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case PAGE_DID_ACTIVATE:
	      return true;
	    case PAGE_WILL_DEACTIVATE:
	      return false;
	    default:
	      return state;
	  }
	}
	function initialScrollerPosition() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case PAGE_WILL_ACTIVATE:
	      return action.payload.position || 'top';
	    case PAGE_WILL_DEACTIVATE:
	      return null;
	    default:
	      return state;
	  }
	}

	var RESET = 'COLLECTION_RESET';
	var ADD = 'COLLECTION_ADD';
	var CHANGE = 'COLLECTION_CHANGE';
	var REMOVE = 'COLLECTION_REMOVE';
	var ORDER = 'COLLECTION_ORDER';
	function reset(_ref) {
	  var collectionName = _ref.collectionName,
	    items = _ref.items;
	  return {
	    type: RESET,
	    meta: {
	      collectionName: collectionName
	    },
	    payload: {
	      collectionName: collectionName,
	      items: items
	    }
	  };
	}
	function add(_ref2) {
	  var collectionName = _ref2.collectionName,
	    attributes = _ref2.attributes,
	    order = _ref2.order;
	  return {
	    type: ADD,
	    meta: {
	      collectionName: collectionName
	    },
	    payload: {
	      attributes: attributes,
	      order: order
	    }
	  };
	}
	function change(_ref3) {
	  var collectionName = _ref3.collectionName,
	    attributes = _ref3.attributes;
	  return {
	    type: CHANGE,
	    meta: {
	      collectionName: collectionName
	    },
	    payload: {
	      attributes: attributes
	    }
	  };
	}
	function remove(_ref4) {
	  var collectionName = _ref4.collectionName,
	    attributes = _ref4.attributes,
	    order = _ref4.order;
	  return {
	    type: REMOVE,
	    meta: {
	      collectionName: collectionName
	    },
	    payload: {
	      attributes: attributes,
	      order: order
	    }
	  };
	}
	function order(_ref5) {
	  var collectionName = _ref5.collectionName,
	    order = _ref5.order;
	  return {
	    type: ORDER,
	    meta: {
	      collectionName: collectionName
	    },
	    payload: {
	      order: order
	    }
	  };
	}

	function attributesItemReducer() {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case ADD:
	    case CHANGE:
	      return action.payload.attributes;
	    default:
	      return state;
	  }
	}

	function createPageStateReducer (pageStateReducers) {
	  var pageReducers = {};
	  function getPageReducer(type) {
	    pageReducers[type] = pageReducers[type] || combineReducers({
	      attributes: attributesItemReducer,
	      state: combineReducers({
	        custom: pageStateReducers[type] || function () {
	          var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	          return item;
	        },
	        common: commonPageStateReducer
	      })
	    });
	    return pageReducers[type];
	  }
	  return function () {
	    var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments.length > 1 ? arguments[1] : undefined;
	    var attributes = attributesItemReducer(page.attributes, action);
	    return getPageReducer(attributes.type)(resetCustomPageStateOnTypeChange(page, page.attributes, attributes), action);
	  };
	  function resetCustomPageStateOnTypeChange(page, attributes, newAttributes) {
	    if (attributes && attributes.type !== newAttributes.type) {
	      return _objectSpread2(_objectSpread2({}, page), {}, {
	        state: _objectSpread2(_objectSpread2({}, page.state), {}, {
	          custom: undefined
	        })
	      });
	    } else {
	      return page;
	    }
	  }
	}

	function createCollectionItemsSelector (collectionName) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    namespace = _ref.namespace;
	  return function itemsSelector(state) {
	    if (namespace) {
	      if (!state[namespace]) {
	        throw new Error("Cannot select from unknown namespace ".concat(namespace, "."));
	      }
	      state = state[namespace];
	    }
	    return state[collectionName].items || {};
	  };
	}

	function addItemScope(state, collectionName, itemId) {
	  return _objectSpread2(_objectSpread2({}, state), {}, _defineProperty({}, getItemScopeProperty(collectionName), itemId));
	}
	function getItemScopeProperty(collectionName) {
	  return "__".concat(collectionName, "_connectedId");
	}

	function createItemSelector (collectionName) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    namespace = _ref.namespace;
	  return function () {
	    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      id = _ref2.id;
	    return function (state, props) {
	      var modelId = id;
	      var namespacedState = state;
	      if (namespace) {
	        if (!state[namespace]) {
	          throw new Error("Cannot select from unknown namespace ".concat(namespace, "."));
	        }
	        namespacedState = state[namespace];
	      }
	      if (!namespacedState[collectionName]) {
	        throw new Error("Cannot select from unknown collection ".concat(collectionName, "."));
	      }
	      if (typeof id == 'function') {
	        modelId = id(state, props);
	      }
	      modelId = modelId || state[getItemScopeProperty(collectionName)];
	      if (!modelId) {
	        return null;
	      }
	      return namespacedState[collectionName].items[modelId];
	    };
	  };
	}

	function createFirstItemSelector(collectionName) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    namespace = _ref.namespace;
	  return function (state) {
	    if (namespace) {
	      if (!state[namespace]) {
	        throw new Error("Cannot select from unknown namespace ".concat(namespace, "."));
	      }
	      state = state[namespace];
	    }
	    var collection = state[collectionName];
	    return collection.items[collection.order[0]];
	  };
	}

	function createCollectionReducer (collectionName) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$idAttribute = _ref.idAttribute,
	    idAttribute = _ref$idAttribute === void 0 ? 'id' : _ref$idAttribute,
	    _ref$itemReducer = _ref.itemReducer,
	    itemReducer = _ref$itemReducer === void 0 ? attributesItemReducer : _ref$itemReducer;
	  var initialState = {
	    order: [],
	    items: {}
	  };
	  return function () {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	    var action = arguments.length > 1 ? arguments[1] : undefined;
	    var clone, id;
	    if (!action.meta || action.meta.collectionName != collectionName) {
	      return state;
	    }
	    switch (action.type) {
	      case RESET:
	        return {
	          order: action.payload.items.map(function (item) {
	            return item[idAttribute];
	          }),
	          items: action.payload.items.reduce(function (result, item) {
	            result[item[idAttribute]] = itemReducer(undefined, add({
	              collectioName: action.payload.collectioName,
	              attributes: item
	            }));
	            return result;
	          }, {})
	        };
	      case ADD:
	        return {
	          order: action.payload.order,
	          items: _objectSpread2(_objectSpread2({}, state.items), {}, _defineProperty({}, action.payload.attributes[idAttribute], itemReducer(undefined, action)))
	        };
	      case CHANGE:
	        id = action.payload.attributes[idAttribute];
	        return {
	          order: state.order,
	          items: _objectSpread2(_objectSpread2({}, state.items), {}, _defineProperty({}, id, itemReducer(state.items[id], action)))
	        };
	      case REMOVE:
	        id = action.payload.attributes[idAttribute];
	        clone = _objectSpread2({}, state.items);
	        delete clone[id];
	        return {
	          order: action.payload.order,
	          items: clone
	        };
	      case ORDER:
	        return {
	          items: state.items,
	          order: action.payload.order
	        };
	      default:
	        if (action.meta.itemId) {
	          var item = state.items[action.meta.itemId];
	          var reducedItem = itemReducer(item, action);
	          if (reducedItem !== item) {
	            return {
	              order: state.order,
	              items: _objectSpread2(_objectSpread2({}, state.items), {}, _defineProperty({}, action.meta.itemId, reducedItem))
	            };
	          }
	        }
	        return state;
	    }
	  };
	}

	function ensureItemActionId(action, collectionName, itemId) {
	  if (action.meta && action.meta.collectionName == collectionName && !action.meta.itemId) {
	    action.meta = _objectSpread2(_objectSpread2({}, action.meta), {}, {
	      itemId: itemId
	    });
	  }
	}
	function isItemAction(action, collectionName) {
	  return action.meta && action.meta.collectionName == collectionName;
	}
	function getItemIdFromItemAction(action) {
	  return action.meta && action.meta.itemId;
	}

	var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};
	var sym = function sym(id) {
	  return '@@redux-saga/' + id;
	};
	var TASK = sym('TASK');
	var HELPER = sym('HELPER');
	var ident = function ident(v) {
	  return v;
	};
	function check$1(value, predicate, error) {
	  if (!predicate(value)) {
	    log$9('error', 'uncaught at check', error);
	    throw new Error(error);
	  }
	}
	var is = {
	  undef: function undef(v) {
	    return v === null || v === undefined;
	  },
	  notUndef: function notUndef(v) {
	    return v !== null && v !== undefined;
	  },
	  func: function func(f) {
	    return typeof f === 'function';
	  },
	  number: function number(n) {
	    return typeof n === 'number';
	  },
	  array: Array.isArray,
	  promise: function promise(p) {
	    return p && is.func(p.then);
	  },
	  iterator: function iterator(it) {
	    return it && is.func(it.next) && is.func(it["throw"]);
	  },
	  task: function task(t) {
	    return t && t[TASK];
	  },
	  observable: function observable(ob) {
	    return ob && is.func(ob.subscribe);
	  },
	  buffer: function buffer(buf) {
	    return buf && is.func(buf.isEmpty) && is.func(buf.take) && is.func(buf.put);
	  },
	  pattern: function pattern(pat) {
	    return pat && (typeof pat === 'string' || (typeof pat === 'undefined' ? 'undefined' : _typeof$1(pat)) === 'symbol' || is.func(pat) || is.array(pat));
	  },
	  channel: function channel(ch) {
	    return ch && is.func(ch.take) && is.func(ch.close);
	  },
	  helper: function helper(it) {
	    return it && it[HELPER];
	  }
	};

	/**
	  Print error in a useful way whether in a browser environment
	  (with expandable error stack traces), or in a node.js environment
	  (text-only log output)
	 **/
	function log$9(level, message, error) {
	  /*eslint-disable no-console*/
	  if (typeof window === 'undefined') {
	    console.log('redux-saga ' + level + ': ' + message + '\n' + (error && error.stack || error));
	  } else {
	    console[level](message, error);
	  }
	}

	var _slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	    return _arr;
	  }
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();
	function _defineProperty$1(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}
	var IO = sym('IO');
	var TAKE = 'TAKE';
	var PUT = 'PUT';
	var RACE = 'RACE';
	var CALL = 'CALL';
	var CPS = 'CPS';
	var FORK = 'FORK';
	var CANCEL = 'CANCEL';
	var SELECT = 'SELECT';
	var effect = function effect(type, payload) {
	  var _ref;
	  return _ref = {}, _defineProperty$1(_ref, IO, true), _defineProperty$1(_ref, type, payload), _ref;
	};
	function take() {
	  var patternOrChannel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '*';
	  if (arguments.length) {
	    check$1(arguments[0], is.notUndef, 'take(patternOrChannel): patternOrChannel is undefined');
	  }
	  if (is.pattern(patternOrChannel)) {
	    return effect(TAKE, {
	      pattern: patternOrChannel
	    });
	  }
	  if (is.channel(patternOrChannel)) {
	    return effect(TAKE, {
	      channel: patternOrChannel
	    });
	  }
	  throw new Error('take(patternOrChannel): argument ' + String(patternOrChannel) + ' is not valid channel or a valid pattern');
	}
	function put(channel, action) {
	  if (arguments.length > 1) {
	    check$1(channel, is.notUndef, 'put(channel, action): argument channel is undefined');
	    check$1(channel, is.channel, 'put(channel, action): argument ' + channel + ' is not a valid channel');
	    check$1(action, is.notUndef, 'put(channel, action): argument action is undefined');
	  } else {
	    check$1(channel, is.notUndef, 'put(action): argument action is undefined');
	    action = channel;
	    channel = null;
	  }
	  return effect(PUT, {
	    channel: channel,
	    action: action
	  });
	}
	put.sync = function () {
	  var eff = put.apply(undefined, arguments);
	  eff[PUT].sync = true;
	  return eff;
	};
	function race(effects) {
	  return effect(RACE, effects);
	}
	function getFnCallDesc(meth, fn, args) {
	  check$1(fn, is.notUndef, meth + ': argument fn is undefined');
	  var context = null;
	  if (is.array(fn)) {
	    var _fn = fn;
	    var _fn2 = _slicedToArray(_fn, 2);
	    context = _fn2[0];
	    fn = _fn2[1];
	  } else if (fn.fn) {
	    var _fn3 = fn;
	    context = _fn3.context;
	    fn = _fn3.fn;
	  }
	  check$1(fn, is.func, meth + ': argument ' + fn + ' is not a function');
	  return {
	    context: context,
	    fn: fn,
	    args: args
	  };
	}
	function call(fn) {
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }
	  return effect(CALL, getFnCallDesc('call', fn, args));
	}
	function cps(fn) {
	  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    args[_key2 - 1] = arguments[_key2];
	  }
	  return effect(CPS, getFnCallDesc('cps', fn, args));
	}
	function fork(fn) {
	  for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	    args[_key3 - 1] = arguments[_key3];
	  }
	  return effect(FORK, getFnCallDesc('fork', fn, args));
	}
	var isForkedTask = function isForkedTask(task) {
	  return task[TASK];
	};
	function cancel(task) {
	  check$1(task, is.notUndef, 'cancel(task): argument task is undefined');
	  if (!isForkedTask(task)) {
	    throw new Error('cancel(task): argument ' + task + ' is not a valid Task object \n(HINT: if you are getting this errors in tests, consider using createMockTask from redux-saga/utils)');
	  }
	  return effect(CANCEL, task);
	}
	function select(selector) {
	  for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
	    args[_key5 - 1] = arguments[_key5];
	  }
	  if (arguments.length === 0) {
	    selector = ident;
	  } else {
	    check$1(selector, is.notUndef, 'select(selector,[...]): argument selector is undefined');
	    check$1(selector, is.func, 'select(selector,[...]): argument ' + selector + ' is not a function');
	  }
	  return effect(SELECT, {
	    selector: selector,
	    args: args
	  });
	}

	var utils = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	  return target;
	};
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};
	exports.check = check;
	exports.remove = remove;
	exports.deferred = deferred;
	exports.arrayOfDeffered = arrayOfDeffered;
	exports.delay = delay;
	exports.createMockTask = createMockTask;
	exports.autoInc = autoInc;
	exports.makeIterator = makeIterator;
	exports.log = log;
	exports.wrapSagaDispatch = wrapSagaDispatch;
	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}
	var sym = exports.sym = function sym(id) {
	  return '@@redux-saga/' + id;
	};
	var TASK = exports.TASK = sym('TASK');
	var HELPER = exports.HELPER = sym('HELPER');
	var MATCH = exports.MATCH = sym('MATCH');
	var CANCEL = exports.CANCEL = sym('cancelPromise');
	var SAGA_ACTION = exports.SAGA_ACTION = sym('SAGA_ACTION');
	var konst = exports.konst = function konst(v) {
	  return function () {
	    return v;
	  };
	};
	var kTrue = exports.kTrue = konst(true);
	var kFalse = exports.kFalse = konst(false);
	var noop = exports.noop = function noop() {};
	var ident = exports.ident = function ident(v) {
	  return v;
	};
	function check(value, predicate, error) {
	  if (!predicate(value)) {
	    log('error', 'uncaught at check', error);
	    throw new Error(error);
	  }
	}
	var is = exports.is = {
	  undef: function undef(v) {
	    return v === null || v === undefined;
	  },
	  notUndef: function notUndef(v) {
	    return v !== null && v !== undefined;
	  },
	  func: function func(f) {
	    return typeof f === 'function';
	  },
	  number: function number(n) {
	    return typeof n === 'number';
	  },
	  array: Array.isArray,
	  promise: function promise(p) {
	    return p && is.func(p.then);
	  },
	  iterator: function iterator(it) {
	    return it && is.func(it.next) && is.func(it["throw"]);
	  },
	  task: function task(t) {
	    return t && t[TASK];
	  },
	  observable: function observable(ob) {
	    return ob && is.func(ob.subscribe);
	  },
	  buffer: function buffer(buf) {
	    return buf && is.func(buf.isEmpty) && is.func(buf.take) && is.func(buf.put);
	  },
	  pattern: function pattern(pat) {
	    return pat && (typeof pat === 'string' || (typeof pat === 'undefined' ? 'undefined' : _typeof(pat)) === 'symbol' || is.func(pat) || is.array(pat));
	  },
	  channel: function channel(ch) {
	    return ch && is.func(ch.take) && is.func(ch.close);
	  },
	  helper: function helper(it) {
	    return it && it[HELPER];
	  }
	};
	function remove(array, item) {
	  var index = array.indexOf(item);
	  if (index >= 0) {
	    array.splice(index, 1);
	  }
	}
	function deferred() {
	  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var def = _extends({}, props);
	  var promise = new Promise(function (resolve, reject) {
	    def.resolve = resolve;
	    def.reject = reject;
	  });
	  def.promise = promise;
	  return def;
	}
	function arrayOfDeffered(length) {
	  var arr = [];
	  for (var i = 0; i < length; i++) {
	    arr.push(deferred());
	  }
	  return arr;
	}
	function delay(ms) {
	  var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	  var timeoutId = void 0;
	  var promise = new Promise(function (resolve) {
	    timeoutId = setTimeout(function () {
	      return resolve(val);
	    }, ms);
	  });
	  promise[CANCEL] = function () {
	    return clearTimeout(timeoutId);
	  };
	  return promise;
	}
	function createMockTask() {
	  var _ref;
	  var running = true;
	  var _result = void 0,
	    _error = void 0;
	  return _ref = {}, _defineProperty(_ref, TASK, true), _defineProperty(_ref, 'isRunning', function isRunning() {
	    return running;
	  }), _defineProperty(_ref, 'result', function result() {
	    return _result;
	  }), _defineProperty(_ref, 'error', function error() {
	    return _error;
	  }), _defineProperty(_ref, 'setRunning', function setRunning(b) {
	    return running = b;
	  }), _defineProperty(_ref, 'setResult', function setResult(r) {
	    return _result = r;
	  }), _defineProperty(_ref, 'setError', function setError(e) {
	    return _error = e;
	  }), _ref;
	}
	function autoInc() {
	  var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	  return function () {
	    return ++seed;
	  };
	}
	var uid = exports.uid = autoInc();
	var kThrow = function kThrow(err) {
	  throw err;
	};
	var kReturn = function kReturn(value) {
	  return {
	    value: value,
	    done: true
	  };
	};
	function makeIterator(next) {
	  var thro = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : kThrow;
	  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
	  var isHelper = arguments[3];
	  var iterator = {
	    name: name,
	    next: next,
	    "throw": thro,
	    "return": kReturn
	  };
	  if (isHelper) {
	    iterator[HELPER] = true;
	  }
	  if (typeof Symbol !== 'undefined') {
	    iterator[Symbol.iterator] = function () {
	      return iterator;
	    };
	  }
	  return iterator;
	}

	/**
	  Print error in a useful way whether in a browser environment
	  (with expandable error stack traces), or in a node.js environment
	  (text-only log output)
	 **/
	function log(level, message, error) {
	  /*eslint-disable no-console*/
	  if (typeof window === 'undefined') {
	    console.log('redux-saga ' + level + ': ' + message + '\n' + (error && error.stack || error));
	  } else {
	    console[level](message, error);
	  }
	}
	var internalErr = exports.internalErr = function internalErr(err) {
	  return new Error('\n  redux-saga: Error checking hooks detected an inconsistent state. This is likely a bug\n  in redux-saga code and not yours. Thanks for reporting this in the project\'s github repo.\n  Error: ' + err + '\n');
	};
	function wrapSagaDispatch(dispatch) {
	  return function sagaDispatch(action) {
	    var wrappedAction = Object.defineProperty(action, SAGA_ACTION, {
	      value: true
	    });
	    return dispatch(wrappedAction);
	  };
	}
	});

	unwrapExports(utils);
	var utils_1 = utils.check;
	var utils_2 = utils.remove;
	var utils_3 = utils.deferred;
	var utils_4 = utils.arrayOfDeffered;
	var utils_5 = utils.delay;
	var utils_6 = utils.createMockTask;
	var utils_7 = utils.autoInc;
	var utils_8 = utils.makeIterator;
	var utils_9 = utils.log;
	var utils_10 = utils.wrapSagaDispatch;
	var utils_11 = utils.sym;
	var utils_12 = utils.TASK;
	var utils_13 = utils.HELPER;
	var utils_14 = utils.MATCH;
	var utils_15 = utils.CANCEL;
	var utils_16 = utils.SAGA_ACTION;
	var utils_17 = utils.konst;
	var utils_18 = utils.kTrue;
	var utils_19 = utils.kFalse;
	var utils_20 = utils.noop;
	var utils_21 = utils.ident;
	var utils_22 = utils.is;
	var utils_23 = utils.uid;
	var utils_24 = utils.internalErr;

	var scheduler = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.asap = asap;
	exports.suspend = suspend;
	exports.flush = flush;
	var queue = [];
	/**
	  Variable to hold a counting semaphore
	  - Incrementing adds a lock and puts the scheduler in a `suspended` state (if it's not
	    already suspended)
	  - Decrementing releases a lock. Zero locks puts the scheduler in a `released` state. This
	    triggers flushing the queued tasks.
	**/
	var semaphore = 0;

	/**
	  Executes a task 'atomically'. Tasks scheduled during this execution will be queued
	  and flushed after this task has finished (assuming the scheduler endup in a released
	  state).
	**/
	function exec(task) {
	  try {
	    suspend();
	    task();
	  } finally {
	    flush();
	  }
	}

	/**
	  Executes or queues a task depending on the state of the scheduler (`suspended` or `released`)
	**/
	function asap(task) {
	  if (!semaphore) {
	    exec(task);
	  } else {
	    queue.push(task);
	  }
	}

	/**
	  Puts the scheduler in a `suspended` state. Scheduled tasks will be queued until the
	  scheduler is released.
	**/
	function suspend() {
	  semaphore++;
	}

	/**
	  Releases the current lock. Executes all queued tasks if the scheduler is in the released state.
	**/
	function flush() {
	  semaphore--;
	  if (!semaphore && queue.length) {
	    exec(queue.shift());
	  }
	}
	});

	unwrapExports(scheduler);
	var scheduler_1 = scheduler.asap;
	var scheduler_2 = scheduler.suspend;
	var scheduler_3 = scheduler.flush;

	var io = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.asEffect = undefined;
	var _slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	    return _arr;
	  }
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();
	exports.take = take;
	exports.takem = takem;
	exports.put = put;
	exports.race = race;
	exports.call = call;
	exports.apply = apply;
	exports.cps = cps;
	exports.fork = fork;
	exports.spawn = spawn;
	exports.join = join;
	exports.cancel = cancel;
	exports.select = select;
	exports.actionChannel = actionChannel;
	exports.cancelled = cancelled;
	exports.flush = flush;

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}
	var IO = (0, utils.sym)('IO');
	var TAKE = 'TAKE';
	var PUT = 'PUT';
	var RACE = 'RACE';
	var CALL = 'CALL';
	var CPS = 'CPS';
	var FORK = 'FORK';
	var JOIN = 'JOIN';
	var CANCEL = 'CANCEL';
	var SELECT = 'SELECT';
	var ACTION_CHANNEL = 'ACTION_CHANNEL';
	var CANCELLED = 'CANCELLED';
	var FLUSH = 'FLUSH';
	var effect = function effect(type, payload) {
	  var _ref;
	  return _ref = {}, _defineProperty(_ref, IO, true), _defineProperty(_ref, type, payload), _ref;
	};
	function take() {
	  var patternOrChannel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '*';
	  if (arguments.length) {
	    (0, utils.check)(arguments[0], utils.is.notUndef, 'take(patternOrChannel): patternOrChannel is undefined');
	  }
	  if (utils.is.pattern(patternOrChannel)) {
	    return effect(TAKE, {
	      pattern: patternOrChannel
	    });
	  }
	  if (utils.is.channel(patternOrChannel)) {
	    return effect(TAKE, {
	      channel: patternOrChannel
	    });
	  }
	  throw new Error('take(patternOrChannel): argument ' + String(patternOrChannel) + ' is not valid channel or a valid pattern');
	}
	function takem() {
	  var eff = take.apply(undefined, arguments);
	  eff[TAKE].maybe = true;
	  return eff;
	}
	function put(channel, action) {
	  if (arguments.length > 1) {
	    (0, utils.check)(channel, utils.is.notUndef, 'put(channel, action): argument channel is undefined');
	    (0, utils.check)(channel, utils.is.channel, 'put(channel, action): argument ' + channel + ' is not a valid channel');
	    (0, utils.check)(action, utils.is.notUndef, 'put(channel, action): argument action is undefined');
	  } else {
	    (0, utils.check)(channel, utils.is.notUndef, 'put(action): argument action is undefined');
	    action = channel;
	    channel = null;
	  }
	  return effect(PUT, {
	    channel: channel,
	    action: action
	  });
	}
	put.sync = function () {
	  var eff = put.apply(undefined, arguments);
	  eff[PUT].sync = true;
	  return eff;
	};
	function race(effects) {
	  return effect(RACE, effects);
	}
	function getFnCallDesc(meth, fn, args) {
	  (0, utils.check)(fn, utils.is.notUndef, meth + ': argument fn is undefined');
	  var context = null;
	  if (utils.is.array(fn)) {
	    var _fn = fn;
	    var _fn2 = _slicedToArray(_fn, 2);
	    context = _fn2[0];
	    fn = _fn2[1];
	  } else if (fn.fn) {
	    var _fn3 = fn;
	    context = _fn3.context;
	    fn = _fn3.fn;
	  }
	  (0, utils.check)(fn, utils.is.func, meth + ': argument ' + fn + ' is not a function');
	  return {
	    context: context,
	    fn: fn,
	    args: args
	  };
	}
	function call(fn) {
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }
	  return effect(CALL, getFnCallDesc('call', fn, args));
	}
	function apply(context, fn) {
	  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	  return effect(CALL, getFnCallDesc('apply', {
	    context: context,
	    fn: fn
	  }, args));
	}
	function cps(fn) {
	  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	    args[_key2 - 1] = arguments[_key2];
	  }
	  return effect(CPS, getFnCallDesc('cps', fn, args));
	}
	function fork(fn) {
	  for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	    args[_key3 - 1] = arguments[_key3];
	  }
	  return effect(FORK, getFnCallDesc('fork', fn, args));
	}
	function spawn(fn) {
	  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	    args[_key4 - 1] = arguments[_key4];
	  }
	  var eff = fork.apply(undefined, [fn].concat(args));
	  eff[FORK].detached = true;
	  return eff;
	}
	var isForkedTask = function isForkedTask(task) {
	  return task[utils.TASK];
	};
	function join(task) {
	  (0, utils.check)(task, utils.is.notUndef, 'join(task): argument task is undefined');
	  if (!isForkedTask(task)) {
	    throw new Error('join(task): argument ' + task + ' is not a valid Task object \n(HINT: if you are getting this errors in tests, consider using createMockTask from redux-saga/utils)');
	  }
	  return effect(JOIN, task);
	}
	function cancel(task) {
	  (0, utils.check)(task, utils.is.notUndef, 'cancel(task): argument task is undefined');
	  if (!isForkedTask(task)) {
	    throw new Error('cancel(task): argument ' + task + ' is not a valid Task object \n(HINT: if you are getting this errors in tests, consider using createMockTask from redux-saga/utils)');
	  }
	  return effect(CANCEL, task);
	}
	function select(selector) {
	  for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
	    args[_key5 - 1] = arguments[_key5];
	  }
	  if (arguments.length === 0) {
	    selector = utils.ident;
	  } else {
	    (0, utils.check)(selector, utils.is.notUndef, 'select(selector,[...]): argument selector is undefined');
	    (0, utils.check)(selector, utils.is.func, 'select(selector,[...]): argument ' + selector + ' is not a function');
	  }
	  return effect(SELECT, {
	    selector: selector,
	    args: args
	  });
	}

	/**
	  channel(pattern, [buffer])    => creates an event channel for store actions
	**/
	function actionChannel(pattern, buffer) {
	  (0, utils.check)(pattern, utils.is.notUndef, 'actionChannel(pattern,...): argument pattern is undefined');
	  if (arguments.length > 1) {
	    (0, utils.check)(buffer, utils.is.notUndef, 'actionChannel(pattern, buffer): argument buffer is undefined');
	    (0, utils.check)(buffer, utils.is.notUndef, 'actionChannel(pattern, buffer): argument ' + buffer + ' is not a valid buffer');
	  }
	  return effect(ACTION_CHANNEL, {
	    pattern: pattern,
	    buffer: buffer
	  });
	}
	function cancelled() {
	  return effect(CANCELLED, {});
	}
	function flush(channel) {
	  (0, utils.check)(channel, utils.is.channel, 'flush(channel): argument ' + channel + ' is not valid channel');
	  return effect(FLUSH, channel);
	}
	var asEffect = exports.asEffect = {
	  take: function take(effect) {
	    return effect && effect[IO] && effect[TAKE];
	  },
	  put: function put(effect) {
	    return effect && effect[IO] && effect[PUT];
	  },
	  race: function race(effect) {
	    return effect && effect[IO] && effect[RACE];
	  },
	  call: function call(effect) {
	    return effect && effect[IO] && effect[CALL];
	  },
	  cps: function cps(effect) {
	    return effect && effect[IO] && effect[CPS];
	  },
	  fork: function fork(effect) {
	    return effect && effect[IO] && effect[FORK];
	  },
	  join: function join(effect) {
	    return effect && effect[IO] && effect[JOIN];
	  },
	  cancel: function cancel(effect) {
	    return effect && effect[IO] && effect[CANCEL];
	  },
	  select: function select(effect) {
	    return effect && effect[IO] && effect[SELECT];
	  },
	  actionChannel: function actionChannel(effect) {
	    return effect && effect[IO] && effect[ACTION_CHANNEL];
	  },
	  cancelled: function cancelled(effect) {
	    return effect && effect[IO] && effect[CANCELLED];
	  },
	  flush: function flush(effect) {
	    return effect && effect[IO] && effect[FLUSH];
	  }
	};
	});

	unwrapExports(io);
	var io_1 = io.asEffect;
	var io_2 = io.take;
	var io_3 = io.takem;
	var io_4 = io.put;
	var io_5 = io.race;
	var io_6 = io.call;
	var io_7 = io.apply;
	var io_8 = io.cps;
	var io_9 = io.fork;
	var io_10 = io.spawn;
	var io_11 = io.join;
	var io_12 = io.cancel;
	var io_13 = io.select;
	var io_14 = io.actionChannel;
	var io_15 = io.cancelled;
	var io_16 = io.flush;

	var buffers_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.buffers = exports.BUFFER_OVERFLOW = undefined;

	var BUFFER_OVERFLOW = exports.BUFFER_OVERFLOW = 'Channel\'s Buffer overflow!';
	var ON_OVERFLOW_THROW = 1;
	var ON_OVERFLOW_DROP = 2;
	var ON_OVERFLOW_SLIDE = 3;
	var ON_OVERFLOW_EXPAND = 4;
	var zeroBuffer = {
	  isEmpty: utils.kTrue,
	  put: utils.noop,
	  take: utils.noop
	};
	function ringBuffer() {
	  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
	  var overflowAction = arguments[1];
	  var arr = new Array(limit);
	  var length = 0;
	  var pushIndex = 0;
	  var popIndex = 0;
	  var push = function push(it) {
	    arr[pushIndex] = it;
	    pushIndex = (pushIndex + 1) % limit;
	    length++;
	  };
	  var take = function take() {
	    if (length != 0) {
	      var it = arr[popIndex];
	      arr[popIndex] = null;
	      length--;
	      popIndex = (popIndex + 1) % limit;
	      return it;
	    }
	  };
	  var flush = function flush() {
	    var items = [];
	    while (length) {
	      items.push(take());
	    }
	    return items;
	  };
	  return {
	    isEmpty: function isEmpty() {
	      return length == 0;
	    },
	    put: function put(it) {
	      if (length < limit) {
	        push(it);
	      } else {
	        var doubledLimit = void 0;
	        switch (overflowAction) {
	          case ON_OVERFLOW_THROW:
	            throw new Error(BUFFER_OVERFLOW);
	          case ON_OVERFLOW_SLIDE:
	            arr[pushIndex] = it;
	            pushIndex = (pushIndex + 1) % limit;
	            popIndex = pushIndex;
	            break;
	          case ON_OVERFLOW_EXPAND:
	            doubledLimit = 2 * limit;
	            arr = flush();
	            length = arr.length;
	            pushIndex = arr.length;
	            popIndex = 0;
	            arr.length = doubledLimit;
	            limit = doubledLimit;
	            push(it);
	            break;
	          // DROP
	        }
	      }
	    },
	    take: take,
	    flush: flush
	  };
	}
	var buffers = exports.buffers = {
	  none: function none() {
	    return zeroBuffer;
	  },
	  fixed: function fixed(limit) {
	    return ringBuffer(limit, ON_OVERFLOW_THROW);
	  },
	  dropping: function dropping(limit) {
	    return ringBuffer(limit, ON_OVERFLOW_DROP);
	  },
	  sliding: function sliding(limit) {
	    return ringBuffer(limit, ON_OVERFLOW_SLIDE);
	  },
	  expanding: function expanding(initialSize) {
	    return ringBuffer(initialSize, ON_OVERFLOW_EXPAND);
	  }
	};
	});

	unwrapExports(buffers_1);
	var buffers_2 = buffers_1.buffers;
	var buffers_3 = buffers_1.BUFFER_OVERFLOW;

	var channel_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.UNDEFINED_INPUT_ERROR = exports.INVALID_BUFFER = exports.isEnd = exports.END = undefined;
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	  return target;
	};
	exports.emitter = emitter;
	exports.channel = channel;
	exports.eventChannel = eventChannel;
	exports.stdChannel = stdChannel;


	var CHANNEL_END_TYPE = '@@redux-saga/CHANNEL_END';
	var END = exports.END = {
	  type: CHANNEL_END_TYPE
	};
	var isEnd = exports.isEnd = function isEnd(a) {
	  return a && a.type === CHANNEL_END_TYPE;
	};
	function emitter() {
	  var subscribers = [];
	  function subscribe(sub) {
	    subscribers.push(sub);
	    return function () {
	      return (0, utils.remove)(subscribers, sub);
	    };
	  }
	  function emit(item) {
	    var arr = subscribers.slice();
	    for (var i = 0, len = arr.length; i < len; i++) {
	      arr[i](item);
	    }
	  }
	  return {
	    subscribe: subscribe,
	    emit: emit
	  };
	}
	var INVALID_BUFFER = exports.INVALID_BUFFER = 'invalid buffer passed to channel factory function';
	var UNDEFINED_INPUT_ERROR = exports.UNDEFINED_INPUT_ERROR = 'Saga was provided with an undefined action';
	function channel() {
	  var buffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : buffers_1.buffers.fixed();
	  var closed = false;
	  var takers = [];
	  (0, utils.check)(buffer, utils.is.buffer, INVALID_BUFFER);
	  function checkForbiddenStates() {
	    if (closed && takers.length) {
	      throw (0, utils.internalErr)('Cannot have a closed channel with pending takers');
	    }
	    if (takers.length && !buffer.isEmpty()) {
	      throw (0, utils.internalErr)('Cannot have pending takers with non empty buffer');
	    }
	  }
	  function put(input) {
	    checkForbiddenStates();
	    (0, utils.check)(input, utils.is.notUndef, UNDEFINED_INPUT_ERROR);
	    if (closed) {
	      return;
	    }
	    if (!takers.length) {
	      return buffer.put(input);
	    }
	    for (var i = 0; i < takers.length; i++) {
	      var cb = takers[i];
	      if (!cb[utils.MATCH] || cb[utils.MATCH](input)) {
	        takers.splice(i, 1);
	        return cb(input);
	      }
	    }
	  }
	  function take(cb) {
	    checkForbiddenStates();
	    (0, utils.check)(cb, utils.is.func, 'channel.take\'s callback must be a function');
	    if (closed && buffer.isEmpty()) {
	      cb(END);
	    } else if (!buffer.isEmpty()) {
	      cb(buffer.take());
	    } else {
	      takers.push(cb);
	      cb.cancel = function () {
	        return (0, utils.remove)(takers, cb);
	      };
	    }
	  }
	  function flush(cb) {
	    checkForbiddenStates(); // TODO: check if some new state should be forbidden now
	    (0, utils.check)(cb, utils.is.func, 'channel.flush\' callback must be a function');
	    if (closed && buffer.isEmpty()) {
	      cb(END);
	      return;
	    }
	    cb(buffer.flush());
	  }
	  function close() {
	    checkForbiddenStates();
	    if (!closed) {
	      closed = true;
	      if (takers.length) {
	        var arr = takers;
	        takers = [];
	        for (var i = 0, len = arr.length; i < len; i++) {
	          arr[i](END);
	        }
	      }
	    }
	  }
	  return {
	    take: take,
	    put: put,
	    flush: flush,
	    close: close,
	    get __takers__() {
	      return takers;
	    },
	    get __closed__() {
	      return closed;
	    }
	  };
	}
	function eventChannel(subscribe) {
	  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : buffers_1.buffers.none();
	  var matcher = arguments[2];

	  /**
	    should be if(typeof matcher !== undefined) instead?
	    see PR #273 for a background discussion
	  **/
	  if (arguments.length > 2) {
	    (0, utils.check)(matcher, utils.is.func, 'Invalid match function passed to eventChannel');
	  }
	  var chan = channel(buffer);
	  var unsubscribe = subscribe(function (input) {
	    if (isEnd(input)) {
	      chan.close();
	    } else if (!matcher || matcher(input)) {
	      chan.put(input);
	    }
	  });
	  if (!utils.is.func(unsubscribe)) {
	    throw new Error('in eventChannel: subscribe should return a function to unsubscribe');
	  }
	  return {
	    take: chan.take,
	    flush: chan.flush,
	    close: function close() {
	      if (!chan.__closed__) {
	        chan.close();
	        unsubscribe();
	      }
	    }
	  };
	}
	function stdChannel(subscribe) {
	  var chan = eventChannel(subscribe);
	  return _extends({}, chan, {
	    take: function take(cb, matcher) {
	      if (arguments.length > 1) {
	        (0, utils.check)(matcher, utils.is.func, 'channel.take\'s matcher argument must be a function');
	        cb[utils.MATCH] = matcher;
	      }
	      chan.take(cb);
	    }
	  });
	}
	});

	unwrapExports(channel_1);
	var channel_2 = channel_1.UNDEFINED_INPUT_ERROR;
	var channel_3 = channel_1.INVALID_BUFFER;
	var channel_4 = channel_1.isEnd;
	var channel_5 = channel_1.END;
	var channel_6 = channel_1.emitter;
	var channel_7 = channel_1.channel;
	var channel_8 = channel_1.eventChannel;
	var channel_9 = channel_1.stdChannel;

	var proc_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.TASK_CANCEL = exports.CHANNEL_END = exports.NOT_ITERATOR_ERROR = undefined;
	exports["default"] = proc;





	function _defineEnumerableProperties(obj, descs) {
	  for (var key in descs) {
	    var desc = descs[key];
	    desc.configurable = desc.enumerable = true;
	    if ("value" in desc) desc.writable = true;
	    Object.defineProperty(obj, key, desc);
	  }
	  return obj;
	}
	function _toConsumableArray(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	}
	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}
	var isDev = "production" === 'development';
	var NOT_ITERATOR_ERROR = exports.NOT_ITERATOR_ERROR = 'proc first argument (Saga function result) must be an iterator';
	var CHANNEL_END = exports.CHANNEL_END = {
	  toString: function toString() {
	    return '@@redux-saga/CHANNEL_END';
	  }
	};
	var TASK_CANCEL = exports.TASK_CANCEL = {
	  toString: function toString() {
	    return '@@redux-saga/TASK_CANCEL';
	  }
	};
	var matchers = {
	  wildcard: function wildcard() {
	    return utils.kTrue;
	  },
	  "default": function _default(pattern) {
	    return function (input) {
	      return input.type === pattern;
	    };
	  },
	  array: function array(patterns) {
	    return function (input) {
	      return patterns.some(function (p) {
	        return p === input.type;
	      });
	    };
	  },
	  predicate: function predicate(_predicate) {
	    return function (input) {
	      return _predicate(input);
	    };
	  }
	};
	function matcher(pattern) {
	  return (pattern === '*' ? matchers.wildcard : utils.is.array(pattern) ? matchers.array : utils.is.func(pattern) ? matchers.predicate : matchers["default"])(pattern);
	}

	/**
	  Used to track a parent task and its forks
	  In the new fork model, forked tasks are attached by default to their parent
	  We model this using the concept of Parent task && main Task
	  main task is the main flow of the current Generator, the parent tasks is the
	  aggregation of the main tasks + all its forked tasks.
	  Thus the whole model represents an execution tree with multiple branches (vs the
	  linear execution tree in sequential (non parallel) programming)

	  A parent tasks has the following semantics
	  - It completes iff all its forks either complete or all cancelled
	  - If it's cancelled, all forks are cancelled as well
	  - It aborts if any uncaught error bubbles up from forks
	  - If it completes, the return value is the one returned by the main task
	**/
	function forkQueue(name, mainTask, cb) {
	  var tasks = [],
	    result = void 0,
	    completed = false;
	  addTask(mainTask);
	  function abort(err) {
	    cancelAll();
	    cb(err, true);
	  }
	  function addTask(task) {
	    tasks.push(task);
	    task.cont = function (res, isErr) {
	      if (completed) {
	        return;
	      }
	      (0, utils.remove)(tasks, task);
	      task.cont = utils.noop;
	      if (isErr) {
	        abort(res);
	      } else {
	        if (task === mainTask) {
	          result = res;
	        }
	        if (!tasks.length) {
	          completed = true;
	          cb(result);
	        }
	      }
	    };
	    // task.cont.cancel = task.cancel
	  }
	  function cancelAll() {
	    if (completed) {
	      return;
	    }
	    completed = true;
	    tasks.forEach(function (t) {
	      t.cont = utils.noop;
	      t.cancel();
	    });
	    tasks = [];
	  }
	  return {
	    addTask: addTask,
	    cancelAll: cancelAll,
	    abort: abort,
	    getTasks: function getTasks() {
	      return tasks;
	    },
	    taskNames: function taskNames() {
	      return tasks.map(function (t) {
	        return t.name;
	      });
	    }
	  };
	}
	function createTaskIterator(_ref) {
	  var context = _ref.context,
	    fn = _ref.fn,
	    args = _ref.args;
	  if (utils.is.iterator(fn)) {
	    return fn;
	  }

	  // catch synchronous failures; see #152 and #441
	  var result = void 0,
	    error = void 0;
	  try {
	    result = fn.apply(context, args);
	  } catch (err) {
	    error = err;
	  }

	  // i.e. a generator function returns an iterator
	  if (utils.is.iterator(result)) {
	    return result;
	  }

	  // do not bubble up synchronous failures for detached forks
	  // instead create a failed task. See #152 and #441
	  return error ? (0, utils.makeIterator)(function () {
	    throw error;
	  }) : (0, utils.makeIterator)(function () {
	    var pc = void 0;
	    var eff = {
	      done: false,
	      value: result
	    };
	    var ret = function ret(value) {
	      return {
	        done: true,
	        value: value
	      };
	    };
	    return function (arg) {
	      if (!pc) {
	        pc = true;
	        return eff;
	      } else {
	        return ret(arg);
	      }
	    };
	  }());
	}
	function wrapHelper(helper) {
	  return {
	    fn: helper
	  };
	}
	function proc(iterator) {
	  var subscribe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
	    return utils.noop;
	  };
	  var dispatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : utils.noop;
	  var getState = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : utils.noop;
	  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
	  var parentEffectId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
	  var name = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 'anonymous';
	  var cont = arguments[7];
	  (0, utils.check)(iterator, utils.is.iterator, NOT_ITERATOR_ERROR);
	  var sagaMonitor = options.sagaMonitor,
	    logger = options.logger,
	    onError = options.onError;
	  var log = logger || utils.log;
	  var stdChannel = (0, channel_1.stdChannel)(subscribe);
	  /**
	    Tracks the current effect cancellation
	    Each time the generator progresses. calling runEffect will set a new value
	    on it. It allows propagating cancellation to child effects
	  **/
	  next.cancel = utils.noop;

	  /**
	    Creates a new task descriptor for this generator, We'll also create a main task
	    to track the main flow (besides other forked tasks)
	  **/
	  var task = newTask(parentEffectId, name, iterator, cont);
	  var mainTask = {
	    name: name,
	    cancel: cancelMain,
	    isRunning: true
	  };
	  var taskQueue = forkQueue(name, mainTask, end);

	  /**
	    cancellation of the main task. We'll simply resume the Generator with a Cancel
	  **/
	  function cancelMain() {
	    if (mainTask.isRunning && !mainTask.isCancelled) {
	      mainTask.isCancelled = true;
	      next(TASK_CANCEL);
	    }
	  }

	  /**
	    This may be called by a parent generator to trigger/propagate cancellation
	    cancel all pending tasks (including the main task), then end the current task.
	      Cancellation propagates down to the whole execution tree holded by this Parent task
	    It's also propagated to all joiners of this task and their execution tree/joiners
	      Cancellation is noop for terminated/Cancelled tasks tasks
	  **/
	  function cancel() {
	    /**
	      We need to check both Running and Cancelled status
	      Tasks can be Cancelled but still Running
	    **/
	    if (iterator._isRunning && !iterator._isCancelled) {
	      iterator._isCancelled = true;
	      taskQueue.cancelAll();
	      /**
	        Ending with a Never result will propagate the Cancellation to all joiners
	      **/
	      end(TASK_CANCEL);
	    }
	  }
	  /**
	    attaches cancellation logic to this task's continuation
	    this will permit cancellation to propagate down the call chain
	  **/
	  cont && (cont.cancel = cancel);

	  // tracks the running status
	  iterator._isRunning = true;

	  // kicks up the generator
	  next();

	  // then return the task descriptor to the caller
	  return task;

	  /**
	    This is the generator driver
	    It's a recursive async/continuation function which calls itself
	    until the generator terminates or throws
	  **/
	  function next(arg, isErr) {
	    // Preventive measure. If we end up here, then there is really something wrong
	    if (!mainTask.isRunning) {
	      throw new Error('Trying to resume an already finished generator');
	    }
	    try {
	      var result = void 0;
	      if (isErr) {
	        result = iterator["throw"](arg);
	      } else if (arg === TASK_CANCEL) {
	        /**
	          getting TASK_CANCEL autoamtically cancels the main task
	          We can get this value here
	            - By cancelling the parent task manually
	          - By joining a Cancelled task
	        **/
	        mainTask.isCancelled = true;
	        /**
	          Cancels the current effect; this will propagate the cancellation down to any called tasks
	        **/
	        next.cancel();
	        /**
	          If this Generator has a `return` method then invokes it
	          Thill will jump to the finally block
	        **/
	        result = utils.is.func(iterator["return"]) ? iterator["return"](TASK_CANCEL) : {
	          done: true,
	          value: TASK_CANCEL
	        };
	      } else if (arg === CHANNEL_END) {
	        // We get CHANNEL_END by taking from a channel that ended using `take` (and not `takem` used to trap End of channels)
	        result = utils.is.func(iterator["return"]) ? iterator["return"]() : {
	          done: true
	        };
	      } else {
	        result = iterator.next(arg);
	      }
	      if (!result.done) {
	        runEffect(result.value, parentEffectId, '', next);
	      } else {
	        /**
	          This Generator has ended, terminate the main task and notify the fork queue
	        **/
	        mainTask.isMainRunning = false;
	        mainTask.cont && mainTask.cont(result.value);
	      }
	    } catch (error) {
	      if (mainTask.isCancelled) {
	        log('error', 'uncaught at ' + name, error.message);
	      }
	      mainTask.isMainRunning = false;
	      mainTask.cont(error, true);
	    }
	  }
	  function end(result, isErr) {
	    iterator._isRunning = false;
	    stdChannel.close();
	    if (!isErr) {
	      if (result === TASK_CANCEL && isDev) {
	        log('info', name + ' has been cancelled', '');
	      }
	      iterator._result = result;
	      iterator._deferredEnd && iterator._deferredEnd.resolve(result);
	    } else {
	      if (result instanceof Error) {
	        result.sagaStack = 'at ' + name + ' \n ' + (result.sagaStack || result.stack);
	      }
	      if (!task.cont) {
	        log('error', 'uncaught', result.sagaStack || result.stack);
	        if (result instanceof Error && onError) {
	          onError(result);
	        }
	      }
	      iterator._error = result;
	      iterator._isAborted = true;
	      iterator._deferredEnd && iterator._deferredEnd.reject(result);
	    }
	    task.cont && task.cont(result, isErr);
	    task.joiners.forEach(function (j) {
	      return j.cb(result, isErr);
	    });
	    task.joiners = null;
	  }
	  function runEffect(effect, parentEffectId) {
	    var label = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
	    var cb = arguments[3];
	    var effectId = (0, utils.uid)();
	    sagaMonitor && sagaMonitor.effectTriggered({
	      effectId: effectId,
	      parentEffectId: parentEffectId,
	      label: label,
	      effect: effect
	    });

	    /**
	      completion callback and cancel callback are mutually exclusive
	      We can't cancel an already completed effect
	      And We can't complete an already cancelled effectId
	    **/
	    var effectSettled = void 0;

	    // Completion callback passed to the appropriate effect runner
	    function currCb(res, isErr) {
	      if (effectSettled) {
	        return;
	      }
	      effectSettled = true;
	      cb.cancel = utils.noop; // defensive measure
	      if (sagaMonitor) {
	        isErr ? sagaMonitor.effectRejected(effectId, res) : sagaMonitor.effectResolved(effectId, res);
	      }
	      cb(res, isErr);
	    }
	    // tracks down the current cancel
	    currCb.cancel = utils.noop;

	    // setup cancellation logic on the parent cb
	    cb.cancel = function () {
	      // prevents cancelling an already completed effect
	      if (effectSettled) {
	        return;
	      }
	      effectSettled = true;
	      /**
	        propagates cancel downward
	        catch uncaught cancellations errors; since we can no longer call the completion
	        callback, log errors raised during cancellations into the console
	      **/
	      try {
	        currCb.cancel();
	      } catch (err) {
	        log('error', 'uncaught at ' + name, err.message);
	      }
	      currCb.cancel = utils.noop; // defensive measure

	      sagaMonitor && sagaMonitor.effectCancelled(effectId);
	    };

	    /**
	      each effect runner must attach its own logic of cancellation to the provided callback
	      it allows this generator to propagate cancellation downward.
	        ATTENTION! effect runners must setup the cancel logic by setting cb.cancel = [cancelMethod]
	      And the setup must occur before calling the callback
	        This is a sort of inversion of control: called async functions are responsible
	      of completing the flow by calling the provided continuation; while caller functions
	      are responsible for aborting the current flow by calling the attached cancel function
	        Library users can attach their own cancellation logic to promises by defining a
	      promise[CANCEL] method in their returned promises
	      ATTENTION! calling cancel must have no effect on an already completed or cancelled effect
	    **/
	    var data = void 0;
	    return (
	      // Non declarative effect
	      utils.is.promise(effect) ? resolvePromise(effect, currCb) : utils.is.helper(effect) ? runForkEffect(wrapHelper(effect), effectId, currCb) : utils.is.iterator(effect) ? resolveIterator(effect, effectId, name, currCb)

	      // declarative effects
	      : utils.is.array(effect) ? runParallelEffect(effect, effectId, currCb) : utils.is.notUndef(data = io.asEffect.take(effect)) ? runTakeEffect(data, currCb) : utils.is.notUndef(data = io.asEffect.put(effect)) ? runPutEffect(data, currCb) : utils.is.notUndef(data = io.asEffect.race(effect)) ? runRaceEffect(data, effectId, currCb) : utils.is.notUndef(data = io.asEffect.call(effect)) ? runCallEffect(data, effectId, currCb) : utils.is.notUndef(data = io.asEffect.cps(effect)) ? runCPSEffect(data, currCb) : utils.is.notUndef(data = io.asEffect.fork(effect)) ? runForkEffect(data, effectId, currCb) : utils.is.notUndef(data = io.asEffect.join(effect)) ? runJoinEffect(data, currCb) : utils.is.notUndef(data = io.asEffect.cancel(effect)) ? runCancelEffect(data, currCb) : utils.is.notUndef(data = io.asEffect.select(effect)) ? runSelectEffect(data, currCb) : utils.is.notUndef(data = io.asEffect.actionChannel(effect)) ? runChannelEffect(data, currCb) : utils.is.notUndef(data = io.asEffect.flush(effect)) ? runFlushEffect(data, currCb) : utils.is.notUndef(data = io.asEffect.cancelled(effect)) ? runCancelledEffect(data, currCb) : /* anything else returned as is        */currCb(effect)
	    );
	  }
	  function resolvePromise(promise, cb) {
	    var cancelPromise = promise[utils.CANCEL];
	    if (typeof cancelPromise === 'function') {
	      cb.cancel = cancelPromise;
	    }
	    promise.then(cb, function (error) {
	      return cb(error, true);
	    });
	  }
	  function resolveIterator(iterator, effectId, name, cb) {
	    proc(iterator, subscribe, dispatch, getState, options, effectId, name, cb);
	  }
	  function runTakeEffect(_ref2, cb) {
	    var channel = _ref2.channel,
	      pattern = _ref2.pattern,
	      maybe = _ref2.maybe;
	    channel = channel || stdChannel;
	    var takeCb = function takeCb(inp) {
	      return inp instanceof Error ? cb(inp, true) : (0, channel_1.isEnd)(inp) && !maybe ? cb(CHANNEL_END) : cb(inp);
	    };
	    try {
	      channel.take(takeCb, matcher(pattern));
	    } catch (err) {
	      return cb(err, true);
	    }
	    cb.cancel = takeCb.cancel;
	  }
	  function runPutEffect(_ref3, cb) {
	    var channel = _ref3.channel,
	      action = _ref3.action,
	      sync = _ref3.sync;

	    /**
	      Schedule the put in case another saga is holding a lock.
	      The put will be executed atomically. ie nested puts will execute after
	      this put has terminated.
	    **/
	    (0, scheduler.asap)(function () {
	      var result = void 0;
	      try {
	        result = (channel ? channel.put : dispatch)(action);
	      } catch (error) {
	        // If we have a channel or `put.sync` was used then bubble up the error.
	        if (channel || sync) return cb(error, true);
	        log('error', 'uncaught at ' + name, error.stack || error.message || error);
	      }
	      if (sync && utils.is.promise(result)) {
	        resolvePromise(result, cb);
	      } else {
	        return cb(result);
	      }
	    });
	    // Put effects are non cancellables
	  }
	  function runCallEffect(_ref4, effectId, cb) {
	    var context = _ref4.context,
	      fn = _ref4.fn,
	      args = _ref4.args;
	    var result = void 0;
	    // catch synchronous failures; see #152
	    try {
	      result = fn.apply(context, args);
	    } catch (error) {
	      return cb(error, true);
	    }
	    return utils.is.promise(result) ? resolvePromise(result, cb) : utils.is.iterator(result) ? resolveIterator(result, effectId, fn.name, cb) : cb(result);
	  }
	  function runCPSEffect(_ref5, cb) {
	    var context = _ref5.context,
	      fn = _ref5.fn,
	      args = _ref5.args;

	    // CPS (ie node style functions) can define their own cancellation logic
	    // by setting cancel field on the cb

	    // catch synchronous failures; see #152
	    try {
	      (function () {
	        var cpsCb = function cpsCb(err, res) {
	          return utils.is.undef(err) ? cb(res) : cb(err, true);
	        };
	        fn.apply(context, args.concat(cpsCb));
	        if (cpsCb.cancel) {
	          cb.cancel = function () {
	            return cpsCb.cancel();
	          };
	        }
	      })();
	    } catch (error) {
	      return cb(error, true);
	    }
	  }
	  function runForkEffect(_ref6, effectId, cb) {
	    var context = _ref6.context,
	      fn = _ref6.fn,
	      args = _ref6.args,
	      detached = _ref6.detached;
	    var taskIterator = createTaskIterator({
	      context: context,
	      fn: fn,
	      args: args
	    });
	    try {
	      (0, scheduler.suspend)();
	      var _task = proc(taskIterator, subscribe, dispatch, getState, options, effectId, fn.name, detached ? null : utils.noop);
	      if (detached) {
	        cb(_task);
	      } else {
	        if (taskIterator._isRunning) {
	          taskQueue.addTask(_task);
	          cb(_task);
	        } else if (taskIterator._error) {
	          taskQueue.abort(taskIterator._error);
	        } else {
	          cb(_task);
	        }
	      }
	    } finally {
	      (0, scheduler.flush)();
	    }
	    // Fork effects are non cancellables
	  }
	  function runJoinEffect(t, cb) {
	    if (t.isRunning()) {
	      (function () {
	        var joiner = {
	          task: task,
	          cb: cb
	        };
	        cb.cancel = function () {
	          return (0, utils.remove)(t.joiners, joiner);
	        };
	        t.joiners.push(joiner);
	      })();
	    } else {
	      t.isAborted() ? cb(t.error(), true) : cb(t.result());
	    }
	  }
	  function runCancelEffect(task, cb) {
	    if (task.isRunning()) {
	      task.cancel();
	    }
	    cb();
	    // cancel effects are non cancellables
	  }
	  function runParallelEffect(effects, effectId, cb) {
	    if (!effects.length) {
	      return cb([]);
	    }
	    var completedCount = 0;
	    var completed = void 0;
	    var results = Array(effects.length);
	    function checkEffectEnd() {
	      if (completedCount === results.length) {
	        completed = true;
	        cb(results);
	      }
	    }
	    var childCbs = effects.map(function (eff, idx) {
	      var chCbAtIdx = function chCbAtIdx(res, isErr) {
	        if (completed) {
	          return;
	        }
	        if (isErr || (0, channel_1.isEnd)(res) || res === CHANNEL_END || res === TASK_CANCEL) {
	          cb.cancel();
	          cb(res, isErr);
	        } else {
	          results[idx] = res;
	          completedCount++;
	          checkEffectEnd();
	        }
	      };
	      chCbAtIdx.cancel = utils.noop;
	      return chCbAtIdx;
	    });
	    cb.cancel = function () {
	      if (!completed) {
	        completed = true;
	        childCbs.forEach(function (chCb) {
	          return chCb.cancel();
	        });
	      }
	    };
	    effects.forEach(function (eff, idx) {
	      return runEffect(eff, effectId, idx, childCbs[idx]);
	    });
	  }
	  function runRaceEffect(effects, effectId, cb) {
	    var completed = void 0;
	    var keys = Object.keys(effects);
	    var childCbs = {};
	    keys.forEach(function (key) {
	      var chCbAtKey = function chCbAtKey(res, isErr) {
	        if (completed) {
	          return;
	        }
	        if (isErr) {
	          // Race Auto cancellation
	          cb.cancel();
	          cb(res, true);
	        } else if (!(0, channel_1.isEnd)(res) && res !== CHANNEL_END && res !== TASK_CANCEL) {
	          cb.cancel();
	          completed = true;
	          cb(_defineProperty({}, key, res));
	        }
	      };
	      chCbAtKey.cancel = utils.noop;
	      childCbs[key] = chCbAtKey;
	    });
	    cb.cancel = function () {
	      // prevents unnecessary cancellation
	      if (!completed) {
	        completed = true;
	        keys.forEach(function (key) {
	          return childCbs[key].cancel();
	        });
	      }
	    };
	    keys.forEach(function (key) {
	      if (completed) {
	        return;
	      }
	      runEffect(effects[key], effectId, key, childCbs[key]);
	    });
	  }
	  function runSelectEffect(_ref7, cb) {
	    var selector = _ref7.selector,
	      args = _ref7.args;
	    try {
	      var state = selector.apply(undefined, [getState()].concat(_toConsumableArray(args)));
	      cb(state);
	    } catch (error) {
	      cb(error, true);
	    }
	  }
	  function runChannelEffect(_ref8, cb) {
	    var pattern = _ref8.pattern,
	      buffer = _ref8.buffer;
	    var match = matcher(pattern);
	    match.pattern = pattern;
	    cb((0, channel_1.eventChannel)(subscribe, buffer || buffers_1.buffers.fixed(), match));
	  }
	  function runCancelledEffect(data, cb) {
	    cb(!!mainTask.isCancelled);
	  }
	  function runFlushEffect(channel, cb) {
	    channel.flush(cb);
	  }
	  function newTask(id, name, iterator, cont) {
	    var _done, _ref9, _mutatorMap;
	    iterator._deferredEnd = null;
	    return _ref9 = {}, _defineProperty(_ref9, utils.TASK, true), _defineProperty(_ref9, 'id', id), _defineProperty(_ref9, 'name', name), _done = 'done', _mutatorMap = {}, _mutatorMap[_done] = _mutatorMap[_done] || {}, _mutatorMap[_done].get = function () {
	      if (iterator._deferredEnd) {
	        return iterator._deferredEnd.promise;
	      } else {
	        var def = (0, utils.deferred)();
	        iterator._deferredEnd = def;
	        if (!iterator._isRunning) {
	          iterator._error ? def.reject(iterator._error) : def.resolve(iterator._result);
	        }
	        return def.promise;
	      }
	    }, _defineProperty(_ref9, 'cont', cont), _defineProperty(_ref9, 'joiners', []), _defineProperty(_ref9, 'cancel', cancel), _defineProperty(_ref9, 'isRunning', function isRunning() {
	      return iterator._isRunning;
	    }), _defineProperty(_ref9, 'isCancelled', function isCancelled() {
	      return iterator._isCancelled;
	    }), _defineProperty(_ref9, 'isAborted', function isAborted() {
	      return iterator._isAborted;
	    }), _defineProperty(_ref9, 'result', function result() {
	      return iterator._result;
	    }), _defineProperty(_ref9, 'error', function error() {
	      return iterator._error;
	    }), _defineEnumerableProperties(_ref9, _mutatorMap), _ref9;
	  }
	}
	});

	unwrapExports(proc_1);
	var proc_2 = proc_1.TASK_CANCEL;
	var proc_3 = proc_1.CHANNEL_END;
	var proc_4 = proc_1.NOT_ITERATOR_ERROR;

	var runSaga_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.runSaga = runSaga;


	var _proc2 = _interopRequireDefault(proc_1);
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	}
	function runSaga(iterator, _ref) {
	  var subscribe = _ref.subscribe,
	    dispatch = _ref.dispatch,
	    getState = _ref.getState,
	    sagaMonitor = _ref.sagaMonitor,
	    logger = _ref.logger;
	  (0, utils.check)(iterator, utils.is.iterator, "runSaga must be called on an iterator");
	  var effectId = (0, utils.uid)();
	  if (sagaMonitor) {
	    dispatch = (0, utils.wrapSagaDispatch)(dispatch);
	    sagaMonitor.effectTriggered({
	      effectId: effectId,
	      root: true,
	      parentEffectId: 0,
	      effect: {
	        root: true,
	        saga: iterator,
	        args: []
	      }
	    });
	  }
	  var task = (0, _proc2["default"])(iterator, subscribe, dispatch, getState, {
	    sagaMonitor: sagaMonitor,
	    logger: logger
	  }, effectId, iterator.name);
	  if (sagaMonitor) {
	    sagaMonitor.effectResolved(effectId, task);
	  }
	  return task;
	}
	});

	unwrapExports(runSaga_1);
	var runSaga_2 = runSaga_1.runSaga;

	var sagaHelpers = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var _slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;
	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);
	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }
	    return _arr;
	  }
	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();
	exports.takeEvery = takeEvery;
	exports.takeLatest = takeLatest;
	exports.throttle = throttle;




	var done = {
	  done: true,
	  value: undefined
	};
	var qEnd = {};
	function fsmIterator(fsm, q0) {
	  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'iterator';
	  var updateState = void 0,
	    qNext = q0;
	  function next(arg, error) {
	    if (qNext === qEnd) {
	      return done;
	    }
	    if (error) {
	      qNext = qEnd;
	      throw error;
	    } else {
	      updateState && updateState(arg);
	      var _fsm$qNext = fsm[qNext](),
	        _fsm$qNext2 = _slicedToArray(_fsm$qNext, 3),
	        q = _fsm$qNext2[0],
	        output = _fsm$qNext2[1],
	        _updateState = _fsm$qNext2[2];
	      qNext = q;
	      updateState = _updateState;
	      return qNext === qEnd ? done : output;
	    }
	  }
	  return (0, utils.makeIterator)(next, function (error) {
	    return next(null, error);
	  }, name, true);
	}
	function safeName(pattern) {
	  if (Array.isArray(pattern)) {
	    return String(pattern.map(function (entry) {
	      return String(entry);
	    }));
	  } else {
	    return String(pattern);
	  }
	}
	function takeEvery(pattern, worker) {
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	  var yTake = {
	    done: false,
	    value: (0, io.take)(pattern)
	  };
	  var yFork = function yFork(ac) {
	    return {
	      done: false,
	      value: io.fork.apply(undefined, [worker].concat(args, [ac]))
	    };
	  };
	  var action = void 0,
	    setAction = function setAction(ac) {
	      return action = ac;
	    };
	  return fsmIterator({
	    q1: function q1() {
	      return ['q2', yTake, setAction];
	    },
	    q2: function q2() {
	      return action === channel_1.END ? [qEnd] : ['q1', yFork(action)];
	    }
	  }, 'q1', 'takeEvery(' + safeName(pattern) + ', ' + worker.name + ')');
	}
	function takeLatest(pattern, worker) {
	  for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	    args[_key2 - 2] = arguments[_key2];
	  }
	  var yTake = {
	    done: false,
	    value: (0, io.take)(pattern)
	  };
	  var yFork = function yFork(ac) {
	    return {
	      done: false,
	      value: io.fork.apply(undefined, [worker].concat(args, [ac]))
	    };
	  };
	  var yCancel = function yCancel(task) {
	    return {
	      done: false,
	      value: (0, io.cancel)(task)
	    };
	  };
	  var task = void 0,
	    action = void 0;
	  var setTask = function setTask(t) {
	    return task = t;
	  };
	  var setAction = function setAction(ac) {
	    return action = ac;
	  };
	  return fsmIterator({
	    q1: function q1() {
	      return ['q2', yTake, setAction];
	    },
	    q2: function q2() {
	      return action === channel_1.END ? [qEnd] : task ? ['q3', yCancel(task)] : ['q1', yFork(action), setTask];
	    },
	    q3: function q3() {
	      return ['q1', yFork(action), setTask];
	    }
	  }, 'q1', 'takeLatest(' + safeName(pattern) + ', ' + worker.name + ')');
	}
	function throttle(delayLength, pattern, worker) {
	  for (var _len3 = arguments.length, args = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
	    args[_key3 - 3] = arguments[_key3];
	  }
	  var action = void 0,
	    channel = void 0;
	  var yActionChannel = {
	    done: false,
	    value: (0, io.actionChannel)(pattern, buffers_1.buffers.sliding(1))
	  };
	  var yTake = function yTake() {
	    return {
	      done: false,
	      value: (0, io.take)(channel, pattern)
	    };
	  };
	  var yFork = function yFork(ac) {
	    return {
	      done: false,
	      value: io.fork.apply(undefined, [worker].concat(args, [ac]))
	    };
	  };
	  var yDelay = {
	    done: false,
	    value: (0, io.call)(utils.delay, delayLength)
	  };
	  var setAction = function setAction(ac) {
	    return action = ac;
	  };
	  var setChannel = function setChannel(ch) {
	    return channel = ch;
	  };
	  return fsmIterator({
	    q1: function q1() {
	      return ['q2', yActionChannel, setChannel];
	    },
	    q2: function q2() {
	      return ['q3', yTake(), setAction];
	    },
	    q3: function q3() {
	      return action === channel_1.END ? [qEnd] : ['q4', yFork(action)];
	    },
	    q4: function q4() {
	      return ['q2', yDelay];
	    }
	  }, 'q1', 'throttle(' + safeName(pattern) + ', ' + worker.name + ')');
	}
	});

	unwrapExports(sagaHelpers);
	var sagaHelpers_1 = sagaHelpers.takeEvery;
	var sagaHelpers_2 = sagaHelpers.takeLatest;
	var sagaHelpers_3 = sagaHelpers.throttle;

	var middleware = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = sagaMiddlewareFactory;


	var _proc2 = _interopRequireDefault(proc_1);


	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	}
	function _toConsumableArray(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	}
	function sagaMiddlewareFactory() {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var runSagaDynamically = void 0;
	  var sagaMonitor = options.sagaMonitor;
	  if (utils.is.func(options)) {
	    {
	      throw new Error('Saga middleware no longer accept Generator functions. Use sagaMiddleware.run instead');
	    }
	  }
	  if (options.logger && !utils.is.func(options.logger)) {
	    throw new Error('`options.logger` passed to the Saga middleware is not a function!');
	  }
	  if (options.onerror && !utils.is.func(options.onerror)) {
	    throw new Error('`options.onerror` passed to the Saga middleware is not a function!');
	  }
	  function sagaMiddleware(_ref) {
	    var getState = _ref.getState,
	      dispatch = _ref.dispatch;
	    runSagaDynamically = runSaga;
	    var sagaEmitter = (0, channel_1.emitter)();
	    var sagaDispatch = (0, utils.wrapSagaDispatch)(dispatch);
	    function runSaga(saga, args, sagaId) {
	      return (0, _proc2["default"])(saga.apply(undefined, _toConsumableArray(args)), sagaEmitter.subscribe, sagaDispatch, getState, options, sagaId, saga.name);
	    }
	    return function (next) {
	      return function (action) {
	        if (sagaMonitor) {
	          sagaMonitor.actionDispatched(action);
	        }
	        var result = next(action); // hit reducers
	        if (action[utils.SAGA_ACTION]) {
	          // Saga actions are already scheduled with asap in proc/runPutEffect
	          sagaEmitter.emit(action);
	        } else {
	          (0, scheduler.asap)(function () {
	            return sagaEmitter.emit(action);
	          });
	        }
	        return result;
	      };
	    };
	  }
	  sagaMiddleware.run = function (saga) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }
	    (0, utils.check)(runSagaDynamically, utils.is.notUndef, 'Before running a Saga, you must mount the Saga middleware on the Store using applyMiddleware');
	    (0, utils.check)(saga, utils.is.func, 'sagaMiddleware.run(saga, ...args): saga argument must be a Generator function!');
	    var effectId = (0, utils.uid)();
	    if (sagaMonitor) {
	      sagaMonitor.effectTriggered({
	        effectId: effectId,
	        root: true,
	        parentEffectId: 0,
	        effect: {
	          root: true,
	          saga: saga,
	          args: args
	        }
	      });
	    }
	    var task = runSagaDynamically(saga, args, effectId);
	    if (sagaMonitor) {
	      sagaMonitor.effectResolved(effectId, task);
	    }
	    return task;
	  };
	  return sagaMiddleware;
	}
	});

	unwrapExports(middleware);

	var effects = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	Object.defineProperty(exports, 'take', {
	  enumerable: true,
	  get: function get() {
	    return io.take;
	  }
	});
	Object.defineProperty(exports, 'takem', {
	  enumerable: true,
	  get: function get() {
	    return io.takem;
	  }
	});
	Object.defineProperty(exports, 'put', {
	  enumerable: true,
	  get: function get() {
	    return io.put;
	  }
	});
	Object.defineProperty(exports, 'race', {
	  enumerable: true,
	  get: function get() {
	    return io.race;
	  }
	});
	Object.defineProperty(exports, 'call', {
	  enumerable: true,
	  get: function get() {
	    return io.call;
	  }
	});
	Object.defineProperty(exports, 'apply', {
	  enumerable: true,
	  get: function get() {
	    return io.apply;
	  }
	});
	Object.defineProperty(exports, 'cps', {
	  enumerable: true,
	  get: function get() {
	    return io.cps;
	  }
	});
	Object.defineProperty(exports, 'fork', {
	  enumerable: true,
	  get: function get() {
	    return io.fork;
	  }
	});
	Object.defineProperty(exports, 'spawn', {
	  enumerable: true,
	  get: function get() {
	    return io.spawn;
	  }
	});
	Object.defineProperty(exports, 'join', {
	  enumerable: true,
	  get: function get() {
	    return io.join;
	  }
	});
	Object.defineProperty(exports, 'cancel', {
	  enumerable: true,
	  get: function get() {
	    return io.cancel;
	  }
	});
	Object.defineProperty(exports, 'select', {
	  enumerable: true,
	  get: function get() {
	    return io.select;
	  }
	});
	Object.defineProperty(exports, 'actionChannel', {
	  enumerable: true,
	  get: function get() {
	    return io.actionChannel;
	  }
	});
	Object.defineProperty(exports, 'cancelled', {
	  enumerable: true,
	  get: function get() {
	    return io.cancelled;
	  }
	});
	Object.defineProperty(exports, 'flush', {
	  enumerable: true,
	  get: function get() {
	    return io.flush;
	  }
	});
	});

	unwrapExports(effects);

	var utils$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	Object.defineProperty(exports, 'TASK', {
	  enumerable: true,
	  get: function get() {
	    return utils.TASK;
	  }
	});
	Object.defineProperty(exports, 'SAGA_ACTION', {
	  enumerable: true,
	  get: function get() {
	    return utils.SAGA_ACTION;
	  }
	});
	Object.defineProperty(exports, 'noop', {
	  enumerable: true,
	  get: function get() {
	    return utils.noop;
	  }
	});
	Object.defineProperty(exports, 'is', {
	  enumerable: true,
	  get: function get() {
	    return utils.is;
	  }
	});
	Object.defineProperty(exports, 'deferred', {
	  enumerable: true,
	  get: function get() {
	    return utils.deferred;
	  }
	});
	Object.defineProperty(exports, 'arrayOfDeffered', {
	  enumerable: true,
	  get: function get() {
	    return utils.arrayOfDeffered;
	  }
	});
	Object.defineProperty(exports, 'createMockTask', {
	  enumerable: true,
	  get: function get() {
	    return utils.createMockTask;
	  }
	});

	Object.defineProperty(exports, 'CHANNEL_END', {
	  enumerable: true,
	  get: function get() {
	    return io.CHANNEL_END;
	  }
	});
	Object.defineProperty(exports, 'asEffect', {
	  enumerable: true,
	  get: function get() {
	    return io.asEffect;
	  }
	});
	});

	unwrapExports(utils$1);

	var lib$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.utils = exports.effects = exports.CANCEL = exports.delay = exports.throttle = exports.takeLatest = exports.takeEvery = exports.buffers = exports.channel = exports.eventChannel = exports.END = exports.runSaga = undefined;

	Object.defineProperty(exports, 'runSaga', {
	  enumerable: true,
	  get: function get() {
	    return runSaga_1.runSaga;
	  }
	});

	Object.defineProperty(exports, 'END', {
	  enumerable: true,
	  get: function get() {
	    return channel_1.END;
	  }
	});
	Object.defineProperty(exports, 'eventChannel', {
	  enumerable: true,
	  get: function get() {
	    return channel_1.eventChannel;
	  }
	});
	Object.defineProperty(exports, 'channel', {
	  enumerable: true,
	  get: function get() {
	    return channel_1.channel;
	  }
	});

	Object.defineProperty(exports, 'buffers', {
	  enumerable: true,
	  get: function get() {
	    return buffers_1.buffers;
	  }
	});

	Object.defineProperty(exports, 'takeEvery', {
	  enumerable: true,
	  get: function get() {
	    return sagaHelpers.takeEvery;
	  }
	});
	Object.defineProperty(exports, 'takeLatest', {
	  enumerable: true,
	  get: function get() {
	    return sagaHelpers.takeLatest;
	  }
	});
	Object.defineProperty(exports, 'throttle', {
	  enumerable: true,
	  get: function get() {
	    return sagaHelpers.throttle;
	  }
	});

	Object.defineProperty(exports, 'delay', {
	  enumerable: true,
	  get: function get() {
	    return utils.delay;
	  }
	});
	Object.defineProperty(exports, 'CANCEL', {
	  enumerable: true,
	  get: function get() {
	    return utils.CANCEL;
	  }
	});

	var _middleware2 = _interopRequireDefault(middleware);

	var effects$1 = _interopRequireWildcard(effects);

	var utils$2 = _interopRequireWildcard(utils$1);
	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};
	    if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }
	    newObj["default"] = obj;
	    return newObj;
	  }
	}
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	}
	exports["default"] = _middleware2["default"];
	exports.effects = effects$1;
	exports.utils = utils$2;
	});

	var createSagaMiddleware = unwrapExports(lib$1);
	var lib_1$1 = lib$1.utils;
	var lib_2$1 = lib$1.effects;
	var lib_3$1 = lib$1.CANCEL;
	var lib_4$1 = lib$1.delay;
	var lib_5 = lib$1.throttle;
	var lib_6 = lib$1.takeLatest;
	var lib_7 = lib$1.takeEvery;
	var lib_8 = lib$1.buffers;
	var lib_9 = lib$1.channel;
	var lib_10 = lib$1.eventChannel;
	var lib_11 = lib$1.END;
	var lib_12 = lib$1.runSaga;

	function _regeneratorRuntime() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function createCollectionSaga (collectionName, _ref) {
	  var _marked = /*#__PURE__*/_regeneratorRuntime().mark(saga),
	    _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(syncItemSagas),
	    _marked3 = /*#__PURE__*/_regeneratorRuntime().mark(cancelStaleItemSagas),
	    _marked4 = /*#__PURE__*/_regeneratorRuntime().mark(forkNewItemSagas),
	    _marked5 = /*#__PURE__*/_regeneratorRuntime().mark(runItemSaga);
	  var itemSaga = _ref.itemSaga,
	    middleware = _ref.middleware;
	  var itemsSelector = createCollectionItemsSelector(collectionName);
	  return saga;
	  function saga() {
	    var runningItemSagas;
	    return _regeneratorRuntime().wrap(function saga$(_context) {
	      while (1) switch (_context.prev = _context.next) {
	        case 0:
	          runningItemSagas = {};
	          _context.next = 3;
	          return lib_7([RESET, ADD, REMOVE], syncItemSagas, runningItemSagas);
	        case 3:
	        case "end":
	          return _context.stop();
	      }
	    }, _marked);
	  }
	  function syncItemSagas(runningItemSagas) {
	    var items;
	    return _regeneratorRuntime().wrap(function syncItemSagas$(_context2) {
	      while (1) switch (_context2.prev = _context2.next) {
	        case 0:
	          _context2.next = 2;
	          return select(itemsSelector);
	        case 2:
	          items = _context2.sent;
	          return _context2.delegateYield(cancelStaleItemSagas(items, runningItemSagas), "t0", 4);
	        case 4:
	          return _context2.delegateYield(forkNewItemSagas(items, runningItemSagas), "t1", 5);
	        case 5:
	        case "end":
	          return _context2.stop();
	      }
	    }, _marked2);
	  }
	  function cancelStaleItemSagas(items, runningItemSagas) {
	    return _regeneratorRuntime().wrap(function cancelStaleItemSagas$(_context3) {
	      while (1) switch (_context3.prev = _context3.next) {
	        case 0:
	          _context3.next = 2;
	          return Object.keys(runningItemSagas).map(function (runningItemId) {
	            if (!(runningItemId in items)) {
	              return cancel(runningItemSagas[runningItemId]);
	            }
	          });
	        case 2:
	        case "end":
	          return _context3.stop();
	      }
	    }, _marked3);
	  }
	  function forkNewItemSagas(items, runningItemSagas) {
	    var tasks;
	    return _regeneratorRuntime().wrap(function forkNewItemSagas$(_context4) {
	      while (1) switch (_context4.prev = _context4.next) {
	        case 0:
	          _context4.next = 2;
	          return Object.keys(items).map(function (itemId) {
	            if (!runningItemSagas[itemId]) {
	              return fork(runItemSaga, parseInt(itemId, 10));
	            }
	          });
	        case 2:
	          tasks = _context4.sent;
	          Object.keys(items).forEach(function (key, index) {
	            if (!runningItemSagas[key]) {
	              runningItemSagas[key] = tasks[index];
	            }
	          });
	        case 4:
	        case "end":
	          return _context4.stop();
	      }
	    }, _marked4);
	  }
	  function runItemSaga(itemId) {
	    var task;
	    return _regeneratorRuntime().wrap(function runItemSaga$(_context5) {
	      while (1) switch (_context5.prev = _context5.next) {
	        case 0:
	          task = lib_12(itemSaga(), {
	            subscribe: function subscribe(callback) {
	              return middleware.subscribe(function (action) {
	                if (!isItemAction(action, collectionName) || getItemIdFromItemAction(action) == itemId) {
	                  callback(action);
	                }
	              });
	            },
	            dispatch: function dispatch(action) {
	              ensureItemActionId(action, collectionName, itemId);
	              middleware.dispatch(action);
	            },
	            getState: function getState() {
	              return addItemScope(middleware.getState(), collectionName, itemId);
	            }
	          });
	          _context5.prev = 1;
	          _context5.next = 4;
	          return call(function () {
	            return task.done;
	          });
	        case 4:
	          _context5.prev = 4;
	          task.cancel();
	          return _context5.finish(4);
	        case 7:
	        case "end":
	          return _context5.stop();
	      }
	    }, _marked5, null, [[1,, 4, 7]]);
	  }
	}
	function createMiddleware() {
	  return function middleware(_ref2) {
	    var getState = _ref2.getState,
	      dispatch = _ref2.dispatch;
	    var sagaEmitter = emitter();
	    middleware.getState = getState;
	    middleware.dispatch = dispatch;
	    middleware.subscribe = sagaEmitter.subscribe;
	    return function (next) {
	      return function (action) {
	        var result = next(action);
	        sagaEmitter.emit(action);
	        return result;
	      };
	    };
	  };
	}
	function emitter() {
	  var subscribers = [];
	  function subscribe(sub) {
	    subscribers.push(sub);
	    return function () {
	      return remove$1(subscribers, sub);
	    };
	  }
	  function emit(item) {
	    var arr = subscribers.slice();
	    for (var i = 0, len = arr.length; i < len; i++) {
	      arr[i](item);
	    }
	  }
	  return {
	    subscribe: subscribe,
	    emit: emit
	  };
	}
	function remove$1(array, item) {
	  var index = array.indexOf(item);
	  if (index >= 0) {
	    array.splice(index, 1);
	  }
	}

	function _setPrototypeOf$1(o, p) {
	  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };
	  return _setPrototypeOf$1(o, p);
	}

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  _setPrototypeOf$1(subClass, superClass);
	}

	/** @license React v16.13.1
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var b = "function" === typeof Symbol && Symbol["for"],
	  c = b ? Symbol["for"]("react.element") : 60103,
	  d = b ? Symbol["for"]("react.portal") : 60106,
	  e = b ? Symbol["for"]("react.fragment") : 60107,
	  f$8 = b ? Symbol["for"]("react.strict_mode") : 60108,
	  g = b ? Symbol["for"]("react.profiler") : 60114,
	  h = b ? Symbol["for"]("react.provider") : 60109,
	  k = b ? Symbol["for"]("react.context") : 60110,
	  l = b ? Symbol["for"]("react.async_mode") : 60111,
	  m = b ? Symbol["for"]("react.concurrent_mode") : 60111,
	  n = b ? Symbol["for"]("react.forward_ref") : 60112,
	  p = b ? Symbol["for"]("react.suspense") : 60113,
	  q = b ? Symbol["for"]("react.suspense_list") : 60120,
	  r = b ? Symbol["for"]("react.memo") : 60115,
	  t = b ? Symbol["for"]("react.lazy") : 60116,
	  v = b ? Symbol["for"]("react.block") : 60121,
	  w = b ? Symbol["for"]("react.fundamental") : 60117,
	  x = b ? Symbol["for"]("react.responder") : 60118,
	  y = b ? Symbol["for"]("react.scope") : 60119;
	function z(a) {
	  if ("object" === typeof a && null !== a) {
	    var u = a.$$typeof;
	    switch (u) {
	      case c:
	        switch (a = a.type, a) {
	          case l:
	          case m:
	          case e:
	          case g:
	          case f$8:
	          case p:
	            return a;
	          default:
	            switch (a = a && a.$$typeof, a) {
	              case k:
	              case n:
	              case t:
	              case r:
	              case h:
	                return a;
	              default:
	                return u;
	            }
	        }
	      case d:
	        return u;
	    }
	  }
	}
	function A(a) {
	  return z(a) === m;
	}
	var AsyncMode = l;
	var ConcurrentMode = m;
	var ContextConsumer = k;
	var ContextProvider = h;
	var Element$1 = c;
	var ForwardRef = n;
	var Fragment = e;
	var Lazy = t;
	var Memo = r;
	var Portal = d;
	var Profiler = g;
	var StrictMode = f$8;
	var Suspense = p;
	var isAsyncMode = function (a) {
	  return A(a) || z(a) === l;
	};
	var isConcurrentMode = A;
	var isContextConsumer = function (a) {
	  return z(a) === k;
	};
	var isContextProvider = function (a) {
	  return z(a) === h;
	};
	var isElement = function (a) {
	  return "object" === typeof a && null !== a && a.$$typeof === c;
	};
	var isForwardRef = function (a) {
	  return z(a) === n;
	};
	var isFragment = function (a) {
	  return z(a) === e;
	};
	var isLazy = function (a) {
	  return z(a) === t;
	};
	var isMemo = function (a) {
	  return z(a) === r;
	};
	var isPortal = function (a) {
	  return z(a) === d;
	};
	var isProfiler = function (a) {
	  return z(a) === g;
	};
	var isStrictMode = function (a) {
	  return z(a) === f$8;
	};
	var isSuspense = function (a) {
	  return z(a) === p;
	};
	var isValidElementType = function (a) {
	  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f$8 || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
	};
	var typeOf = z;

	var reactIs_production_min = {
		AsyncMode: AsyncMode,
		ConcurrentMode: ConcurrentMode,
		ContextConsumer: ContextConsumer,
		ContextProvider: ContextProvider,
		Element: Element$1,
		ForwardRef: ForwardRef,
		Fragment: Fragment,
		Lazy: Lazy,
		Memo: Memo,
		Portal: Portal,
		Profiler: Profiler,
		StrictMode: StrictMode,
		Suspense: Suspense,
		isAsyncMode: isAsyncMode,
		isConcurrentMode: isConcurrentMode,
		isContextConsumer: isContextConsumer,
		isContextProvider: isContextProvider,
		isElement: isElement,
		isForwardRef: isForwardRef,
		isFragment: isFragment,
		isLazy: isLazy,
		isMemo: isMemo,
		isPortal: isPortal,
		isProfiler: isProfiler,
		isStrictMode: isStrictMode,
		isSuspense: isSuspense,
		isValidElementType: isValidElementType,
		typeOf: typeOf
	};

	var reactIs_development = createCommonjsModule(function (module, exports) {
	});
	var reactIs_development_1 = reactIs_development.AsyncMode;
	var reactIs_development_2 = reactIs_development.ConcurrentMode;
	var reactIs_development_3 = reactIs_development.ContextConsumer;
	var reactIs_development_4 = reactIs_development.ContextProvider;
	var reactIs_development_5 = reactIs_development.Element;
	var reactIs_development_6 = reactIs_development.ForwardRef;
	var reactIs_development_7 = reactIs_development.Fragment;
	var reactIs_development_8 = reactIs_development.Lazy;
	var reactIs_development_9 = reactIs_development.Memo;
	var reactIs_development_10 = reactIs_development.Portal;
	var reactIs_development_11 = reactIs_development.Profiler;
	var reactIs_development_12 = reactIs_development.StrictMode;
	var reactIs_development_13 = reactIs_development.Suspense;
	var reactIs_development_14 = reactIs_development.isAsyncMode;
	var reactIs_development_15 = reactIs_development.isConcurrentMode;
	var reactIs_development_16 = reactIs_development.isContextConsumer;
	var reactIs_development_17 = reactIs_development.isContextProvider;
	var reactIs_development_18 = reactIs_development.isElement;
	var reactIs_development_19 = reactIs_development.isForwardRef;
	var reactIs_development_20 = reactIs_development.isFragment;
	var reactIs_development_21 = reactIs_development.isLazy;
	var reactIs_development_22 = reactIs_development.isMemo;
	var reactIs_development_23 = reactIs_development.isPortal;
	var reactIs_development_24 = reactIs_development.isProfiler;
	var reactIs_development_25 = reactIs_development.isStrictMode;
	var reactIs_development_26 = reactIs_development.isSuspense;
	var reactIs_development_27 = reactIs_development.isValidElementType;
	var reactIs_development_28 = reactIs_development.typeOf;

	var reactIs = createCommonjsModule(function (module) {

	{
	  module.exports = reactIs_production_min;
	}
	});
	var reactIs_1 = reactIs.isValidElementType;

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	var ReactPropTypesSecret_1 = ReactPropTypesSecret;

	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;
	var factoryWithThrowingShims = function () {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret_1) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
	    err.name = 'Invariant Violation';
	    throw err;
	  }
	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bigint: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,
	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,
	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };
	  ReactPropTypes.PropTypes = ReactPropTypes;
	  return ReactPropTypes;
	};

	var propTypes = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	{
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = factoryWithThrowingShims();
	}
	});

	var subscriptionShape = propTypes.shape({
	  trySubscribe: propTypes.func.isRequired,
	  tryUnsubscribe: propTypes.func.isRequired,
	  notifyNestedSubs: propTypes.func.isRequired,
	  isSubscribed: propTypes.func.isRequired
	});
	var storeShape = propTypes.shape({
	  subscribe: propTypes.func.isRequired,
	  dispatch: propTypes.func.isRequired,
	  getState: propTypes.func.isRequired
	});

	var prefixUnsafeLifecycleMethods = typeof React$1__default.forwardRef !== "undefined";
	function createProvider(storeKey) {
	  var _Provider$childContex;
	  if (storeKey === void 0) {
	    storeKey = 'store';
	  }
	  var subscriptionKey = storeKey + "Subscription";
	  var Provider = /*#__PURE__*/
	  function (_Component) {
	    _inheritsLoose(Provider, _Component);
	    var _proto = Provider.prototype;
	    _proto.getChildContext = function getChildContext() {
	      var _ref;
	      return _ref = {}, _ref[storeKey] = this[storeKey], _ref[subscriptionKey] = null, _ref;
	    };
	    function Provider(props, context) {
	      var _this;
	      _this = _Component.call(this, props, context) || this;
	      _this[storeKey] = props.store;
	      return _this;
	    }
	    _proto.render = function render() {
	      return React$1.Children.only(this.props.children);
	    };
	    return Provider;
	  }(React$1.Component);
	  Provider.propTypes = {
	    store: storeShape.isRequired,
	    children: propTypes.element.isRequired
	  };
	  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[storeKey] = storeShape.isRequired, _Provider$childContex[subscriptionKey] = subscriptionShape, _Provider$childContex);
	  return Provider;
	}
	var Provider = createProvider();

	function _assertThisInitialized$1(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	  return self;
	}

	function _extends$1() {
	  _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];
	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }
	    return target;
	  };
	  return _extends$1.apply(this, arguments);
	}

	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;
	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }
	  return target;
	}

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	var REACT_STATICS = {
	  childContextTypes: true,
	  contextType: true,
	  contextTypes: true,
	  defaultProps: true,
	  displayName: true,
	  getDefaultProps: true,
	  getDerivedStateFromError: true,
	  getDerivedStateFromProps: true,
	  mixins: true,
	  propTypes: true,
	  type: true
	};
	var KNOWN_STATICS = {
	  name: true,
	  length: true,
	  prototype: true,
	  caller: true,
	  callee: true,
	  arguments: true,
	  arity: true
	};
	var FORWARD_REF_STATICS = {
	  '$$typeof': true,
	  render: true,
	  defaultProps: true,
	  displayName: true,
	  propTypes: true
	};
	var MEMO_STATICS = {
	  '$$typeof': true,
	  compare: true,
	  defaultProps: true,
	  displayName: true,
	  propTypes: true,
	  type: true
	};
	var TYPE_STATICS = {};
	TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
	TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
	function getStatics(component) {
	  // React v16.11 and below
	  if (reactIs.isMemo(component)) {
	    return MEMO_STATICS;
	  } // React v16.12 and above

	  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
	}
	var defineProperty$b = Object.defineProperty;
	var getOwnPropertyNames$3 = Object.getOwnPropertyNames;
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var getOwnPropertyDescriptor$9 = Object.getOwnPropertyDescriptor;
	var getPrototypeOf = Object.getPrototypeOf;
	var objectPrototype = Object.prototype;
	function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
	  if (typeof sourceComponent !== 'string') {
	    // don't hoist over string (html) components
	    if (objectPrototype) {
	      var inheritedComponent = getPrototypeOf(sourceComponent);
	      if (inheritedComponent && inheritedComponent !== objectPrototype) {
	        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
	      }
	    }
	    var keys = getOwnPropertyNames$3(sourceComponent);
	    if (getOwnPropertySymbols) {
	      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
	    }
	    var targetStatics = getStatics(targetComponent);
	    var sourceStatics = getStatics(sourceComponent);
	    for (var i = 0; i < keys.length; ++i) {
	      var key = keys[i];
	      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
	        var descriptor = getOwnPropertyDescriptor$9(sourceComponent, key);
	        try {
	          // Avoid failures from read-only properties
	          defineProperty$b(targetComponent, key, descriptor);
	        } catch (e) {}
	      }
	    }
	  }
	  return targetComponent;
	}
	var hoistNonReactStatics_cjs = hoistNonReactStatics;

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var invariant = function invariant(condition, format, a, b, c, d, e, f) {
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	var invariant_1 = invariant;

	// encapsulates the subscription logic for connecting a component to the redux store, as
	// well as nesting subscriptions of descendant components, so that we can ensure the
	// ancestor components re-render before descendants
	var CLEARED = null;
	var nullListeners = {
	  notify: function notify() {}
	};
	function createListenerCollection() {
	  // the current/next pattern is copied from redux's createStore code.
	  // TODO: refactor+expose that code to be reusable here?
	  var current = [];
	  var next = [];
	  return {
	    clear: function clear() {
	      next = CLEARED;
	      current = CLEARED;
	    },
	    notify: function notify() {
	      var listeners = current = next;
	      for (var i = 0; i < listeners.length; i++) {
	        listeners[i]();
	      }
	    },
	    get: function get() {
	      return next;
	    },
	    subscribe: function subscribe(listener) {
	      var isSubscribed = true;
	      if (next === current) next = current.slice();
	      next.push(listener);
	      return function unsubscribe() {
	        if (!isSubscribed || current === CLEARED) return;
	        isSubscribed = false;
	        if (next === current) next = current.slice();
	        next.splice(next.indexOf(listener), 1);
	      };
	    }
	  };
	}
	var Subscription = /*#__PURE__*/
	function () {
	  function Subscription(store, parentSub, onStateChange) {
	    this.store = store;
	    this.parentSub = parentSub;
	    this.onStateChange = onStateChange;
	    this.unsubscribe = null;
	    this.listeners = nullListeners;
	  }
	  var _proto = Subscription.prototype;
	  _proto.addNestedSub = function addNestedSub(listener) {
	    this.trySubscribe();
	    return this.listeners.subscribe(listener);
	  };
	  _proto.notifyNestedSubs = function notifyNestedSubs() {
	    this.listeners.notify();
	  };
	  _proto.isSubscribed = function isSubscribed() {
	    return Boolean(this.unsubscribe);
	  };
	  _proto.trySubscribe = function trySubscribe() {
	    if (!this.unsubscribe) {
	      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);
	      this.listeners = createListenerCollection();
	    }
	  };
	  _proto.tryUnsubscribe = function tryUnsubscribe() {
	    if (this.unsubscribe) {
	      this.unsubscribe();
	      this.unsubscribe = null;
	      this.listeners.clear();
	      this.listeners = nullListeners;
	    }
	  };
	  return Subscription;
	}();

	var prefixUnsafeLifecycleMethods$1 = typeof React$1__default.forwardRef !== "undefined";
	var hotReloadingVersion = 0;
	var dummyState = {};
	function noop() {}
	function makeSelectorStateful(sourceSelector, store) {
	  // wrap the selector in an object that tracks its results between runs.
	  var selector = {
	    run: function runComponentSelector(props) {
	      try {
	        var nextProps = sourceSelector(store.getState(), props);
	        if (nextProps !== selector.props || selector.error) {
	          selector.shouldComponentUpdate = true;
	          selector.props = nextProps;
	          selector.error = null;
	        }
	      } catch (error) {
	        selector.shouldComponentUpdate = true;
	        selector.error = error;
	      }
	    }
	  };
	  return selector;
	}
	function connectAdvanced(
	/*
	  selectorFactory is a func that is responsible for returning the selector function used to
	  compute new props from state, props, and dispatch. For example:
	     export default connectAdvanced((dispatch, options) => (state, props) => ({
	      thing: state.things[props.thingId],
	      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
	    }))(YourComponent)
	   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
	  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
	  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
	   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
	  props. Do not use connectAdvanced directly without memoizing results between calls to your
	  selector, otherwise the Connect component will re-render on every state or props change.
	*/
	selectorFactory,
	// options object:
	_ref) {
	  var _contextTypes, _childContextTypes;
	  if (_ref === void 0) {
	    _ref = {};
	  }
	  var _ref2 = _ref,
	    _ref2$getDisplayName = _ref2.getDisplayName,
	    getDisplayName = _ref2$getDisplayName === void 0 ? function (name) {
	      return "ConnectAdvanced(" + name + ")";
	    } : _ref2$getDisplayName,
	    _ref2$methodName = _ref2.methodName,
	    methodName = _ref2$methodName === void 0 ? 'connectAdvanced' : _ref2$methodName,
	    _ref2$renderCountProp = _ref2.renderCountProp,
	    renderCountProp = _ref2$renderCountProp === void 0 ? undefined : _ref2$renderCountProp,
	    _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,
	    shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta,
	    _ref2$storeKey = _ref2.storeKey,
	    storeKey = _ref2$storeKey === void 0 ? 'store' : _ref2$storeKey,
	    _ref2$withRef = _ref2.withRef,
	    withRef = _ref2$withRef === void 0 ? false : _ref2$withRef,
	    connectOptions = _objectWithoutPropertiesLoose(_ref2, ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef"]);
	  var subscriptionKey = storeKey + 'Subscription';
	  var version = hotReloadingVersion++;
	  var contextTypes = (_contextTypes = {}, _contextTypes[storeKey] = storeShape, _contextTypes[subscriptionKey] = subscriptionShape, _contextTypes);
	  var childContextTypes = (_childContextTypes = {}, _childContextTypes[subscriptionKey] = subscriptionShape, _childContextTypes);
	  return function wrapWithConnect(WrappedComponent) {
	    invariant_1(reactIs_1(WrappedComponent), "You must pass a component to the function returned by " + (methodName + ". Instead received " + JSON.stringify(WrappedComponent)));
	    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
	    var displayName = getDisplayName(wrappedComponentName);
	    var selectorFactoryOptions = _extends$1({}, connectOptions, {
	      getDisplayName: getDisplayName,
	      methodName: methodName,
	      renderCountProp: renderCountProp,
	      shouldHandleStateChanges: shouldHandleStateChanges,
	      storeKey: storeKey,
	      withRef: withRef,
	      displayName: displayName,
	      wrappedComponentName: wrappedComponentName,
	      WrappedComponent: WrappedComponent // TODO Actually fix our use of componentWillReceiveProps

	      /* eslint-disable react/no-deprecated */
	    });
	    var Connect = /*#__PURE__*/
	    function (_Component) {
	      _inheritsLoose(Connect, _Component);
	      function Connect(props, context) {
	        var _this;
	        _this = _Component.call(this, props, context) || this;
	        _this.version = version;
	        _this.state = {};
	        _this.renderCount = 0;
	        _this.store = props[storeKey] || context[storeKey];
	        _this.propsMode = Boolean(props[storeKey]);
	        _this.setWrappedInstance = _this.setWrappedInstance.bind(_assertThisInitialized$1(_assertThisInitialized$1(_this)));
	        invariant_1(_this.store, "Could not find \"" + storeKey + "\" in either the context or props of " + ("\"" + displayName + "\". Either wrap the root component in a <Provider>, ") + ("or explicitly pass \"" + storeKey + "\" as a prop to \"" + displayName + "\"."));
	        _this.initSelector();
	        _this.initSubscription();
	        return _this;
	      }
	      var _proto = Connect.prototype;
	      _proto.getChildContext = function getChildContext() {
	        var _ref3;

	        // If this component received store from props, its subscription should be transparent
	        // to any descendants receiving store+subscription from context; it passes along
	        // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
	        // Connect to control ordering of notifications to flow top-down.
	        var subscription = this.propsMode ? null : this.subscription;
	        return _ref3 = {}, _ref3[subscriptionKey] = subscription || this.context[subscriptionKey], _ref3;
	      };
	      _proto.componentDidMount = function componentDidMount() {
	        if (!shouldHandleStateChanges) return; // componentWillMount fires during server side rendering, but componentDidMount and
	        // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.
	        // Otherwise, unsubscription would never take place during SSR, causing a memory leak.
	        // To handle the case where a child component may have triggered a state change by
	        // dispatching an action in its componentWillMount, we have to re-run the select and maybe
	        // re-render.

	        this.subscription.trySubscribe();
	        this.selector.run(this.props);
	        if (this.selector.shouldComponentUpdate) this.forceUpdate();
	      }; // Note: this is renamed below to the UNSAFE_ version in React >=16.3.0

	      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	        this.selector.run(nextProps);
	      };
	      _proto.shouldComponentUpdate = function shouldComponentUpdate() {
	        return this.selector.shouldComponentUpdate;
	      };
	      _proto.componentWillUnmount = function componentWillUnmount() {
	        if (this.subscription) this.subscription.tryUnsubscribe();
	        this.subscription = null;
	        this.notifyNestedSubs = noop;
	        this.store = null;
	        this.selector.run = noop;
	        this.selector.shouldComponentUpdate = false;
	      };
	      _proto.getWrappedInstance = function getWrappedInstance() {
	        invariant_1(withRef, "To access the wrapped instance, you need to specify " + ("{ withRef: true } in the options argument of the " + methodName + "() call."));
	        return this.wrappedInstance;
	      };
	      _proto.setWrappedInstance = function setWrappedInstance(ref) {
	        this.wrappedInstance = ref;
	      };
	      _proto.initSelector = function initSelector() {
	        var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
	        this.selector = makeSelectorStateful(sourceSelector, this.store);
	        this.selector.run(this.props);
	      };
	      _proto.initSubscription = function initSubscription() {
	        if (!shouldHandleStateChanges) return; // parentSub's source should match where store came from: props vs. context. A component
	        // connected to the store via props shouldn't use subscription from context, or vice versa.

	        var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
	        this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this)); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
	        // the middle of the notification loop, where `this.subscription` will then be null. An
	        // extra null check every change can be avoided by copying the method onto `this` and then
	        // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
	        // listeners logic is changed to not call listeners that have been unsubscribed in the
	        // middle of the notification loop.

	        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
	      };
	      _proto.onStateChange = function onStateChange() {
	        this.selector.run(this.props);
	        if (!this.selector.shouldComponentUpdate) {
	          this.notifyNestedSubs();
	        } else {
	          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
	          this.setState(dummyState);
	        }
	      };
	      _proto.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate() {
	        // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
	        // needs to notify nested subs. Once called, it unimplements itself until further state
	        // changes occur. Doing it this way vs having a permanent `componentDidUpdate` that does
	        // a boolean check every time avoids an extra method call most of the time, resulting
	        // in some perf boost.
	        this.componentDidUpdate = undefined;
	        this.notifyNestedSubs();
	      };
	      _proto.isSubscribed = function isSubscribed() {
	        return Boolean(this.subscription) && this.subscription.isSubscribed();
	      };
	      _proto.addExtraProps = function addExtraProps(props) {
	        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props; // make a shallow copy so that fields added don't leak to the original selector.
	        // this is especially important for 'ref' since that's a reference back to the component
	        // instance. a singleton memoized selector would then be holding a reference to the
	        // instance, preventing the instance from being garbage collected, and that would be bad

	        var withExtras = _extends$1({}, props);
	        if (withRef) withExtras.ref = this.setWrappedInstance;
	        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++;
	        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription;
	        return withExtras;
	      };
	      _proto.render = function render() {
	        var selector = this.selector;
	        selector.shouldComponentUpdate = false;
	        if (selector.error) {
	          throw selector.error;
	        } else {
	          return React$1.createElement(WrappedComponent, this.addExtraProps(selector.props));
	        }
	      };
	      return Connect;
	    }(React$1.Component);
	    if (prefixUnsafeLifecycleMethods$1) {
	      // Use UNSAFE_ event name where supported
	      Connect.prototype.UNSAFE_componentWillReceiveProps = Connect.prototype.componentWillReceiveProps;
	      delete Connect.prototype.componentWillReceiveProps;
	    }
	    /* eslint-enable react/no-deprecated */

	    Connect.WrappedComponent = WrappedComponent;
	    Connect.displayName = displayName;
	    Connect.childContextTypes = childContextTypes;
	    Connect.contextTypes = contextTypes;
	    Connect.propTypes = contextTypes;
	    return hoistNonReactStatics_cjs(Connect, WrappedComponent);
	  };
	}

	var hasOwn = Object.prototype.hasOwnProperty;
	function is$1(x, y) {
	  if (x === y) {
	    return x !== 0 || y !== 0 || 1 / x === 1 / y;
	  } else {
	    return x !== x && y !== y;
	  }
	}
	function shallowEqual(objA, objB) {
	  if (is$1(objA, objB)) return true;
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	  if (keysA.length !== keysB.length) return false;
	  for (var i = 0; i < keysA.length; i++) {
	    if (!hasOwn.call(objB, keysA[i]) || !is$1(objA[keysA[i]], objB[keysA[i]])) {
	      return false;
	    }
	  }
	  return true;
	}

	function wrapMapToPropsConstant(getConstant) {
	  return function initConstantSelector(dispatch, options) {
	    var constant = getConstant(dispatch, options);
	    function constantSelector() {
	      return constant;
	    }
	    constantSelector.dependsOnOwnProps = false;
	    return constantSelector;
	  };
	} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
	// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
	// whether mapToProps needs to be invoked when props have changed.
	// 
	// A length of one signals that mapToProps does not depend on props from the parent component.
	// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
	// therefore not reporting its length accurately..

	function getDependsOnOwnProps(mapToProps) {
	  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
	} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
	// this function wraps mapToProps in a proxy function which does several things:
	// 
	//  * Detects whether the mapToProps function being called depends on props, which
	//    is used by selectorFactory to decide if it should reinvoke on props changes.
	//    
	//  * On first call, handles mapToProps if returns another function, and treats that
	//    new function as the true mapToProps for subsequent calls.
	//    
	//  * On first call, verifies the first result is a plain object, in order to warn
	//    the developer that their mapToProps function is not returning a valid result.
	//    

	function wrapMapToPropsFunc(mapToProps, methodName) {
	  return function initProxySelector(dispatch, _ref) {
	    var displayName = _ref.displayName;
	    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
	      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
	    }; // allow detectFactoryAndVerify to get ownProps

	    proxy.dependsOnOwnProps = true;
	    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
	      proxy.mapToProps = mapToProps;
	      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
	      var props = proxy(stateOrDispatch, ownProps);
	      if (typeof props === 'function') {
	        proxy.mapToProps = props;
	        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
	        props = proxy(stateOrDispatch, ownProps);
	      }
	      return props;
	    };
	    return proxy;
	  };
	}

	function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
	  return typeof mapDispatchToProps === 'function' ? wrapMapToPropsFunc(mapDispatchToProps) : undefined;
	}
	function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
	  return !mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) {
	    return {
	      dispatch: dispatch
	    };
	  }) : undefined;
	}
	function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
	  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? wrapMapToPropsConstant(function (dispatch) {
	    return bindActionCreators(mapDispatchToProps, dispatch);
	  }) : undefined;
	}
	var defaultMapDispatchToPropsFactories = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];

	function whenMapStateToPropsIsFunction(mapStateToProps) {
	  return typeof mapStateToProps === 'function' ? wrapMapToPropsFunc(mapStateToProps) : undefined;
	}
	function whenMapStateToPropsIsMissing(mapStateToProps) {
	  return !mapStateToProps ? wrapMapToPropsConstant(function () {
	    return {};
	  }) : undefined;
	}
	var defaultMapStateToPropsFactories = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];

	function defaultMergeProps(stateProps, dispatchProps, ownProps) {
	  return _extends$1({}, ownProps, stateProps, dispatchProps);
	}
	function wrapMergePropsFunc(mergeProps) {
	  return function initMergePropsProxy(dispatch, _ref) {
	    var displayName = _ref.displayName,
	      pure = _ref.pure,
	      areMergedPropsEqual = _ref.areMergedPropsEqual;
	    var hasRunOnce = false;
	    var mergedProps;
	    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
	      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
	      if (hasRunOnce) {
	        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
	      } else {
	        hasRunOnce = true;
	        mergedProps = nextMergedProps;
	      }
	      return mergedProps;
	    };
	  };
	}
	function whenMergePropsIsFunction(mergeProps) {
	  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
	}
	function whenMergePropsIsOmitted(mergeProps) {
	  return !mergeProps ? function () {
	    return defaultMergeProps;
	  } : undefined;
	}
	var defaultMergePropsFactories = [whenMergePropsIsFunction, whenMergePropsIsOmitted];

	function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
	  return function impureFinalPropsSelector(state, ownProps) {
	    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
	  };
	}
	function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
	  var areStatesEqual = _ref.areStatesEqual,
	    areOwnPropsEqual = _ref.areOwnPropsEqual,
	    areStatePropsEqual = _ref.areStatePropsEqual;
	  var hasRunAtLeastOnce = false;
	  var state;
	  var ownProps;
	  var stateProps;
	  var dispatchProps;
	  var mergedProps;
	  function handleFirstCall(firstState, firstOwnProps) {
	    state = firstState;
	    ownProps = firstOwnProps;
	    stateProps = mapStateToProps(state, ownProps);
	    dispatchProps = mapDispatchToProps(dispatch, ownProps);
	    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
	    hasRunAtLeastOnce = true;
	    return mergedProps;
	  }
	  function handleNewPropsAndNewState() {
	    stateProps = mapStateToProps(state, ownProps);
	    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
	    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
	    return mergedProps;
	  }
	  function handleNewProps() {
	    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
	    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
	    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
	    return mergedProps;
	  }
	  function handleNewState() {
	    var nextStateProps = mapStateToProps(state, ownProps);
	    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
	    stateProps = nextStateProps;
	    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
	    return mergedProps;
	  }
	  function handleSubsequentCalls(nextState, nextOwnProps) {
	    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
	    var stateChanged = !areStatesEqual(nextState, state);
	    state = nextState;
	    ownProps = nextOwnProps;
	    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
	    if (propsChanged) return handleNewProps();
	    if (stateChanged) return handleNewState();
	    return mergedProps;
	  }
	  return function pureFinalPropsSelector(nextState, nextOwnProps) {
	    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
	  };
	} // TODO: Add more comments
	// If pure is true, the selector returned by selectorFactory will memoize its results,
	// allowing connectAdvanced's shouldComponentUpdate to return false if final
	// props have not changed. If false, the selector will always return a new
	// object and shouldComponentUpdate will always return true.

	function finalPropsSelectorFactory(dispatch, _ref2) {
	  var initMapStateToProps = _ref2.initMapStateToProps,
	    initMapDispatchToProps = _ref2.initMapDispatchToProps,
	    initMergeProps = _ref2.initMergeProps,
	    options = _objectWithoutPropertiesLoose(_ref2, ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"]);
	  var mapStateToProps = initMapStateToProps(dispatch, options);
	  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
	  var mergeProps = initMergeProps(dispatch, options);
	  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
	  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
	}

	/*
	  connect is a facade over connectAdvanced. It turns its args into a compatible
	  selectorFactory, which has the signature:

	    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
	  
	  connect passes its args to connectAdvanced as options, which will in turn pass them to
	  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

	  selectorFactory returns a final props selector from its mapStateToProps,
	  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
	  mergePropsFactories, and pure args.

	  The resulting final props selector is called by the Connect component instance whenever
	  it receives new props or store state.
	 */

	function match$1(arg, factories, name) {
	  for (var i = factories.length - 1; i >= 0; i--) {
	    var result = factories[i](arg);
	    if (result) return result;
	  }
	  return function (dispatch, options) {
	    throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
	  };
	}
	function strictEqual(a, b) {
	  return a === b;
	} // createConnect with default args builds the 'official' connect behavior. Calling it with
	// different options opens up some testing and extensibility scenarios

	function createConnect(_temp) {
	  var _ref = _temp === void 0 ? {} : _temp,
	    _ref$connectHOC = _ref.connectHOC,
	    connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC,
	    _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
	    mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? defaultMapStateToPropsFactories : _ref$mapStateToPropsF,
	    _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
	    mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? defaultMapDispatchToPropsFactories : _ref$mapDispatchToPro,
	    _ref$mergePropsFactor = _ref.mergePropsFactories,
	    mergePropsFactories = _ref$mergePropsFactor === void 0 ? defaultMergePropsFactories : _ref$mergePropsFactor,
	    _ref$selectorFactory = _ref.selectorFactory,
	    selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;
	  return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {
	    if (_ref2 === void 0) {
	      _ref2 = {};
	    }
	    var _ref3 = _ref2,
	      _ref3$pure = _ref3.pure,
	      pure = _ref3$pure === void 0 ? true : _ref3$pure,
	      _ref3$areStatesEqual = _ref3.areStatesEqual,
	      areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual,
	      _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,
	      areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual : _ref3$areOwnPropsEqua,
	      _ref3$areStatePropsEq = _ref3.areStatePropsEqual,
	      areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual : _ref3$areStatePropsEq,
	      _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,
	      areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual : _ref3$areMergedPropsE,
	      extraOptions = _objectWithoutPropertiesLoose(_ref3, ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"]);
	    var initMapStateToProps = match$1(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
	    var initMapDispatchToProps = match$1(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
	    var initMergeProps = match$1(mergeProps, mergePropsFactories, 'mergeProps');
	    return connectHOC(selectorFactory, _extends$1({
	      // used in error messages
	      methodName: 'connect',
	      // used to compute Connect's displayName from the wrapped component's displayName.
	      getDisplayName: function getDisplayName(name) {
	        return "Connect(" + name + ")";
	      },
	      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
	      shouldHandleStateChanges: Boolean(mapStateToProps),
	      // passed through to selectorFactory
	      initMapStateToProps: initMapStateToProps,
	      initMapDispatchToProps: initMapDispatchToProps,
	      initMergeProps: initMergeProps,
	      pure: pure,
	      areStatesEqual: areStatesEqual,
	      areOwnPropsEqual: areOwnPropsEqual,
	      areStatePropsEqual: areStatePropsEqual,
	      areMergedPropsEqual: areMergedPropsEqual
	    }, extraOptions));
	  };
	}
	var connect = createConnect();

	function _callSuper$2(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function createCollectionItemScopeConnector (collectionName) {
	  var itemScopeProperty = getItemScopeProperty(collectionName);
	  return function connectInItemScope(mapStateToProps, mapDispatchToProps, mergeProps) {
	    var connecter = connect(mapStateToProps ? function (state, props) {
	      var result = mapStateToProps(addItemScope(state, collectionName, props[itemScopeProperty]), props);
	      if (typeof result == 'function') {
	        return function (state, props) {
	          return result(addItemScope(state, collectionName, props[itemScopeProperty]), props);
	        };
	      }
	      return result;
	    } : null, mapDispatchToProps ? function (dispatch, props) {
	      var wrappedDispatch = function wrappedDispatch(action) {
	        ensureItemActionId(action, collectionName, props[itemScopeProperty]);
	        return dispatch(action);
	      };
	      if (typeof mapDispatchToProps == 'function') {
	        return mapDispatchToProps(wrappedDispatch, props);
	      } else {
	        return bindActionCreators(mapDispatchToProps, wrappedDispatch);
	      }
	    } : null, mergeProps);
	    return function (Component) {
	      var Connected = connecter(Component);
	      var ConnectedInItemScope = /*#__PURE__*/function (_React$Component) {
	        _inherits(ConnectedInItemScope, _React$Component);
	        function ConnectedInItemScope() {
	          _classCallCheck(this, ConnectedInItemScope);
	          return _callSuper$2(this, ConnectedInItemScope, arguments);
	        }
	        _createClass(ConnectedInItemScope, [{
	          key: "render",
	          value: function render() {
	            var props = _objectSpread2(_objectSpread2({}, this.props), {}, _defineProperty({}, itemScopeProperty, this.context[itemScopeProperty]));
	            return /*#__PURE__*/React$1__default.createElement(Connected, props);
	          }
	        }]);
	        return ConnectedInItemScope;
	      }(React$1__default.Component);
	      ConnectedInItemScope.contextTypes = _defineProperty({}, itemScopeProperty, React$1__default.PropTypes.number);
	      return ConnectedInItemScope;
	    };
	  };
	}

	function _callSuper$3(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function createItemScopeProvider (collectionName) {
	  var ItemScopeProvider = /*#__PURE__*/function (_React$Component) {
	    _inherits(ItemScopeProvider, _React$Component);
	    function ItemScopeProvider() {
	      _classCallCheck(this, ItemScopeProvider);
	      return _callSuper$3(this, ItemScopeProvider, arguments);
	    }
	    _createClass(ItemScopeProvider, [{
	      key: "getChildContext",
	      value: function getChildContext() {
	        return _defineProperty({}, getItemScopeProperty(collectionName), this.props.itemId);
	      }
	    }, {
	      key: "render",
	      value: function render() {
	        return this.props.children;
	      }
	    }]);
	    return ItemScopeProvider;
	  }(React$1__default.Component);
	  ItemScopeProvider.childContextTypes = _defineProperty({}, getItemScopeProperty(collectionName), React$1__default.PropTypes.number);
	  return ItemScopeProvider;
	}

	function pickAttributes (attributeNames, record, additionalAttributes) {
	  var result = camelize.deep(attributeNames.reduce(function (result, attributeName) {
	    if (typeof attributeName == 'object') {
	      var key = Object.keys(attributeName)[0];
	      var value = attributeName[key];
	      result[key] = record[value];
	    } else {
	      result[attributeName] = record[attributeName];
	    }
	    return result;
	  }, {}));
	  if (additionalAttributes) {
	    return _objectSpread2(_objectSpread2({}, result), camelize.deep(additionalAttributes));
	  }
	  return result;
	}

	function watchBackboneCollection (_ref) {
	  var collection = _ref.collection,
	    dispatch = _ref.dispatch,
	    collectionName = _ref.collectionName,
	    _ref$idAttribute = _ref.idAttribute,
	    idAttribute = _ref$idAttribute === void 0 ? 'id' : _ref$idAttribute,
	    _ref$attributes = _ref.attributes,
	    attributes = _ref$attributes === void 0 ? ['id'] : _ref$attributes,
	    _ref$includeConfigura = _ref.includeConfiguration,
	    includeConfiguration = _ref$includeConfigura === void 0 ? false : _ref$includeConfigura;
	  dispatch(reset({
	    collectionName: collectionName,
	    items: collection.map(modelToAttributes)
	  }));
	  collection.on('add', function (model) {
	    if (!model.isNew()) {
	      dispatch(add({
	        collectionName: collectionName,
	        attributes: modelToAttributes(model)
	      }));
	    }
	  });
	  collection.on('change:id', function (model) {
	    dispatch(add({
	      collectionName: collectionName,
	      attributes: modelToAttributes(model),
	      order: collection.pluck(idAttribute)
	    }));
	  });
	  collection.on('change', function (model) {
	    if (watchedAttributeHasChanged(model)) {
	      dispatch(change({
	        collectionName: collectionName,
	        attributes: modelToAttributes(model)
	      }));
	    }
	  });
	  if (includeConfiguration) {
	    collection.on('change:configuration', function (model) {
	      dispatch(change({
	        collectionName: collectionName,
	        attributes: modelToAttributes(model)
	      }));
	    });
	  }
	  collection.on('remove', function (model) {
	    setTimeout(function () {
	      dispatch(remove({
	        collectionName: collectionName,
	        attributes: modelToAttributes(model),
	        order: collection.pluck(idAttribute)
	      }));
	    }, 0);
	  });
	  collection.on('sort', function () {
	    dispatch(order({
	      collectionName: collectionName,
	      order: collection.pluck(idAttribute)
	    }));
	  });
	  var watchedAttributes = attributes.map(function (attribute) {
	    return typeof attribute == 'object' ? mappedAttributeSource(attribute) : attribute;
	  });
	  function watchedAttributeHasChanged(model) {
	    return watchedAttributes.some(function (attribute) {
	      return model.hasChanged(attribute);
	    });
	  }
	  function modelToAttributes(model) {
	    return pickAttributes(attributes, model.attributes, includeConfiguration && model.configuration.attributes);
	  }
	  function mappedAttributeSource(attribute) {
	    return attribute[Object.keys(attribute)[0]];
	  }
	}

	function loadFromSeed (_ref) {
	  var collection = _ref.collection,
	    collectionName = _ref.collectionName,
	    dispatch = _ref.dispatch,
	    _ref$attributes = _ref.attributes,
	    attributes = _ref$attributes === void 0 ? ['id'] : _ref$attributes,
	    _ref$includeConfigura = _ref.includeConfiguration,
	    includeConfiguration = _ref$includeConfigura === void 0 ? false : _ref$includeConfigura;
	  dispatch(reset({
	    collectionName: collectionName,
	    items: collection.map(function (record) {
	      return pickAttributes(attributes, record, includeConfiguration && record.configuration);
	    })
	  }));
	}

	function watch (_ref) {
	  var collection = _ref.collection,
	    collectionName = _ref.collectionName,
	    dispatch = _ref.dispatch,
	    idAttribute = _ref.idAttribute,
	    attributes = _ref.attributes,
	    includeConfiguration = _ref.includeConfiguration;
	  var delegate = Backbone.Collection && collection instanceof Backbone.Collection ? watchBackboneCollection : loadFromSeed;
	  delegate({
	    collection: collection,
	    collectionName: collectionName,
	    dispatch: dispatch,
	    idAttribute: idAttribute,
	    attributes: attributes,
	    includeConfiguration: includeConfiguration
	  });
	}

	function findThumbnailCandidate(_ref) {
	  var candidates = _ref.candidates,
	    page = _ref.page,
	    fileExists = _ref.fileExists;
	  return candidates.find(function (candidate) {
	    if (candidate.condition && !conditionMet(candidate.condition, page)) {
	      return false;
	    }
	    var id = thumbnailCandidateId(page, candidate);
	    return fileExists(camelize(candidate.collectionName), id);
	  });
	}
	function conditionMet(condition, page) {
	  var value = page[camelize(condition.attribute)];
	  if (condition.negated) {
	    return value != condition.value;
	  } else {
	    return value == condition.value;
	  }
	}
	function thumbnailCandidateId(page, candidate) {
	  return 'id' in candidate ? candidate.id : page[camelize(candidate.attribute)];
	}

	function expandUrls (collectionName, file, urlTemplates) {
	  if (!file) {
	    return null;
	  }
	  if (!urlTemplates[collectionName]) {
	    throw new Error("No file url templates found for ".concat(collectionName));
	  }
	  var variants = file.variants || Object.keys(urlTemplates[collectionName]);
	  var urls = variants.reduce(function (result, variant) {
	    var url = getFileUrl(collectionName, file, variant, urlTemplates);
	    if (url) {
	      result[variant] = url;
	    }
	    return result;
	  }, {});
	  return _objectSpread2({
	    urls: urls
	  }, file);
	}
	function getFileUrl(collectionName, file, quality, urlTemplates) {
	  var templates = urlTemplates[collectionName];
	  var template = templates[quality];
	  if (template) {
	    return template.replace(':id_partition', idPartition(file.id)).replace(':basename', file.basename).replace(':processed_extension', file.processedExtension).replace(':pageflow_hls_qualities', function () {
	      return hlsQualities(file);
	    });
	  }
	}
	function idPartition(id) {
	  return partition(pad(id, 9));
	}
	function partition(string, separator) {
	  return string.replace(/./g, function (c, i, a) {
	    return i && (a.length - i) % 3 === 0 ? '/' + c : c;
	  });
	}
	function pad(string, size) {
	  return (Array(size).fill(0).join('') + string).slice(-size);
	}
	function hlsQualities(file) {
	  return ['low', 'medium', 'high', 'fullhd', '4k'].filter(function (quality) {
	    return file.variants.includes(quality);
	  }).join(',');
	}

	function addTypeInfo (collectionName, file, modelTypes) {
	  if (!file) {
	    return null;
	  }
	  if (!modelTypes[collectionName]) {
	    throw new Error("Could not find model type for collection name ".concat(collectionName));
	  }
	  return _objectSpread2(_objectSpread2({}, file), {}, {
	    collectionName: collectionName,
	    modelType: modelTypes[collectionName]
	  });
	}

	function file(collectionName, options) {
	  return memoizedSelector(createItemSelector(collectionName, {
	    namespace: 'files'
	  })(options), function (state) {
	    return state.fileUrlTemplates;
	  }, function (state) {
	    return state.modelTypes;
	  }, function (file, fileUrlTemplates, modelTypes) {
	    return extendFile(collectionName, file, fileUrlTemplates, modelTypes);
	  });
	}
	function nestedFiles(collectionName, _ref) {
	  var parent = _ref.parent;
	  return memoizedSelector(createCollectionItemsSelector(collectionName, {
	    namespace: 'files'
	  }), parent, function (state) {
	    return state.fileUrlTemplates;
	  }, function (state) {
	    return state.modelTypes;
	  }, function (files, parentFile, fileUrlTemplates, modelTypes) {
	    if (!parentFile) {
	      return [];
	    }
	    return Object.keys(files).reduce(function (result, fileId) {
	      var file = files[fileId];
	      if (file.id && file.parentFileId == parentFile.id && file.parentFileModelType == parentFile.modelType) {
	        result.push(extendFile(collectionName, file, fileUrlTemplates, modelTypes));
	      }
	      return result;
	    }, []);
	  });
	}
	function fileExists() {
	  return memoizedSelector(function (state) {
	    return state.files;
	  }, function (files) {
	    return function (collectionName, id) {
	      return id && !!createItemSelector(collectionName)({
	        id: id
	      })(files);
	    };
	  });
	}
	function extendFile(collectionName, file, fileUrlTemplates, modelTypes) {
	  return addTypeInfo(collectionName, expandUrls(collectionName, file, fileUrlTemplates), modelTypes);
	}

	function pageType(_ref) {
	  var page = _ref.page;
	  return function (state, props) {
	    var _page = typeof page == 'function' ? page(props) : page;
	    return _page ? state.pageTypes[camelize(_page.type)] : null;
	  };
	}

	function pageBackgroundImageUrl(_ref) {
	  var pageSelector = _ref.page,
	    _ref$variant = _ref.variant,
	    variant = _ref$variant === void 0 ? 'medium' : _ref$variant;
	  return memoizedSelector(pageSelector, fileExists(), function (state) {
	    return state;
	  }, function (page, fileExists, state) {
	    if (!page) {
	      return undefined;
	    }
	    var pageType$1 = pageType({
	      page: page
	    })(state);
	    var candidate = findThumbnailCandidate({
	      candidates: pageType$1.thumbnailCandidates,
	      page: page,
	      fileExists: fileExists
	    });
	    if (!candidate) {
	      return undefined;
	    }
	    var fileSelector = file(camelize(candidate.collectionName), {
	      id: thumbnailCandidateId(page, candidate)
	    });
	    if (candidate.collectionName == 'image_files') {
	      return fileSelector(state).urls[variant];
	    } else if (candidate.collectionName == 'video_files') {
	      return fileSelector(state).urls["poster_".concat(variant)];
	    }
	  });
	}

	var selector = createItemSelector('pages');
	var firstPage = createFirstItemSelector('pages');
	function firstPageAttribures() {
	  return memoizedSelector(firstPage, function (page) {
	    return page && page.attributes;
	  });
	}
	function firstPageAttribute(property) {
	  return memoizedSelector(firstPage, function (page) {
	    return page && page.attributes[property];
	  });
	}
	function pageAttribute(property, options) {
	  return memoizedSelector(selector(options), function (page) {
	    return page && page.attributes[property];
	  });
	}
	function pageAttributes(options) {
	  return memoizedSelector(selector(options), function (page) {
	    return page && page.attributes;
	  });
	}
	function pageState(property, options) {
	  return memoizedSelector(selector(options), function (page) {
	    return page && page.state.custom[property];
	  });
	}
	function pageIsActive(options) {
	  return commonPageState('isActive', options);
	}
	function pageIsActivated(options) {
	  return commonPageState('isActivated', options);
	}
	function pageIsPreloaded(options) {
	  return commonPageState('isPreloaded', options);
	}
	function pageIsPrepared(options) {
	  return commonPageState('isPrepared', options);
	}
	function initialScrollerPosition$1(options) {
	  return commonPageState('initialScrollerPosition', options);
	}
	function commonPageState(property, options) {
	  return memoizedSelector(selector(options), function (page) {
	    return page && page.state.common[property];
	  });
	}

	function _regeneratorRuntime$1() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$1 = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	var _marked = /*#__PURE__*/_regeneratorRuntime$1().mark(_callee),
	  _marked2 = /*#__PURE__*/_regeneratorRuntime$1().mark(scheduleUnprepare);
	function _callee() {
	  return _regeneratorRuntime$1().wrap(function _callee$(_context) {
	    while (1) switch (_context.prev = _context.next) {
	      case 0:
	        _context.next = 2;
	        return lib_6([PAGE_SCHEDULE_UNPREPARE, PAGE_DID_PREPARE, PAGE_WILL_ACTIVATE], scheduleUnprepare);
	      case 2:
	      case "end":
	        return _context.stop();
	    }
	  }, _marked);
	}
	function scheduleUnprepare(action) {
	  return _regeneratorRuntime$1().wrap(function scheduleUnprepare$(_context2) {
	    while (1) switch (_context2.prev = _context2.next) {
	      case 0:
	        if (!(action.type == PAGE_SCHEDULE_UNPREPARE)) {
	          _context2.next = 5;
	          break;
	        }
	        _context2.next = 3;
	        return call(lib_4$1, 5000);
	      case 3:
	        _context2.next = 5;
	        return put(pageDidUnprepare());
	      case 5:
	      case "end":
	        return _context2.stop();
	    }
	  }, _marked2);
	}

	var _marked$1 = /*#__PURE__*/_regeneratorRuntime$2().mark(_callee3);
	function _regeneratorRuntime$2() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$2 = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function _callee3(pagesCollection) {
	  return _regeneratorRuntime$2().wrap(function _callee3$(_context3) {
	    while (1) switch (_context3.prev = _context3.next) {
	      case 0:
	        if (pagesCollection instanceof Backbone.Collection) {
	          _context3.next = 2;
	          break;
	        }
	        return _context3.abrupt("return");
	      case 2:
	        _context3.next = 4;
	        return lib_7(UPDATE_PAGE_ATTRIBUTE, /*#__PURE__*/_regeneratorRuntime$2().mark(function _callee(action) {
	          return _regeneratorRuntime$2().wrap(function _callee$(_context) {
	            while (1) switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return call(updatePageAttribute$1, {
	                  pagesCollection: pagesCollection,
	                  id: getItemIdFromItemAction(action),
	                  name: action.payload.name,
	                  value: action.payload.value
	                });
	              case 2:
	              case "end":
	                return _context.stop();
	            }
	          }, _callee);
	        }));
	      case 4:
	        _context3.next = 6;
	        return lib_7(UPDATE_PAGE_LINK, /*#__PURE__*/_regeneratorRuntime$2().mark(function _callee2(action) {
	          return _regeneratorRuntime$2().wrap(function _callee2$(_context2) {
	            while (1) switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.next = 2;
	                return call(updatePageLink$1, {
	                  pagesCollection: pagesCollection,
	                  pageId: getItemIdFromItemAction(action),
	                  linkId: action.payload.linkId,
	                  name: action.payload.name,
	                  value: action.payload.value
	                });
	              case 2:
	              case "end":
	                return _context2.stop();
	            }
	          }, _callee2);
	        }));
	      case 6:
	      case "end":
	        return _context3.stop();
	    }
	  }, _marked$1);
	}
	function updatePageLink$1(_ref) {
	  var pagesCollection = _ref.pagesCollection,
	    pageId = _ref.pageId,
	    linkId = _ref.linkId,
	    name = _ref.name,
	    value = _ref.value;
	  var pageLink = getPage(pagesCollection, pageId).pageLinks().get(linkId);
	  if (!pageLink) {
	    throw new Error("Could not find page link with id ".concat(linkId, " in page with perma id ").concat(pageId, "."));
	  }
	  pageLink.set(name, value);
	}
	function updatePageAttribute$1(_ref2) {
	  var pagesCollection = _ref2.pagesCollection,
	    id = _ref2.id,
	    name = _ref2.name,
	    value = _ref2.value;
	  getPage(pagesCollection, id).configuration.set(name, value);
	}
	function getPage(collection, id) {
	  var page = collection.where({
	    'perma_id': id
	  })[0];
	  if (!page) {
	    throw new Error("Could not find page with perma id ".concat(id, "."));
	  }
	  return page;
	}

	function _regeneratorRuntime$3() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$3 = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function createPageSaga (_ref) {
	  var pages = _ref.pages,
	    pageTypeSagas = _ref.pageTypeSagas;
	  return /*#__PURE__*/_regeneratorRuntime$3().mark(function _callee3$1() {
	    var task;
	    return _regeneratorRuntime$3().wrap(function _callee3$(_context3) {
	      while (1) switch (_context3.prev = _context3.next) {
	        case 0:
	          return _context3.delegateYield(_callee(), "t0", 1);
	        case 1:
	          return _context3.delegateYield(_callee3(pages), "t1", 2);
	        case 2:
	          _context3.next = 4;
	          return lib_7(ENHANCE, /*#__PURE__*/_regeneratorRuntime$3().mark(function _callee() {
	            var thisPageType, pageTypeSaga;
	            return _regeneratorRuntime$3().wrap(function _callee$(_context) {
	              while (1) switch (_context.prev = _context.next) {
	                case 0:
	                  _context.next = 2;
	                  return select(pageAttribute('type'));
	                case 2:
	                  thisPageType = _context.sent;
	                  pageTypeSaga = pageTypeSagas[thisPageType];
	                  if (!pageTypeSaga) {
	                    _context.next = 8;
	                    break;
	                  }
	                  _context.next = 7;
	                  return fork(pageTypeSaga);
	                case 7:
	                  task = _context.sent;
	                case 8:
	                case "end":
	                  return _context.stop();
	              }
	            }, _callee);
	          }));
	        case 4:
	          _context3.next = 6;
	          return lib_7(CLEANUP, /*#__PURE__*/_regeneratorRuntime$3().mark(function _callee2() {
	            return _regeneratorRuntime$3().wrap(function _callee2$(_context2) {
	              while (1) switch (_context2.prev = _context2.next) {
	                case 0:
	                  if (!task) {
	                    _context2.next = 3;
	                    break;
	                  }
	                  _context2.next = 3;
	                  return cancel(task);
	                case 3:
	                case "end":
	                  return _context2.stop();
	              }
	            }, _callee2);
	          }));
	        case 6:
	        case "end":
	          return _context3.stop();
	      }
	    }, _callee3$1);
	  });
	}

	function _callSuper$4(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var MediaContextProvider = /*#__PURE__*/function (_React$Component) {
	  _inherits(MediaContextProvider, _React$Component);
	  function MediaContextProvider() {
	    _classCallCheck(this, MediaContextProvider);
	    return _callSuper$4(this, MediaContextProvider, arguments);
	  }
	  _createClass(MediaContextProvider, [{
	    key: "getChildContext",
	    value: function getChildContext() {
	      return {
	        mediaContext: this.props.mediaContext
	      };
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return this.props.children;
	    }
	  }]);
	  return MediaContextProvider;
	}(React$1__default.Component);
	MediaContextProvider.childContextTypes = {
	  mediaContext: React$1__default.PropTypes.object
	};

	var PageProvider = createItemScopeProvider('pages');
	function createReactPageType (_ref) {
	  var Component = _ref.Component,
	    store = _ref.store,
	    _ref$selectTargetElem = _ref.selectTargetElement,
	    selectTargetElement = _ref$selectTargetElem === void 0 ? function (pageElement) {
	      return pageElement[0];
	    } : _ref$selectTargetElem;
	  return {
	    scroller: false,
	    enhance: function enhance$1(pageElement, configuration) {
	      ReactDOM.render( /*#__PURE__*/React$1__default.createElement(Provider, {
	        store: store
	      }, /*#__PURE__*/React$1__default.createElement(PageProvider, {
	        itemId: pageId(pageElement)
	      }, /*#__PURE__*/React$1__default.createElement(MediaContextProvider, {
	        mediaContext: {
	          page: pageElement.page('instance')
	        }
	      }, /*#__PURE__*/React$1__default.createElement(Component, null)))), selectTargetElement(pageElement));
	      store.dispatch(enhance({
	        id: pageId(pageElement)
	      }));
	    },
	    preload: function preload(pageElement) {
	      store.dispatch(pageDidPreload({
	        id: pageId(pageElement)
	      }));
	    },
	    prepare: function prepare(pageElement) {
	      store.dispatch(pageDidPrepare({
	        id: pageId(pageElement)
	      }));
	    },
	    unprepare: function unprepare(pageElement) {
	      store.dispatch(pageScheduleUnprepare({
	        id: pageId(pageElement)
	      }));
	    },
	    activating: function activating(pageElement, configuration, options) {
	      store.dispatch(pageWillActivate({
	        id: pageId(pageElement),
	        position: options.position
	      }));
	    },
	    activated: function activated(pageElement) {
	      store.dispatch(pageDidActivate({
	        id: pageId(pageElement)
	      }));
	    },
	    deactivating: function deactivating(pageElement) {
	      store.dispatch(pageWillDeactivate({
	        id: pageId(pageElement)
	      }));
	    },
	    deactivated: function deactivated(pageElement) {
	      store.dispatch(pageDidDeactivate({
	        id: pageId(pageElement)
	      }));
	    },
	    resize: function resize(pageElement) {
	      store.dispatch(pageDidResize({
	        id: pageId(pageElement)
	      }));
	    },
	    update: function update(pageElement, configuration) {
	      pageflow.commonPageCssClasses.updateCommonPageCssClasses(pageElement, configuration);
	    },
	    cleanup: function cleanup$1(pageElement) {
	      store.dispatch(cleanup({
	        id: pageId(pageElement)
	      }));
	      ReactDOM.unmountComponentAtNode(pageElement[0]);
	    }
	  };
	}
	function pageId(pageElement) {
	  return parseInt(pageElement.attr('id'), 10);
	}

	function mergePageTypes(base, mixin) {
	  return Object.keys(mixin).reduce(function (result, memberName) {
	    if (typeof base[memberName] == 'function') {
	      result[memberName] = function () {
	        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }
	        base[memberName].apply(this, args);
	        return mixin[memberName].apply(this, args);
	      };
	    } else {
	      result[memberName] = mixin[memberName];
	    }
	    return result;
	  }, _objectSpread2({}, base));
	}

	var pagesModule = {
	  init: function init(_ref) {
	    var pages = _ref.pages,
	      dispatch = _ref.dispatch;
	    watch({
	      collection: pages,
	      collectionName: 'pages',
	      dispatch: dispatch,
	      idAttribute: 'perma_id',
	      attributes: ['perma_id', {
	        type: 'template'
	      }, 'chapter_id'],
	      includeConfiguration: true
	    });
	  },
	  createReducers: function createReducers(_ref2) {
	    var _ref2$pageTypes = _ref2.pageTypes,
	      pageTypes = _ref2$pageTypes === void 0 ? [] : _ref2$pageTypes;
	    var pageStateReducers = pageTypes.reduce(function (result, _ref3) {
	      var name = _ref3.name,
	        reducer = _ref3.reducer;
	      result[name] = reducer;
	      return result;
	    }, {});
	    return {
	      pages: createCollectionReducer('pages', {
	        idAttribute: 'permaId',
	        itemReducer: createPageStateReducer(pageStateReducers)
	      })
	    };
	  },
	  createMiddleware: createMiddleware,
	  createSaga: function createSaga(_ref4) {
	    var pages = _ref4.pages,
	      _ref4$pageTypes = _ref4.pageTypes,
	      pageTypes = _ref4$pageTypes === void 0 ? [] : _ref4$pageTypes,
	      middleware = _ref4.middleware;
	    var pageTypeSagas = pageTypes.reduce(function (result, _ref5) {
	      var name = _ref5.name,
	        saga = _ref5.saga;
	      result[name] = saga;
	      return result;
	    }, {});
	    return createCollectionSaga('pages', {
	      itemSaga: createPageSaga({
	        pages: pages,
	        pageTypeSagas: pageTypeSagas
	      }),
	      middleware: middleware
	    });
	  }
	};
	var connectInPage = createCollectionItemScopeConnector('pages');
	function createPageType(options) {
	  return mergePageTypes(createReactPageType(options), options.mixin || {});
	}

	var LazyBackgroundImage = connectInPage(combine$1({
	  loaded: pageIsPreloaded()
	}))(BackgroundImage);

	function _callSuper$5(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }

	/**
	 * @desc Can be used inside {@link
	 * pageflow.react.components.PageBackground|PageBackground} to display
	 * the background image specified in the page configuration.
	 *
	 * @alias pageflow.react.components.PageBackgroundImage
	 * @class
	 * @since 0.1
	 *
	 * @prop page
	 *   Required. The page object to read configuration properties from.
	 *
	 * @prop propertyBaseName
	 *   By default the configuration property `backgroundImage` is
	 *   used. Use this prop to specify a different property name.
	 *
	 * @prop fileCollection
	 *   Set to `"videoFiles"` if the `propertyBaseName` refers to a video
	 *   you want to display the poster of.
	 */
	var PageBackgroundImage = /*#__PURE__*/function (_React$Component) {
	  _inherits(PageBackgroundImage, _React$Component);
	  function PageBackgroundImage() {
	    _classCallCheck(this, PageBackgroundImage);
	    return _callSuper$5(this, PageBackgroundImage, arguments);
	  }
	  _createClass(PageBackgroundImage, [{
	    key: "render",
	    value: function render() {
	      var page = this.props.page;
	      var property = camelize.concat(this.props.propertyNamePrefix, this.props.propertyBaseName);
	      return /*#__PURE__*/React$1__default.createElement(LazyBackgroundImage, {
	        fileId: page["".concat(property, "Id")],
	        fileCollection: this.props.fileCollection,
	        position: [page["".concat(property, "X")], page["".concat(property, "Y")]],
	        className: "background background_image",
	        structuredDataComponent: this.props.structuredDataComponent
	      });
	    }
	  }]);
	  return PageBackgroundImage;
	}(React$1__default.Component);
	PageBackgroundImage.defaultProps = {
	  propertyBaseName: 'backgroundImage'
	};

	function _callSuper$6(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }

	/**
	 * @desc Can be used inside
	 * {@link pageflow.react.components.PageBackground|PageBackground} to
	 * display a gradient which improves the contrast of text displayed
	 * inside the {@link
	 * pageflow.react.components.PageForeground|PageForeground}
	 *
	 * @alias pageflow.react.components.PageShadow
	 * @class
	 * @since 0.1
	 *
	 * @prop page
	 *   Required. The page object to read configuration properties from.
	 */
	var PageShadow = /*#__PURE__*/function (_React$Component) {
	  _inherits(PageShadow, _React$Component);
	  function PageShadow() {
	    _classCallCheck(this, PageShadow);
	    return _callSuper$6(this, PageShadow, arguments);
	  }
	  _createClass(PageShadow, [{
	    key: "render",
	    value: function render() {
	      return /*#__PURE__*/React$1__default.createElement("div", {
	        className: "shadow_wrapper"
	      }, /*#__PURE__*/React$1__default.createElement("div", {
	        className: classnames('shadow', this.props.className),
	        style: this.style()
	      }));
	    }
	  }, {
	    key: "style",
	    value: function style() {
	      if ('gradientOpacity' in this.props.page) {
	        return {
	          opacity: this.props.page.gradientOpacity / 100
	        };
	      }
	    }
	  }]);
	  return PageShadow;
	}(React$1__default.Component);

	/**
	 * Use inside {@link
	 * pageflow.react.components.PageWrapper|PageWrapper}  to build the
	 * default page structure.
	 *
	 * @alias pageflow.react.components.PageForeground
	 * @class
	 * @since 12.1
	 */
	function PageForeground (props) {
	  return /*#__PURE__*/React$1__default.createElement("div", {
	    className: "content",
	    onTouchStart: props.onInteraction,
	    onMouseMove: props.onInteraction
	  }, props.children);
	}

	function _callSuper$7(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var Scroller = /*#__PURE__*/function (_Component) {
	  _inherits(Scroller, _Component);
	  function Scroller() {
	    _classCallCheck(this, Scroller);
	    return _callSuper$7(this, Scroller, arguments);
	  }
	  _createClass(Scroller, [{
	    key: "render",
	    value: function render() {
	      var _this = this;
	      return /*#__PURE__*/React.createElement("div", {
	        className: "scroller-wrapper",
	        ref: function ref(element) {
	          return _this.wrapperElement = element;
	        }
	      }, /*#__PURE__*/React.createElement("div", {
	        ref: function ref(element) {
	          return _this.scrollerElement = element;
	        },
	        className: classnames('scroller', this.props.className),
	        style: this.props.style
	      }, /*#__PURE__*/React.createElement("div", null, this.props.children)));
	    }
	  }, {
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      if (typeof jQuery !== 'undefined') {
	        var element = jQuery(this.scrollerElement);
	        element.scroller({
	          eventListenerTarget: this.wrapperElement
	        });
	        this.scroller = element.scroller('instance');
	      }
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate() {
	      this.scroller.refresh();
	    }
	  }, {
	    key: "enable",
	    value: function enable() {
	      this.scroller.enable();
	      this.scroller.afterAnimationHook();
	    }
	  }, {
	    key: "disable",
	    value: function disable() {
	      this.scroller.disable();
	    }
	  }, {
	    key: "resetPosition",
	    value: function resetPosition(options) {
	      this.scroller.resetPosition(options);
	    }
	  }]);
	  return Scroller;
	}(React$1.Component);

	function _callSuper$8(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }

	/**
	 * @desc Can be used inside
	 * {@link pageflow.react.components.PageForeground|PageForeground} to
	 * build the default page structure.
	 *
	 * @alias pageflow.react.components.PageScroller
	 * @since 12.1
	 */
	var PageScroller = /*#__PURE__*/function (_React$Component) {
	  _inherits(PageScroller, _React$Component);
	  function PageScroller() {
	    _classCallCheck(this, PageScroller);
	    return _callSuper$8(this, PageScroller, arguments);
	  }
	  _createClass(PageScroller, [{
	    key: "componentWillReceiveProps",
	    value: function componentWillReceiveProps(nextProps) {
	      if (!this.props.enabled && nextProps.enabled) {
	        this.refs.scroller.enable();
	      } else if (this.props.enabled && !nextProps.enabled) {
	        this.refs.scroller.disable();
	      }
	      if (this.props.initialScrollerPosition !== nextProps.initialScrollerPosition && nextProps.initialScrollerPosition) {
	        this.refs.scroller.resetPosition({
	          position: nextProps.initialScrollerPosition
	        });
	      }
	    }
	  }, {
	    key: "getChildContext",
	    value: function getChildContext() {
	      var _this = this;
	      this._pageScroller = this._pageScroller || {
	        disable: function disable() {
	          _this.refs.scroller.disable();
	        },
	        enable: function enable() {
	          _this.refs.scroller.enable();
	        }
	      };
	      return {
	        pageScroller: this._pageScroller
	      };
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return /*#__PURE__*/React$1__default.createElement(Scroller, {
	        ref: "scroller",
	        className: className$1(this.props),
	        style: style(this.props)
	      }, /*#__PURE__*/React$1__default.createElement("div", {
	        className: "content_wrapper"
	      }, this.props.children));
	    }
	  }]);
	  return PageScroller;
	}(React$1__default.Component);
	function className$1(props) {
	  return classnames(props.className, {
	    'scroller-clipped_bottom': !!props.marginBottom
	  });
	}
	function style(props) {
	  if (props.marginBottom) {
	    return {
	      bottom: props.marginBottom
	    };
	  }
	}
	PageScroller.childContextTypes = {
	  pageScroller: React$1__default.PropTypes.object
	};
	var PageScroller$1 = connectInPage(combine$1({
	  enabled: pageIsActivated(),
	  initialScrollerPosition: initialScrollerPosition$1()
	}))(PageScroller);

	/**
	 * Can be used inside
	 * {@link pageflow.react.components.PageWrapper|PageWrapper} to build the
	 * default page structure.
	 *
	 * @alias pageflow.react.components.PageContent
	 * @class
	 * @since 0.1
	 */
	function PageContent (props) {
	  return /*#__PURE__*/React.createElement(PageForeground, null, /*#__PURE__*/React.createElement(PageScroller$1, null, props.children));
	}

	function _callSuper$9(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }

	/**
	 * @desc Place inside
	 * {@link pageflow.react.components.PageScroller|PageScroller} to
	 * display the page's headings.
	 *
	 * @alias pageflow.react.components.PageHeader
	 * @class
	 * @since 0.1
	 *
	 * @prop page
	 *   Required. The page object to read configuration properties from.
	 */
	var _default$1 = /*#__PURE__*/function (_React$Component) {
	  _inherits(_default, _React$Component);
	  function _default() {
	    _classCallCheck(this, _default);
	    return _callSuper$9(this, _default, arguments);
	  }
	  _createClass(_default, [{
	    key: "render",
	    value: function render() {
	      return /*#__PURE__*/React$1__default.createElement("h3", {
	        className: "page_header"
	      }, /*#__PURE__*/React$1__default.createElement("span", {
	        className: "page_header-tagline"
	      }, this.props.page.tagline), /*#__PURE__*/React$1__default.createElement("span", {
	        className: "page_header-title"
	      }, this.props.page.title), /*#__PURE__*/React$1__default.createElement("span", {
	        className: "page_header-subtitle"
	      }, this.props.page.subtitle));
	    }
	  }]);
	  return _default;
	}(React$1__default.Component);

	/**
	 * @desc Place inside
	 * {@link pageflow.react.components.PageScroller|PageScroller} to
	 * display the page's content text.
	 *
	 * @alias pageflow.react.components.PageText
	 * @class
	 * @since 0.1
	 *
	 * @prop page
	 *   Required. The page object to read configuration properties from.
	 */
	function PageText(props) {
	  return /*#__PURE__*/React$1__default.createElement("div", {
	    className: className$2(props)
	  }, /*#__PURE__*/React$1__default.createElement("div", {
	    className: "paragraph",
	    dangerouslySetInnerHTML: text(props)
	  }), props.children);
	}
	PageText.defaultProps = {
	  marginBottom: 'for_scroll_indicator_on_phone'
	};
	function className$2(props) {
	  return classnames('page_text', _defineProperty({}, "page_text-margin_".concat(props.marginBottom), props.marginBottom != PageText.defaultProps.marginBottom));
	}
	function text(props) {
	  return {
	    __html: props.page.text
	  };
	}

	function prop(path) {
	  return function (state, props) {
	    var names = path.split('.');
	    if (!(names[0] in props)) {
	      throw new Error("Missing required prop ".concat(names[0], "."));
	    }
	    return names.reduce(function (p, name) {
	      return p && p[name];
	    }, props);
	  };
	}
	function has$3(featureName) {
	  return function (_props, _state, browser) {
	    return has$2(featureName, browser);
	  };
	}

	function _callSuper$a(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var PageLink = /*#__PURE__*/function (_React$Component) {
	  _inherits(PageLink, _React$Component);
	  function PageLink() {
	    _classCallCheck(this, PageLink);
	    return _callSuper$a(this, PageLink, arguments);
	  }
	  _createClass(PageLink, [{
	    key: "render",
	    value: function render() {
	      return /*#__PURE__*/React$1__default.createElement("a", {
	        href: this._href(),
	        className: this.props.className,
	        onClick: this._handleClick.bind(this)
	      }, this.props.children);
	    }
	  }, {
	    key: "_href",
	    value: function _href() {
	      if (this._targetPage()) {
	        return '#' + this._targetPage().permaId;
	      } else {
	        return '#missing';
	      }
	    }
	  }, {
	    key: "_handleClick",
	    value: function _handleClick(event) {
	      if (this._targetPage()) {
	        pageflow.slides.goToByPermaId(this._targetPage().permaId, {
	          transition: this.props.pageLink.pageTransition
	        });
	      }
	      event.preventDefault();
	    }
	  }, {
	    key: "_targetPage",
	    value: function _targetPage() {
	      return this.props.targetPage;
	    }
	  }]);
	  return PageLink;
	}(React$1__default.Component);
	var PageLink$1 = connect(combine$1({
	  targetPage: pageAttributes({
	    id: prop('pageLink.targetPageId')
	  })
	}))(PageLink);

	function PageThumbnail(props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: className$3(props)
	  });
	}
	PageThumbnail.defaultProps = {
	  imageStyle: 'navigation_thumbnail_large'
	};
	function className$3(props) {
	  return classnames({
	    load_image: props.lazy && props.loaded
	  }, props.className, typeClassName(props.pageType), thumbnailClassName(props));
	}
	function typeClassName(pageType) {
	  return pageType ? "is_".concat(pageType.name) : 'is_dangling';
	}
	function thumbnailClassName(props) {
	  var candidate = findThumbnailCandidate({
	    candidates: thumbnailCandidates(props),
	    page: props.page,
	    fileExists: props.fileExists
	  });
	  if (candidate) {
	    return thumbnailCandidateClassName(props, candidate);
	  }
	}
	function thumbnailCandidates(props) {
	  return [customThumbnailCandidate(props)].concat(_toConsumableArray(pageTypeCandidates(props.pageType)));
	}
	function customThumbnailCandidate(props) {
	  return {
	    id: props.customThumbnailId,
	    cssClassPrefix: 'pageflow_image_file',
	    collectionName: 'image_files'
	  };
	}
	function pageTypeCandidates(pageType) {
	  return pageType ? pageType.thumbnailCandidates : [];
	}
	function thumbnailCandidateClassName(props, candidate) {
	  return [props.lazy ? 'lazy' : null, candidate.cssClassPrefix, props.imageStyle, thumbnailCandidateId(props.page, candidate)].filter(Boolean).join('_');
	}
	var PageThumbnail$1 = connectInPage(combine$1({
	  pageType: pageType({
	    page: function page(props) {
	      return props.page;
	    }
	  }),
	  fileExists: fileExists()
	}))(PageThumbnail);

	var LazyLoadedPageThumbnail = connectInPage(combine$1({
	  loaded: pageIsPreloaded(),
	  lazy: true
	}))(PageThumbnail$1);

	function InfoBox(props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: wrapperClassNames(props)
	  }, header(props), description(props));
	}
	function wrapperClassNames(props) {
	  return classnames('add_info_box', {
	    'empty': isEmpty(props),
	    'title_empty': isBlank(props.title),
	    'description_empty': isBlank(props.description),
	    'add_info_box-hidden_during_playback': props.hiddenDuringPlayback
	  });
	}
	function header(props) {
	  if (!isBlank(props.title)) {
	    return /*#__PURE__*/React.createElement("h3", null, props.title);
	  }
	}
	function description(props) {
	  if (!isBlank(props.description)) {
	    return /*#__PURE__*/React.createElement("p", {
	      dangerouslySetInnerHTML: {
	        __html: props.description
	      }
	    });
	  }
	}
	function isEmpty(props) {
	  return isBlank(props.title) && isBlank(props.description);
	}

	function Container(props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: classnames('controls', props.className),
	    "data-role": "player_controls",
	    onMouseEnter: props.onMouseEnter,
	    onMouseLeave: props.onMouseLeave,
	    onFocus: props.onFocus,
	    onBlur: props.onBlur
	  }, props.children);
	}

	/**
	 * Helper create components that render SVG icons.
	 *
	 * See {@link pageflow.react.iconMapping} for usage examples.
	 *
	 * @alias pageflow.react.components.SvgIcon
	 * @class
	 *
	 * @prop viewBoxWidth
	 *   Required. Width of view box used to interpret coordinates of child elements.
	 *
	 * @prop viewBoxHeight
	 *   Required. Height of view box used to interpret coordinates of child elements.
	 *
	 * @prop viewBoxLeft
	 *   Defaults to 0.
	 *
	 * @prop viewBoxTop
	 *   Defaults to 0.
	 *
	 * @prop className
	 *   CSS class name
	 *
	 * @prop width
	 *   Width attribute for the `svg` element.
	 *
	 * @prop height
	 *   Height attribute for the `svg` element.
	 */
	function Container$1(props) {
	  return /*#__PURE__*/React$1__default.createElement("svg", {
	    className: props.className,
	    version: "1.1",
	    xmlns: "http://www.w3.org/2000/svg",
	    width: props.width,
	    height: props.height,
	    viewBox: "".concat(props.viewBoxLeft, " ").concat(props.viewBoxTop, " ").concat(props.viewBoxWidth, " ").concat(props.viewBoxHeight)
	  }, props.children);
	}
	Container$1.defaultProps = {
	  width: 20,
	  height: 20,
	  viewBoxLeft: 0,
	  viewBoxTop: 0
	};

	function Checkmark (props) {
	  return /*#__PURE__*/React.createElement(Container$1, Object.assign({}, props, {
	    viewBoxWidth: 512,
	    viewBoxHeight: 512
	  }), /*#__PURE__*/React.createElement("polygon", {
	    points: "434.442,58.997 195.559,297.881 77.554,179.88 0,257.438 195.559,453.003 512,136.551 "
	  }));
	}

	function CircleWithNotch (props) {
	  return /*#__PURE__*/React.createElement(Container$1, Object.assign({}, props, {
	    viewBoxWidth: 1000,
	    viewBoxHeight: 1000
	  }), /*#__PURE__*/React.createElement("path", {
	    d: "M990,497.6c0,66.4-13,129.8-38.8,190.3c-25.9,60.5-60.7,112.7-104.4,156.4C803,888,750.9,922.8,690.3,948.7c-60.5,25.9-124,38.8-190.3,38.8s-129.8-12.9-190.3-38.8S197,888,153.3,844.3c-43.7-43.7-78.5-95.9-104.4-156.4C22.9,627.4,10,563.9,10,497.6c0-80.9,18.4-156.5,55.2-226.7c36.8-70.2,87.2-128,151.2-173.4s135.2-73.8,213.6-85v142.2c-80.6,16.4-147.4,56.7-200.4,120.9c-53,64.2-79.5,138.2-79.6,222c0,47.4,9.3,92.7,27.9,135.9c18.6,43.2,43.4,80.4,74.6,111.6c31.2,31.2,68.4,56.1,111.6,74.6c43.2,18.5,88.5,27.8,135.9,27.9c47.4,0,92.7-9.2,135.9-27.9C679,801,716.2,776.1,747.4,745c31.2-31.1,56-68.3,74.6-111.6c18.6-43.3,27.9-88.6,27.9-135.9c0-83.9-26.5-157.9-79.6-222C717.2,211.3,650.4,171,569.9,154.6V12.5c78.4,11.3,149.6,39.6,213.6,85c64,45.4,114.4,103.2,151.2,173.4c36.8,70.2,55.2,145.7,55.2,226.7H990z"
	  }));
	}

	function Disk (props) {
	  return /*#__PURE__*/React.createElement(Container$1, Object.assign({}, props, {
	    viewBoxWidth: 24,
	    viewBoxHeight: 24
	  }), /*#__PURE__*/React.createElement("circle", {
	    cx: "12",
	    cy: "12",
	    r: "12"
	  }));
	}

	function GearIcon (props) {
	  return /*#__PURE__*/React.createElement(Container$1, Object.assign({}, props, {
	    viewBoxWidth: 24,
	    viewBoxHeight: 24
	  }), /*#__PURE__*/React.createElement("path", {
	    d: "M21.312,14.056l-1.691-0.98c0,0-0.472-0.216-0.446-1.073c0,0-0.128-0.961,0.478-1.293l1.661-1.014 c0,0,0.546-0.245,0.313-0.818l-0.707-1.598c0,0-0.229-0.625-0.902-0.423l-1.93,0.615c0,0-0.666-0.009-1.078-0.458 c0,0-0.687-0.662-0.476-1.229l0.445-1.924c0,0,0.114-0.563-0.312-0.768l-1.995-0.757c0,0-0.43-0.026-0.562,0.305l-1.122,2.006 c0,0-0.524,0.437-1.248,0.292c0,0-0.752-0.072-0.928-0.253c0,0-1.135-1.916-1.19-2.015c0,0-0.21-0.437-0.65-0.262L7.144,3.176 c0,0-0.367,0.229-0.275,0.559l0.649,2.441c0,0-0.139,0.597-0.561,0.924c0,0-0.745,0.55-1.104,0.483L3.858,7.1 c0,0-0.578-0.207-0.805,0.294L2.306,9.232c0,0-0.143,0.38,0.251,0.616l1.96,1.123c0,0,0.624,0.286,0.441,1.38 c0,0,0.037,0.804-0.756,1.24c-0.793,0.437-1.476,0.875-1.476,0.875s-0.437,0.21-0.249,0.681c0.189,0.471,0.895,1.811,0.895,1.811 s0.131,0.336,0.762,0.091l1.723-0.466c0,0,0.5-0.151,1.031,0.319c0,0,0.741,0.504,0.687,0.919l-0.48,2.433 c0,0-0.157,0.411,0.312,0.676l1.929,0.733c0,0,0.538,0.052,0.68-0.389l0.84-1.532c0,0,0.278-0.669,1.177-0.625 c0,0,0.909-0.081,1.227,0.407l1.101,1.833c0,0,0.199,0.466,0.791,0.188l1.709-0.728c0,0,0.479-0.315,0.333-0.743l-0.533-1.853 c0,0-0.238-0.5,0.259-1.055c0,0,0.533-0.876,1.27-0.701l2.043,0.487c0,0,0.424,0.187,0.793-0.413l0.659-1.639 C21.685,14.901,21.886,14.313,21.312,14.056z M8.542,13.474c-0.824-1.931,0.073-4.166,2.004-4.989 c1.931-0.826,4.165,0.073,4.988,2.004c0.825,1.931-0.073,4.164-2.005,4.989C11.599,16.303,9.365,15.404,8.542,13.474z"
	  }))
	  /*
	      <path d="M20,14.5v-2.9l-1.8-0.3c-0.1-0.4-0.3-0.8-0.6-1.4l1.1-1.5l-2.1-2.1l-1.5,1.1c-0.5-0.3-1-0.5-1.4-0.6L13.5,5h-2.9l-0.3,1.8
	               C9.8,6.9,9.4,7.1,8.9,7.4L7.4,6.3L5.3,8.4l1,1.5c-0.3,0.5-0.4,0.9-0.6,1.4L4,11.5v2.9l1.8,0.3c0.1,0.5,0.3,0.9,0.6,1.4l-1,1.5
	               l2.1,2.1l1.5-1c0.4,0.2,0.9,0.4,1.4,0.6l0.3,1.8h3l0.3-1.8c0.5-0.1,0.9-0.3,1.4-0.6l1.5,1.1l2.1-2.1l-1.1-1.5c0.3-0.5,0.5-1,0.6-1.4
	               L20,14.5z M12,16c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3S13.7,16,12,16z" />*/;
	}

	function InfoIcon (props) {
	  return /*#__PURE__*/React.createElement(Container$1, Object.assign({}, props, {
	    viewBoxLeft: 5,
	    viewBoxTop: 5,
	    viewBoxWidth: 145,
	    viewBoxHeight: 145
	  }), /*#__PURE__*/React.createElement("path", {
	    d: "m80 15c-35.88 0-65 29.12-65 65s29.12 65 65 65 65-29.12 65-65-29.12-65-65-65zm0 10c30.36 0 55 24.64 55 55s-24.64 55-55 55-55-24.64-55-55 24.64-55 55-55z"
	  }), /*#__PURE__*/React.createElement("path", {
	    d: "m57.373 18.231a9.3834 9.1153 0 1 1 -18.767 0 9.3834 9.1153 0 1 1 18.767 0z",
	    transform: "matrix(1.1989 0 0 1.2342 21.214 28.75)"
	  }), /*#__PURE__*/React.createElement("path", {
	    d: "m90.665 110.96c-0.069 2.73 1.211 3.5 4.327 3.82l5.008 0.1v5.12h-39.073v-5.12l5.503-0.1c3.291-0.1 4.082-1.38 4.327-3.82v-30.813c0.035-4.879-6.296-4.113-10.757-3.968v-5.074l30.665-1.105"
	  }));
	}

	function Pause (props) {
	  return /*#__PURE__*/React.createElement(Container$1, Object.assign({}, props, {
	    viewBoxWidth: 512,
	    viewBoxHeight: 512
	  }), /*#__PURE__*/React.createElement("path", {
	    d: "M162.642 148.337h86.034v215.317h-86.034v-215.316z"
	  }), /*#__PURE__*/React.createElement("path", {
	    d: "M293.356 148.337h86.002v215.317h-86.002v-215.316z"
	  }));
	}

	function Play (props) {
	  return /*#__PURE__*/React.createElement(Container$1, Object.assign({}, props, {
	    viewBoxWidth: 512,
	    viewBoxHeight: 512
	  }), /*#__PURE__*/React.createElement("path", {
	    d: "M152.443 136.417l207.114 119.573-207.114 119.593z"
	  }));
	}

	function Subtitles (props) {
	  return /*#__PURE__*/React.createElement(Container$1, Object.assign({}, props, {
	    viewBoxWidth: 1200,
	    viewBoxHeight: 1200
	  }), /*#__PURE__*/React.createElement("path", {
	    transform: "translate(100,100)",
	    d: "M893.4,599V500H401.1V599H893.4z M893.4,794.5v-98.9H695.5v98.9H893.4z M598.9,794.5v-98.9H106.6v98.9H598.9z M106.6,500V599h197.8V500H106.6z M893.4,106.7c26.1,0,48.7,10,67.9,29.9s28.8,42.9,28.8,69v588.9c0,26.1-9.6,49.1-28.8,69c-19.2,19.9-41.8,29.9-67.9,29.9H106.6c-26.1,0-48.7-10-67.9-29.9c-19.2-19.9-28.8-42.9-28.8-69V205.5c0-26.1,9.6-49.1,28.8-69s41.8-29.9,67.9-29.9H893.4z"
	  }));
	}

	var icons = {
	  Checkmark: Checkmark,
	  CircleWithNotch: CircleWithNotch,
	  Disk: Disk,
	  Gear: GearIcon,
	  Info: InfoIcon,
	  Pause: Pause,
	  Play: Play,
	  Subtitles: Subtitles
	};

	/**
	 * Register {@link pageflow.react.components.SvgIcon} components to be used by other
	 * components.
	 *
	 * @example
	 *
	 * const {SvgIcon} = pageflow.react;
	 *
	 * pageflow.react.iconMapping['pageflow-rainbow.checkmark'] = function(props) {
	 *   return (
	 *     <SvgIcon {...props} viewBoxWidth={512} viewBoxHeight={512}>
	 *       <polygon points="434.442,58.997 195.559,297.881 77.554,179.88 0,257.438 195.559,453.003 512,136.551 " />
	 *     </SvgIcon>
	 *   );
	 * };
	 *
	 * @alias pageflow.react.iconMapping
	 */
	var iconMapping = {
	  toggleInfoBox: icons.Info,
	  mediaQuality: icons.Gear,
	  textTracks: icons.Subtitles,
	  activeMenuItem: icons.Checkmark,
	  loadingSpinner: icons.CircleWithNotch,
	  play: icons.Play,
	  pause: icons.Pause
	};

	/**
	 * Render an SVG icon from {@link pageflow.react.iconMapping}.
	 *
	 * @alias pageflow.react.components.Icon
	 * @class
	 * @since 12.1
	 *
	 * @prop name
	 *   Required. The key to look up in the mapping.
	 */
	function Icon(props) {
	  var SvgIcon = iconMapping[props.name];
	  if (!SvgIcon) {
	    throw new Error("No icon registered for \"".concat(props.name, "\"."));
	  }
	  return /*#__PURE__*/React$1__default.createElement(SvgIcon, props);
	}

	function LoadingSpinner (props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: "vjs-loading-spinner"
	  }, /*#__PURE__*/React.createElement(Icon, {
	    name: "loadingSpinner"
	  }));
	}

	function pageSkipLinkTarget (Component) {
	  return connectInPage(combine$1({
	    id: memoizedSelector(pageIsActive(), function (isActive) {
	      return isActive ? 'firstContent' : undefined;
	    })
	  }))(Component);
	}

	function PlayButton(props) {
	  return /*#__PURE__*/React.createElement("a", {
	    className: className$4(props),
	    href: "#",
	    tabIndex: "4",
	    id: props.id,
	    title: props.title,
	    onClick: clickHandler(props)
	  }, icon(props));
	}
	var PlayButton$1 = pageSkipLinkTarget(PlayButton);
	function className$4(props) {
	  return classnames('vjs-play-control', {
	    'vjs-playing': props.isPlaying
	  }, {
	    'player_controls-play_button-custom_icon': !!props.iconName
	  });
	}
	function clickHandler(props) {
	  return function (event) {
	    if (props.onClick) {
	      props.onClick(event);
	    }
	    event.preventDefault();
	  };
	}
	function icon(props) {
	  if (props.iconName) {
	    return /*#__PURE__*/React.createElement(Icon, {
	      name: props.iconName
	    });
	  } else {
	    return /*#__PURE__*/React.createElement("span", null);
	  }
	}

	function TimeDisplay(props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: classnames(props.className)
	  }, format(props.value));
	}
	var unknownTimePlaceholder = '-:--';
	TimeDisplay.defaultProps = {
	  value: 0
	};
	function format(value) {
	  if (isNaN(value)) {
	    return unknownTimePlaceholder;
	  }
	  var seconds = Math.floor(value) % 60;
	  var minutes = Math.floor(value / 60) % 60;
	  var hours = Math.floor(value / 60 / 60);
	  if (hours > 0) {
	    return "".concat(hours, ":").concat(pad$1(minutes), ":").concat(pad$1(seconds));
	  } else {
	    return "".concat(minutes, ":").concat(pad$1(seconds));
	  }
	}
	function pad$1(value) {
	  return value < 10 ? '0' + value : value;
	}

	function CurrentTime (props) {
	  return /*#__PURE__*/React.createElement(TimeDisplay, {
	    className: "vjs-current-time",
	    value: props.currentTime
	  });
	}

	function TimeDivider (props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: "vjs-time-divider"
	  }, "/");
	}

	function Duration (props) {
	  return /*#__PURE__*/React.createElement(TimeDisplay, {
	    className: "vjs-duration",
	    value: props.duration
	  });
	}

	var reactDraggable = createCommonjsModule(function (module, exports) {
	(function webpackUniversalModuleDefinition(root, factory) {
	  module.exports = factory(React$1__default, ReactDOM);
	})(commonjsGlobal, function (__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_11__) {
	  return /******/function (modules) {
	    // webpackBootstrap
	    /******/ // The module cache
	    /******/
	    var installedModules = {};
	    /******/
	    /******/ // The require function
	    /******/
	    function __webpack_require__(moduleId) {
	      /******/
	      /******/ // Check if module is in cache
	      /******/if (installedModules[moduleId]) /******/return installedModules[moduleId].exports;
	      /******/
	      /******/ // Create a new module (and put it into the cache)
	      /******/
	      var module = installedModules[moduleId] = {
	        /******/exports: {},
	        /******/id: moduleId,
	        /******/loaded: false
	        /******/
	      };
	      /******/
	      /******/ // Execute the module function
	      /******/
	      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	      /******/
	      /******/ // Flag the module as loaded
	      /******/
	      module.loaded = true;
	      /******/
	      /******/ // Return the exports of the module
	      /******/
	      return module.exports;
	      /******/
	    }
	    /******/
	    /******/
	    /******/ // expose the modules object (__webpack_modules__)
	    /******/
	    __webpack_require__.m = modules;
	    /******/
	    /******/ // expose the module cache
	    /******/
	    __webpack_require__.c = installedModules;
	    /******/
	    /******/ // __webpack_public_path__
	    /******/
	    __webpack_require__.p = "";
	    /******/
	    /******/ // Load entry module and return exports
	    /******/
	    return __webpack_require__(0);
	    /******/
	  }
	  /************************************************************************/
	  /******/([/* 0 */
	  /***/function (module, exports, __webpack_require__) {

	    module.exports = __webpack_require__(1)["default"];
	    module.exports.DraggableCore = __webpack_require__(17)["default"];

	    /***/
	  }, /* 1 */
	  /***/function (module, exports, __webpack_require__) {

	    Object.defineProperty(exports, "__esModule", {
	      value: true
	    });
	    var _extends = Object.assign || function (target) {
	      for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];
	        for (var key in source) {
	          if (Object.prototype.hasOwnProperty.call(source, key)) {
	            target[key] = source[key];
	          }
	        }
	      }
	      return target;
	    };
	    var _slicedToArray = function () {
	      function sliceIterator(arr, i) {
	        var _arr = [];
	        var _n = true;
	        var _d = false;
	        var _e = undefined;
	        try {
	          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	            _arr.push(_s.value);
	            if (i && _arr.length === i) break;
	          }
	        } catch (err) {
	          _d = true;
	          _e = err;
	        } finally {
	          try {
	            if (!_n && _i["return"]) _i["return"]();
	          } finally {
	            if (_d) throw _e;
	          }
	        }
	        return _arr;
	      }
	      return function (arr, i) {
	        if (Array.isArray(arr)) {
	          return arr;
	        } else if (Symbol.iterator in Object(arr)) {
	          return sliceIterator(arr, i);
	        } else {
	          throw new TypeError("Invalid attempt to destructure non-iterable instance");
	        }
	      };
	    }();
	    var _createClass = function () {
	      function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	          var descriptor = props[i];
	          descriptor.enumerable = descriptor.enumerable || false;
	          descriptor.configurable = true;
	          if ("value" in descriptor) descriptor.writable = true;
	          Object.defineProperty(target, descriptor.key, descriptor);
	        }
	      }
	      return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);
	        if (staticProps) defineProperties(Constructor, staticProps);
	        return Constructor;
	      };
	    }();
	    var _react = __webpack_require__(2);
	    var _react2 = _interopRequireDefault(_react);
	    var _propTypes = __webpack_require__(3);
	    var _propTypes2 = _interopRequireDefault(_propTypes);
	    var _reactDom = __webpack_require__(11);
	    var _reactDom2 = _interopRequireDefault(_reactDom);
	    var _classnames = __webpack_require__(12);
	    var _classnames2 = _interopRequireDefault(_classnames);
	    var _domFns = __webpack_require__(13);
	    var _positionFns = __webpack_require__(16);
	    var _shims = __webpack_require__(14);
	    var _DraggableCore = __webpack_require__(17);
	    var _DraggableCore2 = _interopRequireDefault(_DraggableCore);
	    var _log = __webpack_require__(19);
	    var _log2 = _interopRequireDefault(_log);
	    function _interopRequireDefault(obj) {
	      return obj && obj.__esModule ? obj : {
	        "default": obj
	      };
	    }
	    function _defineProperty(obj, key, value) {
	      if (key in obj) {
	        Object.defineProperty(obj, key, {
	          value: value,
	          enumerable: true,
	          configurable: true,
	          writable: true
	        });
	      } else {
	        obj[key] = value;
	      }
	      return obj;
	    }
	    function _classCallCheck(instance, Constructor) {
	      if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	      }
	    }
	    function _possibleConstructorReturn(self, call) {
	      if (!self) {
	        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	      }
	      return call && (typeof call === "object" || typeof call === "function") ? call : self;
	    }
	    function _inherits(subClass, superClass) {
	      if (typeof superClass !== "function" && superClass !== null) {
	        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	      }
	      subClass.prototype = Object.create(superClass && superClass.prototype, {
	        constructor: {
	          value: subClass,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	    }
	    // $FlowIgnore

	    /*:: import type {DraggableEventHandler} from './utils/types';*/
	    /*:: type DraggableState = {
	      dragging: boolean,
	      dragged: boolean,
	      x: number, y: number,
	      slackX: number, slackY: number,
	      isElementSVG: boolean
	    };*/

	    //
	    // Define <Draggable>
	    //

	    /*:: type ConstructorProps = {
	      position: { x: number, y: number },
	      defaultPosition: { x: number, y: number }
	    };*/

	    var Draggable = function (_React$Component) {
	      _inherits(Draggable, _React$Component);
	      function Draggable(props /*: ConstructorProps*/) {
	        _classCallCheck(this, Draggable);
	        var _this = _possibleConstructorReturn(this, (Draggable.__proto__ || Object.getPrototypeOf(Draggable)).call(this, props));
	        _this.onDragStart = function (e, coreData) {
	          (0, _log2["default"])('Draggable: onDragStart: %j', coreData);

	          // Short-circuit if user's callback killed it.
	          var shouldStart = _this.props.onStart(e, (0, _positionFns.createDraggableData)(_this, coreData));
	          // Kills start event on core as well, so move handlers are never bound.
	          if (shouldStart === false) return false;
	          _this.setState({
	            dragging: true,
	            dragged: true
	          });
	        };
	        _this.onDrag = function (e, coreData) {
	          if (!_this.state.dragging) return false;
	          (0, _log2["default"])('Draggable: onDrag: %j', coreData);
	          var uiData = (0, _positionFns.createDraggableData)(_this, coreData);
	          var newState /*: $Shape<DraggableState>*/ = {
	            x: uiData.x,
	            y: uiData.y
	          };

	          // Keep within bounds.
	          if (_this.props.bounds) {
	            // Save original x and y.
	            var _x = newState.x,
	              _y = newState.y;

	            // Add slack to the values used to calculate bound position. This will ensure that if
	            // we start removing slack, the element won't react to it right away until it's been
	            // completely removed.

	            newState.x += _this.state.slackX;
	            newState.y += _this.state.slackY;

	            // Get bound position. This will ceil/floor the x and y within the boundaries.
	            // $FlowBug

	            // Recalculate slack by noting how much was shaved by the boundPosition handler.
	            var _getBoundPosition = (0, _positionFns.getBoundPosition)(_this, newState.x, newState.y);
	            var _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2);
	            newState.x = _getBoundPosition2[0];
	            newState.y = _getBoundPosition2[1];
	            newState.slackX = _this.state.slackX + (_x - newState.x);
	            newState.slackY = _this.state.slackY + (_y - newState.y);

	            // Update the event we fire to reflect what really happened after bounds took effect.
	            uiData.x = _x;
	            uiData.y = _y;
	            uiData.deltaX = newState.x - _this.state.x;
	            uiData.deltaY = newState.y - _this.state.y;
	          }

	          // Short-circuit if user's callback killed it.
	          var shouldUpdate = _this.props.onDrag(e, uiData);
	          if (shouldUpdate === false) return false;
	          _this.setState(newState);
	        };
	        _this.onDragStop = function (e, coreData) {
	          if (!_this.state.dragging) return false;

	          // Short-circuit if user's callback killed it.
	          var shouldStop = _this.props.onStop(e, (0, _positionFns.createDraggableData)(_this, coreData));
	          if (shouldStop === false) return false;
	          (0, _log2["default"])('Draggable: onDragStop: %j', coreData);
	          var newState /*: $Shape<DraggableState>*/ = {
	            dragging: false,
	            slackX: 0,
	            slackY: 0
	          };

	          // If this is a controlled component, the result of this operation will be to
	          // revert back to the old position. We expect a handler on `onDragStop`, at the least.
	          var controlled = Boolean(_this.props.position);
	          if (controlled) {
	            var _this$props$position = _this.props.position,
	              _x2 = _this$props$position.x,
	              _y2 = _this$props$position.y;
	            newState.x = _x2;
	            newState.y = _y2;
	          }
	          _this.setState(newState);
	        };
	        _this.state = {
	          // Whether or not we are currently dragging.
	          dragging: false,
	          // Whether or not we have been dragged before.
	          dragged: false,
	          // Current transform x and y.
	          x: props.position ? props.position.x : props.defaultPosition.x,
	          y: props.position ? props.position.y : props.defaultPosition.y,
	          // Used for compensating for out-of-bounds drags
	          slackX: 0,
	          slackY: 0,
	          // Can only determine if SVG after mounting
	          isElementSVG: false
	        };
	        return _this;
	      }
	      _createClass(Draggable, [{
	        key: 'componentWillMount',
	        value: function componentWillMount() {
	          if (this.props.position && !(this.props.onDrag || this.props.onStop)) {
	            // eslint-disable-next-line
	            console.warn('A `position` was applied to this <Draggable>, without drag handlers. This will make this ' + 'component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the ' + '`position` of this element.');
	          }
	        }
	      }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	          // Check to see if the element passed is an instanceof SVGElement
	          if (typeof SVGElement !== 'undefined' && _reactDom2["default"].findDOMNode(this) instanceof SVGElement) {
	            this.setState({
	              isElementSVG: true
	            });
	          }
	        }
	      }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps(nextProps /*: Object*/) {
	          // Set x/y if position has changed
	          if (nextProps.position && (!this.props.position || nextProps.position.x !== this.props.position.x || nextProps.position.y !== this.props.position.y)) {
	            this.setState({
	              x: nextProps.position.x,
	              y: nextProps.position.y
	            });
	          }
	        }
	      }, {
	        key: 'componentWillUnmount',
	        value: function componentWillUnmount() {
	          this.setState({
	            dragging: false
	          }); // prevents invariant if unmounted while dragging
	        }
	      }, {
	        key: 'render',
	        value: function render() /*: React.Element<any>*/{
	          var _classNames;
	          var style = {},
	            svgTransform = null;

	          // If this is controlled, we don't want to move it - unless it's dragging.
	          var controlled = Boolean(this.props.position);
	          var draggable = !controlled || this.state.dragging;
	          var position = this.props.position || this.props.defaultPosition;
	          var transformOpts = {
	            // Set left if horizontal drag is enabled
	            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : position.x,
	            // Set top if vertical drag is enabled
	            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : position.y
	          };

	          // If this element was SVG, we use the `transform` attribute.
	          if (this.state.isElementSVG) {
	            svgTransform = (0, _domFns.createSVGTransform)(transformOpts);
	          } else {
	            // Add a CSS transform to move the element around. This allows us to move the element around
	            // without worrying about whether or not it is relatively or absolutely positioned.
	            // If the item you are dragging already has a transform set, wrap it in a <span> so <Draggable>
	            // has a clean slate.
	            style = (0, _domFns.createCSSTransform)(transformOpts);
	          }
	          var _props = this.props,
	            defaultClassName = _props.defaultClassName,
	            defaultClassNameDragging = _props.defaultClassNameDragging,
	            defaultClassNameDragged = _props.defaultClassNameDragged;

	          // Mark with class while dragging

	          var className = (0, _classnames2["default"])(this.props.children.props.className || '', defaultClassName, (_classNames = {}, _defineProperty(_classNames, defaultClassNameDragging, this.state.dragging), _defineProperty(_classNames, defaultClassNameDragged, this.state.dragged), _classNames));

	          // Reuse the child provided
	          // This makes it flexible to use whatever element is wanted (div, ul, etc)
	          return _react2["default"].createElement(_DraggableCore2["default"], _extends({}, this.props, {
	            onStart: this.onDragStart,
	            onDrag: this.onDrag,
	            onStop: this.onDragStop
	          }), _react2["default"].cloneElement(_react2["default"].Children.only(this.props.children), {
	            className: className,
	            style: _extends({}, this.props.children.props.style, style),
	            transform: svgTransform
	          }));
	        }
	      }]);
	      return Draggable;
	    }(_react2["default"].Component);
	    Draggable.displayName = 'Draggable';
	    Draggable.propTypes = _extends({}, _DraggableCore2["default"].propTypes, {
	      /**
	       * `axis` determines which axis the draggable can move.
	       *
	       *  Note that all callbacks will still return data as normal. This only
	       *  controls flushing to the DOM.
	       *
	       * 'both' allows movement horizontally and vertically.
	       * 'x' limits movement to horizontal axis.
	       * 'y' limits movement to vertical axis.
	       * 'none' limits all movement.
	       *
	       * Defaults to 'both'.
	       */
	      axis: _propTypes2["default"].oneOf(['both', 'x', 'y', 'none']),
	      /**
	       * `bounds` determines the range of movement available to the element.
	       * Available values are:
	       *
	       * 'parent' restricts movement within the Draggable's parent node.
	       *
	       * Alternatively, pass an object with the following properties, all of which are optional:
	       *
	       * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
	       *
	       * All values are in px.
	       *
	       * Example:
	       *
	       * ```jsx
	       *   let App = React.createClass({
	       *       render: function () {
	       *         return (
	       *            <Draggable bounds={{right: 300, bottom: 300}}>
	       *              <div>Content</div>
	       *           </Draggable>
	       *         );
	       *       }
	       *   });
	       * ```
	       */
	      bounds: _propTypes2["default"].oneOfType([_propTypes2["default"].shape({
	        left: _propTypes2["default"].number,
	        right: _propTypes2["default"].number,
	        top: _propTypes2["default"].number,
	        bottom: _propTypes2["default"].number
	      }), _propTypes2["default"].string, _propTypes2["default"].oneOf([false])]),
	      defaultClassName: _propTypes2["default"].string,
	      defaultClassNameDragging: _propTypes2["default"].string,
	      defaultClassNameDragged: _propTypes2["default"].string,
	      /**
	       * `defaultPosition` specifies the x and y that the dragged item should start at
	       *
	       * Example:
	       *
	       * ```jsx
	       *      let App = React.createClass({
	       *          render: function () {
	       *              return (
	       *                  <Draggable defaultPosition={{x: 25, y: 25}}>
	       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	       *                  </Draggable>
	       *              );
	       *          }
	       *      });
	       * ```
	       */
	      defaultPosition: _propTypes2["default"].shape({
	        x: _propTypes2["default"].number,
	        y: _propTypes2["default"].number
	      }),
	      /**
	       * `position`, if present, defines the current position of the element.
	       *
	       *  This is similar to how form elements in React work - if no `position` is supplied, the component
	       *  is uncontrolled.
	       *
	       * Example:
	       *
	       * ```jsx
	       *      let App = React.createClass({
	       *          render: function () {
	       *              return (
	       *                  <Draggable position={{x: 25, y: 25}}>
	       *                      <div>I start with transformX: 25px and transformY: 25px;</div>
	       *                  </Draggable>
	       *              );
	       *          }
	       *      });
	       * ```
	       */
	      position: _propTypes2["default"].shape({
	        x: _propTypes2["default"].number,
	        y: _propTypes2["default"].number
	      }),
	      /**
	       * These properties should be defined on the child, not here.
	       */
	      className: _shims.dontSetMe,
	      style: _shims.dontSetMe,
	      transform: _shims.dontSetMe
	    });
	    Draggable.defaultProps = _extends({}, _DraggableCore2["default"].defaultProps, {
	      axis: 'both',
	      bounds: false,
	      defaultClassName: 'react-draggable',
	      defaultClassNameDragging: 'react-draggable-dragging',
	      defaultClassNameDragged: 'react-draggable-dragged',
	      defaultPosition: {
	        x: 0,
	        y: 0
	      },
	      position: null
	    });
	    exports["default"] = Draggable;

	    /***/
	  }, /* 2 */
	  /***/function (module, exports) {
	    module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

	    /***/
	  }, /* 3 */
	  /***/function (module, exports, __webpack_require__) {
	    /**
	     * Copyright 2013-present, Facebook, Inc.
	     * All rights reserved.
	     *
	     * This source code is licensed under the BSD-style license found in the
	     * LICENSE file in the root directory of this source tree. An additional grant
	     * of patent rights can be found in the PATENTS file in the same directory.
	     */

	    {
	      var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol["for"] && Symbol["for"]('react.element') || 0xeac7;
	      var isValidElement = function isValidElement(object) {
	        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	      };

	      // By explicitly using `prop-types` you are opting into new development behavior.
	      // http://fb.me/prop-types-in-prod
	      var throwOnDirectAccess = true;
	      module.exports = __webpack_require__(4)(isValidElement, throwOnDirectAccess);
	    }

	    /***/
	  }, /* 4 */
	  /***/function (module, exports, __webpack_require__) {

	    var emptyFunction = __webpack_require__(5);
	    var invariant = __webpack_require__(6);
	    var warning = __webpack_require__(7);
	    var ReactPropTypesSecret = __webpack_require__(8);
	    var checkPropTypes = __webpack_require__(9);
	    module.exports = function (isValidElement, throwOnDirectAccess) {
	      /* global Symbol */
	      var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	      var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	      /**
	       * Returns the iterator method function contained on the iterable object.
	       *
	       * Be sure to invoke the function with the iterable as context:
	       *
	       *     var iteratorFn = getIteratorFn(myIterable);
	       *     if (iteratorFn) {
	       *       var iterator = iteratorFn.call(myIterable);
	       *       ...
	       *     }
	       *
	       * @param {?object} maybeIterable
	       * @return {?function}
	       */
	      function getIteratorFn(maybeIterable) {
	        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	        if (typeof iteratorFn === 'function') {
	          return iteratorFn;
	        }
	      }

	      /**
	       * Collection of methods that allow declaration and validation of props that are
	       * supplied to React components. Example usage:
	       *
	       *   var Props = require('ReactPropTypes');
	       *   var MyArticle = React.createClass({
	       *     propTypes: {
	       *       // An optional string prop named "description".
	       *       description: Props.string,
	       *
	       *       // A required enum prop named "category".
	       *       category: Props.oneOf(['News','Photos']).isRequired,
	       *
	       *       // A prop named "dialog" that requires an instance of Dialog.
	       *       dialog: Props.instanceOf(Dialog).isRequired
	       *     },
	       *     render: function() { ... }
	       *   });
	       *
	       * A more formal specification of how these methods are used:
	       *
	       *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	       *   decl := ReactPropTypes.{type}(.isRequired)?
	       *
	       * Each and every declaration produces a function with the same signature. This
	       * allows the creation of custom validation functions. For example:
	       *
	       *  var MyLink = React.createClass({
	       *    propTypes: {
	       *      // An optional string or URI prop named "href".
	       *      href: function(props, propName, componentName) {
	       *        var propValue = props[propName];
	       *        if (propValue != null && typeof propValue !== 'string' &&
	       *            !(propValue instanceof URI)) {
	       *          return new Error(
	       *            'Expected a string or an URI for ' + propName + ' in ' +
	       *            componentName
	       *          );
	       *        }
	       *      }
	       *    },
	       *    render: function() {...}
	       *  });
	       *
	       * @internal
	       */

	      var ANONYMOUS = '<<anonymous>>';

	      // Important!
	      // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	      var ReactPropTypes = {
	        array: createPrimitiveTypeChecker('array'),
	        bool: createPrimitiveTypeChecker('boolean'),
	        func: createPrimitiveTypeChecker('function'),
	        number: createPrimitiveTypeChecker('number'),
	        object: createPrimitiveTypeChecker('object'),
	        string: createPrimitiveTypeChecker('string'),
	        symbol: createPrimitiveTypeChecker('symbol'),
	        any: createAnyTypeChecker(),
	        arrayOf: createArrayOfTypeChecker,
	        element: createElementTypeChecker(),
	        instanceOf: createInstanceTypeChecker,
	        node: createNodeChecker(),
	        objectOf: createObjectOfTypeChecker,
	        oneOf: createEnumTypeChecker,
	        oneOfType: createUnionTypeChecker,
	        shape: createShapeTypeChecker
	      };

	      /**
	       * inlined Object.is polyfill to avoid requiring consumers ship their own
	       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	       */
	      /*eslint-disable no-self-compare*/
	      function is(x, y) {
	        // SameValue algorithm
	        if (x === y) {
	          // Steps 1-5, 7-10
	          // Steps 6.b-6.e: +0 != -0
	          return x !== 0 || 1 / x === 1 / y;
	        } else {
	          // Step 6.a: NaN == NaN
	          return x !== x && y !== y;
	        }
	      }
	      /*eslint-enable no-self-compare*/

	      /**
	       * We use an Error-like object for backward compatibility as people may call
	       * PropTypes directly and inspect their output. However, we don't use real
	       * Errors anymore. We don't inspect their stack anyway, and creating them
	       * is prohibitively expensive if they are created too often, such as what
	       * happens in oneOfType() for any type before the one that matched.
	       */
	      function PropTypeError(message) {
	        this.message = message;
	        this.stack = '';
	      }
	      // Make `instanceof Error` still work for returned errors.
	      PropTypeError.prototype = Error.prototype;
	      function createChainableTypeChecker(validate) {
	        {
	          var manualPropTypeCallCache = {};
	          var manualPropTypeWarningCount = 0;
	        }
	        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	          componentName = componentName || ANONYMOUS;
	          propFullName = propFullName || propName;
	          if (secret !== ReactPropTypesSecret) {
	            if (throwOnDirectAccess) {
	              // New behavior only for users of `prop-types` package
	              invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
	            } else if ( typeof console !== 'undefined') {
	              // Old behavior for people using React.PropTypes
	              var cacheKey = componentName + ':' + propName;
	              if (!manualPropTypeCallCache[cacheKey] &&
	              // Avoid spamming the console because they are often not actionable except for lib authors
	              manualPropTypeWarningCount < 3) {
	                warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
	                manualPropTypeCallCache[cacheKey] = true;
	                manualPropTypeWarningCount++;
	              }
	            }
	          }
	          if (props[propName] == null) {
	            if (isRequired) {
	              if (props[propName] === null) {
	                return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	              }
	              return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	            }
	            return null;
	          } else {
	            return validate(props, propName, componentName, location, propFullName);
	          }
	        }
	        var chainedCheckType = checkType.bind(null, false);
	        chainedCheckType.isRequired = checkType.bind(null, true);
	        return chainedCheckType;
	      }
	      function createPrimitiveTypeChecker(expectedType) {
	        function validate(props, propName, componentName, location, propFullName, secret) {
	          var propValue = props[propName];
	          var propType = getPropType(propValue);
	          if (propType !== expectedType) {
	            // `propValue` being instance of, say, date/regexp, pass the 'object'
	            // check, but we can offer a more precise error message here rather than
	            // 'of type `object`'.
	            var preciseType = getPreciseType(propValue);
	            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	          }
	          return null;
	        }
	        return createChainableTypeChecker(validate);
	      }
	      function createAnyTypeChecker() {
	        return createChainableTypeChecker(emptyFunction.thatReturnsNull);
	      }
	      function createArrayOfTypeChecker(typeChecker) {
	        function validate(props, propName, componentName, location, propFullName) {
	          if (typeof typeChecker !== 'function') {
	            return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	          }
	          var propValue = props[propName];
	          if (!Array.isArray(propValue)) {
	            var propType = getPropType(propValue);
	            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	          }
	          for (var i = 0; i < propValue.length; i++) {
	            var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	            if (error instanceof Error) {
	              return error;
	            }
	          }
	          return null;
	        }
	        return createChainableTypeChecker(validate);
	      }
	      function createElementTypeChecker() {
	        function validate(props, propName, componentName, location, propFullName) {
	          var propValue = props[propName];
	          if (!isValidElement(propValue)) {
	            var propType = getPropType(propValue);
	            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	          }
	          return null;
	        }
	        return createChainableTypeChecker(validate);
	      }
	      function createInstanceTypeChecker(expectedClass) {
	        function validate(props, propName, componentName, location, propFullName) {
	          if (!(props[propName] instanceof expectedClass)) {
	            var expectedClassName = expectedClass.name || ANONYMOUS;
	            var actualClassName = getClassName(props[propName]);
	            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	          }
	          return null;
	        }
	        return createChainableTypeChecker(validate);
	      }
	      function createEnumTypeChecker(expectedValues) {
	        if (!Array.isArray(expectedValues)) {
	           warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') ;
	          return emptyFunction.thatReturnsNull;
	        }
	        function validate(props, propName, componentName, location, propFullName) {
	          var propValue = props[propName];
	          for (var i = 0; i < expectedValues.length; i++) {
	            if (is(propValue, expectedValues[i])) {
	              return null;
	            }
	          }
	          var valuesString = JSON.stringify(expectedValues);
	          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	        }
	        return createChainableTypeChecker(validate);
	      }
	      function createObjectOfTypeChecker(typeChecker) {
	        function validate(props, propName, componentName, location, propFullName) {
	          if (typeof typeChecker !== 'function') {
	            return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	          }
	          var propValue = props[propName];
	          var propType = getPropType(propValue);
	          if (propType !== 'object') {
	            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	          }
	          for (var key in propValue) {
	            if (propValue.hasOwnProperty(key)) {
	              var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	              if (error instanceof Error) {
	                return error;
	              }
	            }
	          }
	          return null;
	        }
	        return createChainableTypeChecker(validate);
	      }
	      function createUnionTypeChecker(arrayOfTypeCheckers) {
	        if (!Array.isArray(arrayOfTypeCheckers)) {
	           warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') ;
	          return emptyFunction.thatReturnsNull;
	        }
	        function validate(props, propName, componentName, location, propFullName) {
	          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	            var checker = arrayOfTypeCheckers[i];
	            if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	              return null;
	            }
	          }
	          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	        }
	        return createChainableTypeChecker(validate);
	      }
	      function createNodeChecker() {
	        function validate(props, propName, componentName, location, propFullName) {
	          if (!isNode(props[propName])) {
	            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	          }
	          return null;
	        }
	        return createChainableTypeChecker(validate);
	      }
	      function createShapeTypeChecker(shapeTypes) {
	        function validate(props, propName, componentName, location, propFullName) {
	          var propValue = props[propName];
	          var propType = getPropType(propValue);
	          if (propType !== 'object') {
	            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	          }
	          for (var key in shapeTypes) {
	            var checker = shapeTypes[key];
	            if (!checker) {
	              continue;
	            }
	            var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	            if (error) {
	              return error;
	            }
	          }
	          return null;
	        }
	        return createChainableTypeChecker(validate);
	      }
	      function isNode(propValue) {
	        switch (typeof propValue) {
	          case 'number':
	          case 'string':
	          case 'undefined':
	            return true;
	          case 'boolean':
	            return !propValue;
	          case 'object':
	            if (Array.isArray(propValue)) {
	              return propValue.every(isNode);
	            }
	            if (propValue === null || isValidElement(propValue)) {
	              return true;
	            }
	            var iteratorFn = getIteratorFn(propValue);
	            if (iteratorFn) {
	              var iterator = iteratorFn.call(propValue);
	              var step;
	              if (iteratorFn !== propValue.entries) {
	                while (!(step = iterator.next()).done) {
	                  if (!isNode(step.value)) {
	                    return false;
	                  }
	                }
	              } else {
	                // Iterator will provide entry [k,v] tuples rather than values.
	                while (!(step = iterator.next()).done) {
	                  var entry = step.value;
	                  if (entry) {
	                    if (!isNode(entry[1])) {
	                      return false;
	                    }
	                  }
	                }
	              }
	            } else {
	              return false;
	            }
	            return true;
	          default:
	            return false;
	        }
	      }
	      function isSymbol(propType, propValue) {
	        // Native Symbol.
	        if (propType === 'symbol') {
	          return true;
	        }

	        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	        if (propValue['@@toStringTag'] === 'Symbol') {
	          return true;
	        }

	        // Fallback for non-spec compliant Symbols which are polyfilled.
	        if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	          return true;
	        }
	        return false;
	      }

	      // Equivalent of `typeof` but with special handling for array and regexp.
	      function getPropType(propValue) {
	        var propType = typeof propValue;
	        if (Array.isArray(propValue)) {
	          return 'array';
	        }
	        if (propValue instanceof RegExp) {
	          // Old webkits (at least until Android 4.0) return 'function' rather than
	          // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	          // passes PropTypes.object.
	          return 'object';
	        }
	        if (isSymbol(propType, propValue)) {
	          return 'symbol';
	        }
	        return propType;
	      }

	      // This handles more types than `getPropType`. Only used for error messages.
	      // See `createPrimitiveTypeChecker`.
	      function getPreciseType(propValue) {
	        var propType = getPropType(propValue);
	        if (propType === 'object') {
	          if (propValue instanceof Date) {
	            return 'date';
	          } else if (propValue instanceof RegExp) {
	            return 'regexp';
	          }
	        }
	        return propType;
	      }

	      // Returns class name of the object, if any.
	      function getClassName(propValue) {
	        if (!propValue.constructor || !propValue.constructor.name) {
	          return ANONYMOUS;
	        }
	        return propValue.constructor.name;
	      }
	      ReactPropTypes.checkPropTypes = checkPropTypes;
	      ReactPropTypes.PropTypes = ReactPropTypes;
	      return ReactPropTypes;
	    };

	    /***/
	  }, /* 5 */
	  /***/function (module, exports) {

	    /**
	     * Copyright (c) 2013-present, Facebook, Inc.
	     * All rights reserved.
	     *
	     * This source code is licensed under the BSD-style license found in the
	     * LICENSE file in the root directory of this source tree. An additional grant
	     * of patent rights can be found in the PATENTS file in the same directory.
	     *
	     * 
	     */
	    function makeEmptyFunction(arg) {
	      return function () {
	        return arg;
	      };
	    }

	    /**
	     * This function accepts and discards inputs; it has no side effects. This is
	     * primarily useful idiomatically for overridable function endpoints which
	     * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	     */
	    var emptyFunction = function emptyFunction() {};
	    emptyFunction.thatReturns = makeEmptyFunction;
	    emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	    emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	    emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	    emptyFunction.thatReturnsThis = function () {
	      return this;
	    };
	    emptyFunction.thatReturnsArgument = function (arg) {
	      return arg;
	    };
	    module.exports = emptyFunction;

	    /***/
	  }, /* 6 */
	  /***/function (module, exports, __webpack_require__) {

	    /**
	     * Use invariant() to assert state which your program assumes to be true.
	     *
	     * Provide sprintf-style format (only %s is supported) and arguments
	     * to provide information about what broke and what you were
	     * expecting.
	     *
	     * The invariant message will be stripped in production, but the invariant
	     * will remain to ensure logic does not differ in production.
	     */
	    var validateFormat = function validateFormat(format) {};
	    {
	      validateFormat = function validateFormat(format) {
	        if (format === undefined) {
	          throw new Error('invariant requires an error message argument');
	        }
	      };
	    }
	    function invariant(condition, format, a, b, c, d, e, f) {
	      validateFormat(format);
	      if (!condition) {
	        var error;
	        if (format === undefined) {
	          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	        } else {
	          var args = [a, b, c, d, e, f];
	          var argIndex = 0;
	          error = new Error(format.replace(/%s/g, function () {
	            return args[argIndex++];
	          }));
	          error.name = 'Invariant Violation';
	        }
	        error.framesToPop = 1; // we don't care about invariant's own frame
	        throw error;
	      }
	    }
	    module.exports = invariant;

	    /***/
	  }, /* 7 */
	  /***/function (module, exports, __webpack_require__) {

	    var emptyFunction = __webpack_require__(5);

	    /**
	     * Similar to invariant but only logs a warning if the condition is not met.
	     * This can be used to log issues in development environments in critical
	     * paths. Removing the logging code for production environments will keep the
	     * same logic and follow the same code paths.
	     */

	    var warning = emptyFunction;
	    {
	      (function () {
	        var printWarning = function printWarning(format) {
	          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            args[_key - 1] = arguments[_key];
	          }
	          var argIndex = 0;
	          var message = 'Warning: ' + format.replace(/%s/g, function () {
	            return args[argIndex++];
	          });
	          if (typeof console !== 'undefined') {
	            console.error(message);
	          }
	          try {
	            // --- Welcome to debugging React ---
	            // This error was thrown as a convenience so that you can use this stack
	            // to find the callsite that caused this warning to fire.
	            throw new Error(message);
	          } catch (x) {}
	        };
	        warning = function warning(condition, format) {
	          if (format === undefined) {
	            throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	          }
	          if (format.indexOf('Failed Composite propType: ') === 0) {
	            return; // Ignore CompositeComponent proptype check.
	          }
	          if (!condition) {
	            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	              args[_key2 - 2] = arguments[_key2];
	            }
	            printWarning.apply(undefined, [format].concat(args));
	          }
	        };
	      })();
	    }
	    module.exports = warning;

	    /***/
	  }, /* 8 */
	  /***/function (module, exports) {

	    var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	    module.exports = ReactPropTypesSecret;

	    /***/
	  }, /* 9 */
	  /***/function (module, exports, __webpack_require__) {

	    {
	      var invariant = __webpack_require__(6);
	      var warning = __webpack_require__(7);
	      var ReactPropTypesSecret = __webpack_require__(8);
	      var loggedTypeFailures = {};
	    }

	    /**
	     * Assert that the values match with the type specs.
	     * Error messages are memorized and will only be shown once.
	     *
	     * @param {object} typeSpecs Map of name to a ReactPropType
	     * @param {object} values Runtime values that need to be type-checked
	     * @param {string} location e.g. "prop", "context", "child context"
	     * @param {string} componentName Name of the component for error messages.
	     * @param {?Function} getStack Returns the component stack.
	     * @private
	     */
	    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	      {
	        for (var typeSpecName in typeSpecs) {
	          if (typeSpecs.hasOwnProperty(typeSpecName)) {
	            var error;
	            // Prop type validation may throw. In case they do, we don't want to
	            // fail the render phase where it didn't fail before. So we log it.
	            // After these have been cleaned up, we'll let them throw.
	            try {
	              // This is intentionally an invariant that gets caught. It's the same
	              // behavior as without this statement except with a better message.
	              invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
	              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	            } catch (ex) {
	              error = ex;
	            }
	            warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
	            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	              // Only monitor this failure once because there tends to be a lot of the
	              // same error.
	              loggedTypeFailures[error.message] = true;
	              var stack = getStack ? getStack() : '';
	              warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
	            }
	          }
	        }
	      }
	    }
	    module.exports = checkPropTypes;

	    /***/
	  }, /* 10 */
	  /***/function (module, exports, __webpack_require__) {

	    var emptyFunction = __webpack_require__(5);
	    var invariant = __webpack_require__(6);
	    module.exports = function () {
	      // Important!
	      // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	      function shim() {
	        invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
	      }
	      shim.isRequired = shim;
	      function getShim() {
	        return shim;
	      }
	      var ReactPropTypes = {
	        array: shim,
	        bool: shim,
	        func: shim,
	        number: shim,
	        object: shim,
	        string: shim,
	        symbol: shim,
	        any: shim,
	        arrayOf: getShim,
	        element: shim,
	        instanceOf: getShim,
	        node: shim,
	        objectOf: getShim,
	        oneOf: getShim,
	        oneOfType: getShim,
	        shape: getShim
	      };
	      ReactPropTypes.checkPropTypes = emptyFunction;
	      ReactPropTypes.PropTypes = ReactPropTypes;
	      return ReactPropTypes;
	    };

	    /***/
	  }, /* 11 */
	  /***/function (module, exports) {
	    module.exports = __WEBPACK_EXTERNAL_MODULE_11__;

	    /***/
	  }, /* 12 */
	  /***/function (module, exports, __webpack_require__) {
	    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; /*!
	                                                                     Copyright (c) 2016 Jed Watson.
	                                                                     Licensed under the MIT License (MIT), see
	                                                                     http://jedwatson.github.io/classnames
	                                                                     */
	    /* global define */

	    (function () {

	      var hasOwn = {}.hasOwnProperty;
	      function classNames() {
	        var classes = [];
	        for (var i = 0; i < arguments.length; i++) {
	          var arg = arguments[i];
	          if (!arg) continue;
	          var argType = typeof arg;
	          if (argType === 'string' || argType === 'number') {
	            classes.push(arg);
	          } else if (Array.isArray(arg)) {
	            classes.push(classNames.apply(null, arg));
	          } else if (argType === 'object') {
	            for (var key in arg) {
	              if (hasOwn.call(arg, key) && arg[key]) {
	                classes.push(key);
	              }
	            }
	          }
	        }
	        return classes.join(' ');
	      }
	      if (typeof module !== 'undefined' && module.exports) {
	        module.exports = classNames;
	      } else {
	        // register as 'classnames', consistent with npm package name
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	          return classNames;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	      }
	    })();

	    /***/
	  }, /* 13 */
	  /***/function (module, exports, __webpack_require__) {

	    Object.defineProperty(exports, "__esModule", {
	      value: true
	    });
	    var _extends = Object.assign || function (target) {
	      for (var i = 1; i < arguments.length; i++) {
	        var source = arguments[i];
	        for (var key in source) {
	          if (Object.prototype.hasOwnProperty.call(source, key)) {
	            target[key] = source[key];
	          }
	        }
	      }
	      return target;
	    };
	    exports.matchesSelector = matchesSelector;
	    exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
	    exports.addEvent = addEvent;
	    exports.removeEvent = removeEvent;
	    exports.outerHeight = outerHeight;
	    exports.outerWidth = outerWidth;
	    exports.innerHeight = innerHeight;
	    exports.innerWidth = innerWidth;
	    exports.offsetXYFromParent = offsetXYFromParent;
	    exports.createCSSTransform = createCSSTransform;
	    exports.createSVGTransform = createSVGTransform;
	    exports.getTouch = getTouch;
	    exports.getTouchIdentifier = getTouchIdentifier;
	    exports.addUserSelectStyles = addUserSelectStyles;
	    exports.removeUserSelectStyles = removeUserSelectStyles;
	    exports.styleHacks = styleHacks;
	    var _shims = __webpack_require__(14);
	    var _getPrefix = __webpack_require__(15);
	    var _getPrefix2 = _interopRequireDefault(_getPrefix);
	    function _interopRequireDefault(obj) {
	      return obj && obj.__esModule ? obj : {
	        "default": obj
	      };
	    }
	    function _defineProperty(obj, key, value) {
	      if (key in obj) {
	        Object.defineProperty(obj, key, {
	          value: value,
	          enumerable: true,
	          configurable: true,
	          writable: true
	        });
	      } else {
	        obj[key] = value;
	      }
	      return obj;
	    }

	    /*:: import type {ControlPosition} from './types';*/

	    var matchesSelectorFunc = '';
	    function matchesSelector(el /*: Node*/, selector /*: string*/) /*: boolean*/{
	      if (!matchesSelectorFunc) {
	        matchesSelectorFunc = (0, _shims.findInArray)(['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector'], function (method) {
	          // $FlowIgnore: Doesn't think elements are indexable
	          return (0, _shims.isFunction)(el[method]);
	        });
	      }

	      // $FlowIgnore: Doesn't think elements are indexable
	      return el[matchesSelectorFunc].call(el, selector);
	    }

	    // Works up the tree to the draggable itself attempting to match selector.
	    function matchesSelectorAndParentsTo(el /*: Node*/, selector /*: string*/, baseNode /*: Node*/) /*: boolean*/{
	      var node = el;
	      do {
	        if (matchesSelector(node, selector)) return true;
	        if (node === baseNode) return false;
	        node = node.parentNode;
	      } while (node);
	      return false;
	    }
	    function addEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/{
	      if (!el) {
	        return;
	      }
	      if (el.attachEvent) {
	        el.attachEvent('on' + event, handler);
	      } else if (el.addEventListener) {
	        el.addEventListener(event, handler, true);
	      } else {
	        // $FlowIgnore: Doesn't think elements are indexable
	        el['on' + event] = handler;
	      }
	    }
	    function removeEvent(el /*: ?Node*/, event /*: string*/, handler /*: Function*/) /*: void*/{
	      if (!el) {
	        return;
	      }
	      if (el.detachEvent) {
	        el.detachEvent('on' + event, handler);
	      } else if (el.removeEventListener) {
	        el.removeEventListener(event, handler, true);
	      } else {
	        // $FlowIgnore: Doesn't think elements are indexable
	        el['on' + event] = null;
	      }
	    }
	    function outerHeight(node /*: HTMLElement*/) /*: number*/{
	      // This is deliberately excluding margin for our calculations, since we are using
	      // offsetTop which is including margin. See getBoundPosition
	      var height = node.clientHeight;
	      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	      height += (0, _shims["int"])(computedStyle.borderTopWidth);
	      height += (0, _shims["int"])(computedStyle.borderBottomWidth);
	      return height;
	    }
	    function outerWidth(node /*: HTMLElement*/) /*: number*/{
	      // This is deliberately excluding margin for our calculations, since we are using
	      // offsetLeft which is including margin. See getBoundPosition
	      var width = node.clientWidth;
	      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	      width += (0, _shims["int"])(computedStyle.borderLeftWidth);
	      width += (0, _shims["int"])(computedStyle.borderRightWidth);
	      return width;
	    }
	    function innerHeight(node /*: HTMLElement*/) /*: number*/{
	      var height = node.clientHeight;
	      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	      height -= (0, _shims["int"])(computedStyle.paddingTop);
	      height -= (0, _shims["int"])(computedStyle.paddingBottom);
	      return height;
	    }
	    function innerWidth(node /*: HTMLElement*/) /*: number*/{
	      var width = node.clientWidth;
	      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
	      width -= (0, _shims["int"])(computedStyle.paddingLeft);
	      width -= (0, _shims["int"])(computedStyle.paddingRight);
	      return width;
	    }

	    // Get from offsetParent
	    function offsetXYFromParent(evt /*: {clientX: number, clientY: number}*/, offsetParent /*: HTMLElement*/) /*: ControlPosition*/{
	      var isBody = offsetParent === offsetParent.ownerDocument.body;
	      var offsetParentRect = isBody ? {
	        left: 0,
	        top: 0
	      } : offsetParent.getBoundingClientRect();
	      var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
	      var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;
	      return {
	        x: x,
	        y: y
	      };
	    }
	    function createCSSTransform(_ref) /*: Object*/{
	      var x = _ref.x,
	        y = _ref.y;

	      // Replace unitless items with px
	      return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)('transform', _getPrefix2["default"]), 'translate(' + x + 'px,' + y + 'px)');
	    }
	    function createSVGTransform(_ref3) /*: string*/{
	      var x = _ref3.x,
	        y = _ref3.y;
	      return 'translate(' + x + ',' + y + ')';
	    }
	    function getTouch(e /*: MouseTouchEvent*/, identifier /*: number*/) /*: ?{clientX: number, clientY: number}*/{
	      return e.targetTouches && (0, _shims.findInArray)(e.targetTouches, function (t) {
	        return identifier === t.identifier;
	      }) || e.changedTouches && (0, _shims.findInArray)(e.changedTouches, function (t) {
	        return identifier === t.identifier;
	      });
	    }
	    function getTouchIdentifier(e /*: MouseTouchEvent*/) /*: ?number*/{
	      if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
	      if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
	    }

	    // User-select Hacks:
	    //
	    // Useful for preventing blue highlights all over everything when dragging.
	    var userSelectPrefix = (0, _getPrefix.getPrefix)('user-select');
	    var userSelect = (0, _getPrefix.browserPrefixToStyle)('user-select', userSelectPrefix);
	    var userSelectStyle = ';' + userSelect + ': none;';
	    var userSelectReplaceRegExp = new RegExp(';?' + userSelect + ': none;'); // leading ; not present on IE

	    // Note we're passing `document` b/c we could be iframed
	    function addUserSelectStyles(body /*: HTMLElement*/) {
	      var style = body.getAttribute('style') || '';
	      if (userSelectReplaceRegExp.test(style)) return; // don't add twice
	      body.setAttribute('style', style + userSelectStyle);
	    }
	    function removeUserSelectStyles(body /*: HTMLElement*/) {
	      var style = body.getAttribute('style') || '';
	      body.setAttribute('style', style.replace(userSelectReplaceRegExp, ''));
	    }
	    function styleHacks() /*: Object*/{
	      var childStyle /*: Object*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      // Workaround IE pointer events; see #51
	      // https://github.com/mzabriskie/react-draggable/issues/51#issuecomment-103488278
	      return _extends({
	        touchAction: 'none'
	      }, childStyle);
	    }

	    /***/
	  }, /* 14 */
	  /***/function (module, exports) {

	    Object.defineProperty(exports, "__esModule", {
	      value: true
	    });
	    exports.findInArray = findInArray;
	    exports.isFunction = isFunction;
	    exports.isNum = isNum;
	    exports["int"] = _int;
	    exports.dontSetMe = dontSetMe;

	    // @credits https://gist.github.com/rogozhnikoff/a43cfed27c41e4e68cdc
	    function findInArray(array /*: Array<any> | TouchList*/, callback /*: Function*/) /*: any*/{
	      for (var i = 0, length = array.length; i < length; i++) {
	        if (callback.apply(callback, [array[i], i, array])) return array[i];
	      }
	    }
	    function isFunction(func /*: any*/) /*: boolean*/{
	      return typeof func === 'function' || Object.prototype.toString.call(func) === '[object Function]';
	    }
	    function isNum(num /*: any*/) /*: boolean*/{
	      return typeof num === 'number' && !isNaN(num);
	    }
	    function _int(a /*: string*/) /*: number*/{
	      return parseInt(a, 10);
	    }
	    function dontSetMe(props /*: Object*/, propName /*: string*/, componentName /*: string*/) {
	      if (props[propName]) {
	        return new Error('Invalid prop ' + propName + ' passed to ' + componentName + ' - do not set this, set it on the child.');
	      }
	    }

	    /***/
	  }, /* 15 */
	  /***/function (module, exports) {

	    Object.defineProperty(exports, "__esModule", {
	      value: true
	    });
	    exports.getPrefix = getPrefix;
	    exports.browserPrefixToKey = browserPrefixToKey;
	    exports.browserPrefixToStyle = browserPrefixToStyle;
	    var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
	    function getPrefix() /*: string*/{
	      var prop /*: string*/ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';

	      // Checking specifically for 'window.document' is for pseudo-browser server-side
	      // environments that define 'window' as the global context.
	      // E.g. React-rails (see https://github.com/reactjs/react-rails/pull/84)
	      if (typeof window === 'undefined' || typeof window.document === 'undefined') return '';
	      var style = window.document.documentElement.style;
	      if (prop in style) return '';
	      for (var i = 0; i < prefixes.length; i++) {
	        if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
	      }
	      return '';
	    }
	    function browserPrefixToKey(prop /*: string*/, prefix /*: string*/) /*: string*/{
	      return prefix ? '' + prefix + kebabToTitleCase(prop) : prop;
	    }
	    function browserPrefixToStyle(prop /*: string*/, prefix /*: string*/) /*: string*/{
	      return prefix ? '-' + prefix.toLowerCase() + '-' + prop : prop;
	    }
	    function kebabToTitleCase(str /*: string*/) /*: string*/{
	      var out = '';
	      var shouldCapitalize = true;
	      for (var i = 0; i < str.length; i++) {
	        if (shouldCapitalize) {
	          out += str[i].toUpperCase();
	          shouldCapitalize = false;
	        } else if (str[i] === '-') {
	          shouldCapitalize = true;
	        } else {
	          out += str[i];
	        }
	      }
	      return out;
	    }

	    // Default export is the prefix itself, like 'Moz', 'Webkit', etc
	    // Note that you may have to re-test for certain things; for instance, Chrome 50
	    // can handle unprefixed `transform`, but not unprefixed `user-select`
	    exports["default"] = getPrefix();

	    /***/
	  }, /* 16 */
	  /***/function (module, exports, __webpack_require__) {

	    Object.defineProperty(exports, "__esModule", {
	      value: true
	    });
	    exports.getBoundPosition = getBoundPosition;
	    exports.snapToGrid = snapToGrid;
	    exports.canDragX = canDragX;
	    exports.canDragY = canDragY;
	    exports.getControlPosition = getControlPosition;
	    exports.createCoreData = createCoreData;
	    exports.createDraggableData = createDraggableData;
	    var _shims = __webpack_require__(14);
	    var _reactDom = __webpack_require__(11);
	    var _reactDom2 = _interopRequireDefault(_reactDom);
	    var _domFns = __webpack_require__(13);
	    function _interopRequireDefault(obj) {
	      return obj && obj.__esModule ? obj : {
	        "default": obj
	      };
	    }

	    /*:: import type Draggable from '../Draggable';*/
	    /*:: import type {Bounds, ControlPosition, DraggableData} from './types';*/
	    /*:: import type DraggableCore from '../DraggableCore';*/
	    function getBoundPosition(draggable /*: Draggable*/, x /*: number*/, y /*: number*/) /*: [number, number]*/{
	      // If no bounds, short-circuit and move on
	      if (!draggable.props.bounds) return [x, y];

	      // Clone new bounds
	      var bounds = draggable.props.bounds;
	      bounds = typeof bounds === 'string' ? bounds : cloneBounds(bounds);
	      var node = _reactDom2["default"].findDOMNode(draggable);
	      if (typeof bounds === 'string') {
	        var ownerDocument = node.ownerDocument;
	        var ownerWindow = ownerDocument.defaultView;
	        var boundNode = void 0;
	        if (bounds === 'parent') {
	          boundNode = node.parentNode;
	        } else {
	          boundNode = ownerDocument.querySelector(bounds);
	          if (!boundNode) throw new Error('Bounds selector "' + bounds + '" could not find an element.');
	        }
	        var nodeStyle = ownerWindow.getComputedStyle(node);
	        var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);
	        // Compute bounds. This is a pain with padding and offsets but this gets it exactly right.
	        bounds = {
	          left: -node.offsetLeft + (0, _shims["int"])(boundNodeStyle.paddingLeft) + (0, _shims["int"])(nodeStyle.marginLeft),
	          top: -node.offsetTop + (0, _shims["int"])(boundNodeStyle.paddingTop) + (0, _shims["int"])(nodeStyle.marginTop),
	          right: (0, _domFns.innerWidth)(boundNode) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims["int"])(boundNodeStyle.paddingRight) - (0, _shims["int"])(nodeStyle.marginRight),
	          bottom: (0, _domFns.innerHeight)(boundNode) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims["int"])(boundNodeStyle.paddingBottom) - (0, _shims["int"])(nodeStyle.marginBottom)
	        };
	      }

	      // Keep x and y below right and bottom limits...
	      if ((0, _shims.isNum)(bounds.right)) x = Math.min(x, bounds.right);
	      if ((0, _shims.isNum)(bounds.bottom)) y = Math.min(y, bounds.bottom);

	      // But above left and top limits.
	      if ((0, _shims.isNum)(bounds.left)) x = Math.max(x, bounds.left);
	      if ((0, _shims.isNum)(bounds.top)) y = Math.max(y, bounds.top);
	      return [x, y];
	    }
	    function snapToGrid(grid /*: [number, number]*/, pendingX /*: number*/, pendingY /*: number*/) /*: [number, number]*/{
	      var x = Math.round(pendingX / grid[0]) * grid[0];
	      var y = Math.round(pendingY / grid[1]) * grid[1];
	      return [x, y];
	    }
	    function canDragX(draggable /*: Draggable*/) /*: boolean*/{
	      return draggable.props.axis === 'both' || draggable.props.axis === 'x';
	    }
	    function canDragY(draggable /*: Draggable*/) /*: boolean*/{
	      return draggable.props.axis === 'both' || draggable.props.axis === 'y';
	    }

	    // Get {x, y} positions from event.
	    function getControlPosition(e /*: MouseTouchEvent*/, touchIdentifier /*: ?number*/, draggableCore /*: DraggableCore*/) /*: ?ControlPosition*/{
	      var touchObj = typeof touchIdentifier === 'number' ? (0, _domFns.getTouch)(e, touchIdentifier) : null;
	      if (typeof touchIdentifier === 'number' && !touchObj) return null; // not the right touch
	      var node = _reactDom2["default"].findDOMNode(draggableCore);
	      // User can provide an offsetParent if desired.
	      var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
	      return (0, _domFns.offsetXYFromParent)(touchObj || e, offsetParent);
	    }

	    // Create an data object exposed by <DraggableCore>'s events
	    function createCoreData(draggable /*: DraggableCore*/, x /*: number*/, y /*: number*/) /*: DraggableData*/{
	      var state = draggable.state;
	      var isStart = !(0, _shims.isNum)(state.lastX);
	      if (isStart) {
	        // If this is our first move, use the x and y as last coords.
	        return {
	          node: _reactDom2["default"].findDOMNode(draggable),
	          deltaX: 0,
	          deltaY: 0,
	          lastX: x,
	          lastY: y,
	          x: x,
	          y: y
	        };
	      } else {
	        // Otherwise calculate proper values.
	        return {
	          node: _reactDom2["default"].findDOMNode(draggable),
	          deltaX: x - state.lastX,
	          deltaY: y - state.lastY,
	          lastX: state.lastX,
	          lastY: state.lastY,
	          x: x,
	          y: y
	        };
	      }
	    }

	    // Create an data exposed by <Draggable>'s events
	    function createDraggableData(draggable /*: Draggable*/, coreData /*: DraggableData*/) /*: DraggableData*/{
	      return {
	        node: coreData.node,
	        x: draggable.state.x + coreData.deltaX,
	        y: draggable.state.y + coreData.deltaY,
	        deltaX: coreData.deltaX,
	        deltaY: coreData.deltaY,
	        lastX: draggable.state.x,
	        lastY: draggable.state.y
	      };
	    }

	    // A lot faster than stringify/parse
	    function cloneBounds(bounds /*: Bounds*/) /*: Bounds*/{
	      return {
	        left: bounds.left,
	        top: bounds.top,
	        right: bounds.right,
	        bottom: bounds.bottom
	      };
	    }

	    /***/
	  }, /* 17 */
	  /***/function (module, exports, __webpack_require__) {
	    /* WEBPACK VAR INJECTION */(function (process) {

	      Object.defineProperty(exports, "__esModule", {
	        value: true
	      });
	      var _slicedToArray = function () {
	        function sliceIterator(arr, i) {
	          var _arr = [];
	          var _n = true;
	          var _d = false;
	          var _e = undefined;
	          try {
	            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	              _arr.push(_s.value);
	              if (i && _arr.length === i) break;
	            }
	          } catch (err) {
	            _d = true;
	            _e = err;
	          } finally {
	            try {
	              if (!_n && _i["return"]) _i["return"]();
	            } finally {
	              if (_d) throw _e;
	            }
	          }
	          return _arr;
	        }
	        return function (arr, i) {
	          if (Array.isArray(arr)) {
	            return arr;
	          } else if (Symbol.iterator in Object(arr)) {
	            return sliceIterator(arr, i);
	          } else {
	            throw new TypeError("Invalid attempt to destructure non-iterable instance");
	          }
	        };
	      }();
	      var _createClass = function () {
	        function defineProperties(target, props) {
	          for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];
	            descriptor.enumerable = descriptor.enumerable || false;
	            descriptor.configurable = true;
	            if ("value" in descriptor) descriptor.writable = true;
	            Object.defineProperty(target, descriptor.key, descriptor);
	          }
	        }
	        return function (Constructor, protoProps, staticProps) {
	          if (protoProps) defineProperties(Constructor.prototype, protoProps);
	          if (staticProps) defineProperties(Constructor, staticProps);
	          return Constructor;
	        };
	      }();
	      var _react = __webpack_require__(2);
	      var _react2 = _interopRequireDefault(_react);
	      var _propTypes = __webpack_require__(3);
	      var _propTypes2 = _interopRequireDefault(_propTypes);
	      var _reactDom = __webpack_require__(11);
	      var _reactDom2 = _interopRequireDefault(_reactDom);
	      var _domFns = __webpack_require__(13);
	      var _positionFns = __webpack_require__(16);
	      var _shims = __webpack_require__(14);
	      var _log = __webpack_require__(19);
	      var _log2 = _interopRequireDefault(_log);
	      function _interopRequireDefault(obj) {
	        return obj && obj.__esModule ? obj : {
	          "default": obj
	        };
	      }
	      function _classCallCheck(instance, Constructor) {
	        if (!(instance instanceof Constructor)) {
	          throw new TypeError("Cannot call a class as a function");
	        }
	      }
	      function _possibleConstructorReturn(self, call) {
	        if (!self) {
	          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	        }
	        return call && (typeof call === "object" || typeof call === "function") ? call : self;
	      }
	      function _inherits(subClass, superClass) {
	        if (typeof superClass !== "function" && superClass !== null) {
	          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	        }
	        subClass.prototype = Object.create(superClass && superClass.prototype, {
	          constructor: {
	            value: subClass,
	            enumerable: false,
	            writable: true,
	            configurable: true
	          }
	        });
	        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	      }

	      // Simple abstraction for dragging events names.
	      /*:: import type {EventHandler} from './utils/types';*/
	      var eventsFor = {
	        touch: {
	          start: 'touchstart',
	          move: 'touchmove',
	          stop: 'touchend'
	        },
	        mouse: {
	          start: 'mousedown',
	          move: 'mousemove',
	          stop: 'mouseup'
	        }
	      };

	      // Default to mouse events.
	      var dragEventFor = eventsFor.mouse;

	      //
	      // Define <DraggableCore>.
	      //
	      // <DraggableCore> is for advanced usage of <Draggable>. It maintains minimal internal state so it can
	      // work well with libraries that require more control over the element.
	      //

	      /*:: type CoreState = {
	        dragging: boolean,
	        lastX: number,
	        lastY: number,
	        touchIdentifier: ?number
	      };*/

	      var DraggableCore = function (_React$Component) {
	        _inherits(DraggableCore, _React$Component);
	        function DraggableCore() {
	          var _ref;
	          var _temp, _this, _ret;
	          _classCallCheck(this, DraggableCore);
	          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	          }
	          return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = DraggableCore.__proto__ || Object.getPrototypeOf(DraggableCore)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
	            dragging: false,
	            // Used while dragging to determine deltas.
	            lastX: NaN,
	            lastY: NaN,
	            touchIdentifier: null
	          }, _this.handleDragStart = function (e) {
	            // Make it possible to attach event handlers on top of this one.
	            _this.props.onMouseDown(e);

	            // Only accept left-clicks.
	            if (!_this.props.allowAnyClick && typeof e.button === 'number' && e.button !== 0) return false;

	            // Get nodes. Be sure to grab relative document (could be iframed)
	            var domNode = _reactDom2["default"].findDOMNode(_this);
	            var ownerDocument = domNode.ownerDocument;

	            // Short circuit if handle or cancel prop was provided and selector doesn't match.

	            if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.handle, domNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e.target, _this.props.cancel, domNode)) {
	              return;
	            }

	            // Set touch identifier in component state if this is a touch event. This allows us to
	            // distinguish between individual touches on multitouch screens by identifying which
	            // touchpoint was set to this element.
	            var touchIdentifier = (0, _domFns.getTouchIdentifier)(e);
	            _this.setState({
	              touchIdentifier: touchIdentifier
	            });

	            // Get the current drag point from the event. This is used as the offset.
	            var position = (0, _positionFns.getControlPosition)(e, touchIdentifier, _this);
	            if (position == null) return; // not possible but satisfies flow
	            var x = position.x,
	              y = position.y;

	            // Create an event object with all the data parents need to make a decision here.

	            var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	            (0, _log2["default"])('DraggableCore: handleDragStart: %j', coreEvent);

	            // Call event handler. If it returns explicit false, cancel.
	            (0, _log2["default"])('calling', _this.props.onStart);
	            var shouldUpdate = _this.props.onStart(e, coreEvent);
	            if (shouldUpdate === false) return;

	            // Add a style to the body to disable user-select. This prevents text from
	            // being selected all over the page.
	            if (_this.props.enableUserSelectHack) (0, _domFns.addUserSelectStyles)(ownerDocument.body);

	            // Initiate dragging. Set the current x and y as offsets
	            // so we know how much we've moved during the drag. This allows us
	            // to drag elements around even if they have been moved, without issue.
	            _this.setState({
	              dragging: true,
	              lastX: x,
	              lastY: y
	            });

	            // Add events to the document directly so we catch when the user's mouse/touch moves outside of
	            // this element. We use different events depending on whether or not we have detected that this
	            // is a touch-capable device.
	            (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
	            (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
	          }, _this.handleDrag = function (e) {
	            // Prevent scrolling on mobile devices, like ipad/iphone.
	            if (e.type === 'touchmove') e.preventDefault();

	            // Get the current drag point from the event. This is used as the offset.
	            var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
	            if (position == null) return;
	            var x = position.x,
	              y = position.y;

	            // Snap to grid if prop has been provided

	            if (Array.isArray(_this.props.grid)) {
	              var deltaX = x - _this.state.lastX,
	                deltaY = y - _this.state.lastY;
	              var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);
	              var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);
	              deltaX = _snapToGrid2[0];
	              deltaY = _snapToGrid2[1];
	              if (!deltaX && !deltaY) return; // skip useless drag
	              x = _this.state.lastX + deltaX, y = _this.state.lastY + deltaY;
	            }
	            var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	            (0, _log2["default"])('DraggableCore: handleDrag: %j', coreEvent);

	            // Call event handler. If it returns explicit false, trigger end.
	            var shouldUpdate = _this.props.onDrag(e, coreEvent);
	            if (shouldUpdate === false) {
	              try {
	                // $FlowIgnore
	                _this.handleDragStop(new MouseEvent('mouseup'));
	              } catch (err) {
	                // Old browsers
	                var event = document.createEvent('MouseEvents') /*: any*/ /*: MouseTouchEvent*/;
	                // I see why this insanity was deprecated
	                // $FlowIgnore
	                event.initMouseEvent('mouseup', true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
	                _this.handleDragStop(event);
	              }
	              return;
	            }
	            _this.setState({
	              lastX: x,
	              lastY: y
	            });
	          }, _this.handleDragStop = function (e) {
	            if (!_this.state.dragging) return;
	            var position = (0, _positionFns.getControlPosition)(e, _this.state.touchIdentifier, _this);
	            if (position == null) return;
	            var x = position.x,
	              y = position.y;
	            var coreEvent = (0, _positionFns.createCoreData)(_this, x, y);
	            var _ReactDOM$findDOMNode = _reactDom2["default"].findDOMNode(_this),
	              ownerDocument = _ReactDOM$findDOMNode.ownerDocument;

	            // Remove user-select hack

	            if (_this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument.body);
	            (0, _log2["default"])('DraggableCore: handleDragStop: %j', coreEvent);

	            // Reset the el.
	            _this.setState({
	              dragging: false,
	              lastX: NaN,
	              lastY: NaN
	            });

	            // Call event handler
	            _this.props.onStop(e, coreEvent);

	            // Remove event handlers
	            (0, _log2["default"])('DraggableCore: Removing handlers');
	            (0, _domFns.removeEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
	            (0, _domFns.removeEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
	          }, _this.onMouseDown = function (e) {
	            dragEventFor = eventsFor.mouse; // on touchscreen laptops we could switch back to mouse

	            return _this.handleDragStart(e);
	          }, _this.onMouseUp = function (e) {
	            dragEventFor = eventsFor.mouse;
	            return _this.handleDragStop(e);
	          }, _this.onTouchStart = function (e) {
	            // We're on a touch device now, so change the event handlers
	            dragEventFor = eventsFor.touch;
	            return _this.handleDragStart(e);
	          }, _this.onTouchEnd = function (e) {
	            // We're on a touch device now, so change the event handlers
	            dragEventFor = eventsFor.touch;
	            return _this.handleDragStop(e);
	          }, _temp), _possibleConstructorReturn(_this, _ret);
	        }
	        _createClass(DraggableCore, [{
	          key: 'componentWillUnmount',
	          value: function componentWillUnmount() {
	            // Remove any leftover event handlers. Remove both touch and mouse handlers in case
	            // some browser quirk caused a touch event to fire during a mouse move, or vice versa.
	            var _ReactDOM$findDOMNode2 = _reactDom2["default"].findDOMNode(this),
	              ownerDocument = _ReactDOM$findDOMNode2.ownerDocument;
	            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
	            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
	            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
	            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
	            if (this.props.enableUserSelectHack) (0, _domFns.removeUserSelectStyles)(ownerDocument.body);
	          }

	          // Same as onMouseDown (start drag), but now consider this a touch device.
	        }, {
	          key: 'render',
	          value: function render() /*: React.Element<any>*/{
	            // Reuse the child provided
	            // This makes it flexible to use whatever element is wanted (div, ul, etc)
	            return _react2["default"].cloneElement(_react2["default"].Children.only(this.props.children), {
	              style: (0, _domFns.styleHacks)(this.props.children.props.style),
	              // Note: mouseMove handler is attached to document so it will still function
	              // when the user drags quickly and leaves the bounds of the element.
	              onMouseDown: this.onMouseDown,
	              onTouchStart: this.onTouchStart,
	              onMouseUp: this.onMouseUp,
	              onTouchEnd: this.onTouchEnd
	            });
	          }
	        }]);
	        return DraggableCore;
	      }(_react2["default"].Component);
	      DraggableCore.displayName = 'DraggableCore';
	      DraggableCore.propTypes = {
	        /**
	         * `allowAnyClick` allows dragging using any mouse button.
	         * By default, we only accept the left button.
	         *
	         * Defaults to `false`.
	         */
	        allowAnyClick: _propTypes2["default"].bool,
	        /**
	         * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
	         * with the exception of `onMouseDown`, will not fire.
	         */
	        disabled: _propTypes2["default"].bool,
	        /**
	         * By default, we add 'user-select:none' attributes to the document body
	         * to prevent ugly text selection during drag. If this is causing problems
	         * for your app, set this to `false`.
	         */
	        enableUserSelectHack: _propTypes2["default"].bool,
	        /**
	         * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
	         * instead of using the parent node.
	         */
	        offsetParent: function offsetParent(props, propName) {
	          if (process.browser && props[propName] && props[propName].nodeType !== 1) {
	            throw new Error('Draggable\'s offsetParent must be a DOM Node.');
	          }
	        },
	        /**
	         * `grid` specifies the x and y that dragging should snap to.
	         */
	        grid: _propTypes2["default"].arrayOf(_propTypes2["default"].number),
	        /**
	         * `handle` specifies a selector to be used as the handle that initiates drag.
	         *
	         * Example:
	         *
	         * ```jsx
	         *   let App = React.createClass({
	         *       render: function () {
	         *         return (
	         *            <Draggable handle=".handle">
	         *              <div>
	         *                  <div className="handle">Click me to drag</div>
	         *                  <div>This is some other content</div>
	         *              </div>
	         *           </Draggable>
	         *         );
	         *       }
	         *   });
	         * ```
	         */
	        handle: _propTypes2["default"].string,
	        /**
	         * `cancel` specifies a selector to be used to prevent drag initialization.
	         *
	         * Example:
	         *
	         * ```jsx
	         *   let App = React.createClass({
	         *       render: function () {
	         *           return(
	         *               <Draggable cancel=".cancel">
	         *                   <div>
	         *                     <div className="cancel">You can't drag from here</div>
	         *                     <div>Dragging here works fine</div>
	         *                   </div>
	         *               </Draggable>
	         *           );
	         *       }
	         *   });
	         * ```
	         */
	        cancel: _propTypes2["default"].string,
	        /**
	         * Called when dragging starts.
	         * If this function returns the boolean false, dragging will be canceled.
	         */
	        onStart: _propTypes2["default"].func,
	        /**
	         * Called while dragging.
	         * If this function returns the boolean false, dragging will be canceled.
	         */
	        onDrag: _propTypes2["default"].func,
	        /**
	         * Called when dragging stops.
	         * If this function returns the boolean false, the drag will remain active.
	         */
	        onStop: _propTypes2["default"].func,
	        /**
	         * A workaround option which can be passed if onMouseDown needs to be accessed,
	         * since it'll always be blocked (as there is internal use of onMouseDown)
	         */
	        onMouseDown: _propTypes2["default"].func,
	        /**
	         * These properties should be defined on the child, not here.
	         */
	        className: _shims.dontSetMe,
	        style: _shims.dontSetMe,
	        transform: _shims.dontSetMe
	      };
	      DraggableCore.defaultProps = {
	        allowAnyClick: false,
	        // by default only accept left click
	        cancel: null,
	        disabled: false,
	        enableUserSelectHack: true,
	        offsetParent: null,
	        handle: null,
	        grid: null,
	        transform: null,
	        onStart: function onStart() {},
	        onDrag: function onDrag() {},
	        onStop: function onStop() {},
	        onMouseDown: function onMouseDown() {}
	      };
	      exports["default"] = DraggableCore;
	      /* WEBPACK VAR INJECTION */
	    }).call(exports, __webpack_require__(18));

	    /***/
	  }, /* 18 */
	  /***/function (module, exports) {
	    // shim for using process in browser
	    var process = module.exports = {};

	    // cached from whatever global is present so that test runners that stub it
	    // don't break things.  But we need to wrap it in a try catch in case it is
	    // wrapped in strict mode code which doesn't define any globals.  It's inside a
	    // function because try/catches deoptimize in certain engines.

	    var cachedSetTimeout;
	    var cachedClearTimeout;
	    function defaultSetTimout() {
	      throw new Error('setTimeout has not been defined');
	    }
	    function defaultClearTimeout() {
	      throw new Error('clearTimeout has not been defined');
	    }
	    (function () {
	      try {
	        if (typeof setTimeout === 'function') {
	          cachedSetTimeout = setTimeout;
	        } else {
	          cachedSetTimeout = defaultSetTimout;
	        }
	      } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	      }
	      try {
	        if (typeof clearTimeout === 'function') {
	          cachedClearTimeout = clearTimeout;
	        } else {
	          cachedClearTimeout = defaultClearTimeout;
	        }
	      } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	      }
	    })();
	    function runTimeout(fun) {
	      if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	      }
	      // if setTimeout wasn't available but was latter defined
	      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	      }
	      try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	      } catch (e) {
	        try {
	          // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	          return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	          return cachedSetTimeout.call(this, fun, 0);
	        }
	      }
	    }
	    function runClearTimeout(marker) {
	      if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	      }
	      // if clearTimeout wasn't available but was latter defined
	      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	      }
	      try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	      } catch (e) {
	        try {
	          // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	          return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	          // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	          return cachedClearTimeout.call(this, marker);
	        }
	      }
	    }
	    var queue = [];
	    var draining = false;
	    var currentQueue;
	    var queueIndex = -1;
	    function cleanUpNextTick() {
	      if (!draining || !currentQueue) {
	        return;
	      }
	      draining = false;
	      if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	      } else {
	        queueIndex = -1;
	      }
	      if (queue.length) {
	        drainQueue();
	      }
	    }
	    function drainQueue() {
	      if (draining) {
	        return;
	      }
	      var timeout = runTimeout(cleanUpNextTick);
	      draining = true;
	      var len = queue.length;
	      while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	          if (currentQueue) {
	            currentQueue[queueIndex].run();
	          }
	        }
	        queueIndex = -1;
	        len = queue.length;
	      }
	      currentQueue = null;
	      draining = false;
	      runClearTimeout(timeout);
	    }
	    process.nextTick = function (fun) {
	      var args = new Array(arguments.length - 1);
	      if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	          args[i - 1] = arguments[i];
	        }
	      }
	      queue.push(new Item(fun, args));
	      if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	      }
	    };

	    // v8 likes predictible objects
	    function Item(fun, array) {
	      this.fun = fun;
	      this.array = array;
	    }
	    Item.prototype.run = function () {
	      this.fun.apply(null, this.array);
	    };
	    process.title = 'browser';
	    process.browser = true;
	    process.env = {};
	    process.argv = [];
	    process.version = ''; // empty string to avoid regexp issues
	    process.versions = {};
	    function noop() {}
	    process.on = noop;
	    process.addListener = noop;
	    process.once = noop;
	    process.off = noop;
	    process.removeListener = noop;
	    process.removeAllListeners = noop;
	    process.emit = noop;
	    process.binding = function (name) {
	      throw new Error('process.binding is not supported');
	    };
	    process.cwd = function () {
	      return '/';
	    };
	    process.chdir = function (dir) {
	      throw new Error('process.chdir is not supported');
	    };
	    process.umask = function () {
	      return 0;
	    };

	    /***/
	  }, /* 19 */
	  /***/function (module, exports, __webpack_require__) {

	    Object.defineProperty(exports, "__esModule", {
	      value: true
	    });
	    exports["default"] = log;

	    /*eslint no-console:0*/
	    function log() {
	    }

	    /***/
	  }
	  /******/]);
	});
	});

	var reactDraggable$1 = unwrapExports(reactDraggable);
	var reactDraggable_1 = reactDraggable.DraggableCore;

	/**
	 * A collection of shims that provide minimal functionality of the ES6 collections.
	 *
	 * These implementations are not meant to be used outside of the ResizeObserver
	 * modules as they cover only a limited range of use cases.
	 */
	/* eslint-disable require-jsdoc, valid-jsdoc */
	var MapShim = function () {
	  if (typeof Map !== 'undefined') {
	    return Map;
	  }
	  /**
	   * Returns index in provided array that matches the specified key.
	   *
	   * @param {Array<Array>} arr
	   * @param {*} key
	   * @returns {number}
	   */
	  function getIndex(arr, key) {
	    var result = -1;
	    arr.some(function (entry, index) {
	      if (entry[0] === key) {
	        result = index;
	        return true;
	      }
	      return false;
	    });
	    return result;
	  }
	  return /** @class */function () {
	    function class_1() {
	      this.__entries__ = [];
	    }
	    Object.defineProperty(class_1.prototype, "size", {
	      /**
	       * @returns {boolean}
	       */
	      get: function get() {
	        return this.__entries__.length;
	      },
	      enumerable: true,
	      configurable: true
	    });
	    /**
	     * @param {*} key
	     * @returns {*}
	     */
	    class_1.prototype.get = function (key) {
	      var index = getIndex(this.__entries__, key);
	      var entry = this.__entries__[index];
	      return entry && entry[1];
	    };
	    /**
	     * @param {*} key
	     * @param {*} value
	     * @returns {void}
	     */
	    class_1.prototype.set = function (key, value) {
	      var index = getIndex(this.__entries__, key);
	      if (~index) {
	        this.__entries__[index][1] = value;
	      } else {
	        this.__entries__.push([key, value]);
	      }
	    };
	    /**
	     * @param {*} key
	     * @returns {void}
	     */
	    class_1.prototype["delete"] = function (key) {
	      var entries = this.__entries__;
	      var index = getIndex(entries, key);
	      if (~index) {
	        entries.splice(index, 1);
	      }
	    };
	    /**
	     * @param {*} key
	     * @returns {void}
	     */
	    class_1.prototype.has = function (key) {
	      return !!~getIndex(this.__entries__, key);
	    };
	    /**
	     * @returns {void}
	     */
	    class_1.prototype.clear = function () {
	      this.__entries__.splice(0);
	    };
	    /**
	     * @param {Function} callback
	     * @param {*} [ctx=null]
	     * @returns {void}
	     */
	    class_1.prototype.forEach = function (callback, ctx) {
	      if (ctx === void 0) {
	        ctx = null;
	      }
	      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
	        var entry = _a[_i];
	        callback.call(ctx, entry[1], entry[0]);
	      }
	    };
	    return class_1;
	  }();
	}();

	/**
	 * Detects whether window and document objects are available in current environment.
	 */
	var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

	// Returns global object of a current environment.
	var global$1 = function () {
	  if (typeof global !== 'undefined' && global.Math === Math) {
	    return global;
	  }
	  if (typeof self !== 'undefined' && self.Math === Math) {
	    return self;
	  }
	  if (typeof window !== 'undefined' && window.Math === Math) {
	    return window;
	  }
	  // eslint-disable-next-line no-new-func
	  return Function('return this')();
	}();

	/**
	 * A shim for the requestAnimationFrame which falls back to the setTimeout if
	 * first one is not supported.
	 *
	 * @returns {number} Requests' identifier.
	 */
	var requestAnimationFrame$1 = function () {
	  if (typeof requestAnimationFrame === 'function') {
	    // It's required to use a bounded function because IE sometimes throws
	    // an "Invalid calling object" error if rAF is invoked without the global
	    // object on the left hand side.
	    return requestAnimationFrame.bind(global$1);
	  }
	  return function (callback) {
	    return setTimeout(function () {
	      return callback(Date.now());
	    }, 1000 / 60);
	  };
	}();

	// Defines minimum timeout before adding a trailing call.
	var trailingTimeout = 2;
	/**
	 * Creates a wrapper function which ensures that provided callback will be
	 * invoked only once during the specified delay period.
	 *
	 * @param {Function} callback - Function to be invoked after the delay period.
	 * @param {number} delay - Delay after which to invoke callback.
	 * @returns {Function}
	 */
	function throttle(callback, delay) {
	  var leadingCall = false,
	    trailingCall = false,
	    lastCallTime = 0;
	  /**
	   * Invokes the original callback function and schedules new invocation if
	   * the "proxy" was called during current request.
	   *
	   * @returns {void}
	   */
	  function resolvePending() {
	    if (leadingCall) {
	      leadingCall = false;
	      callback();
	    }
	    if (trailingCall) {
	      proxy();
	    }
	  }
	  /**
	   * Callback invoked after the specified delay. It will further postpone
	   * invocation of the original function delegating it to the
	   * requestAnimationFrame.
	   *
	   * @returns {void}
	   */
	  function timeoutCallback() {
	    requestAnimationFrame$1(resolvePending);
	  }
	  /**
	   * Schedules invocation of the original function.
	   *
	   * @returns {void}
	   */
	  function proxy() {
	    var timeStamp = Date.now();
	    if (leadingCall) {
	      // Reject immediately following calls.
	      if (timeStamp - lastCallTime < trailingTimeout) {
	        return;
	      }
	      // Schedule new call to be in invoked when the pending one is resolved.
	      // This is important for "transitions" which never actually start
	      // immediately so there is a chance that we might miss one if change
	      // happens amids the pending invocation.
	      trailingCall = true;
	    } else {
	      leadingCall = true;
	      trailingCall = false;
	      setTimeout(timeoutCallback, delay);
	    }
	    lastCallTime = timeStamp;
	  }
	  return proxy;
	}

	// Minimum delay before invoking the update of observers.
	var REFRESH_DELAY = 20;
	// A list of substrings of CSS properties used to find transition events that
	// might affect dimensions of observed elements.
	var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
	// Check if MutationObserver is available.
	var mutationObserverSupported = typeof MutationObserver !== 'undefined';
	/**
	 * Singleton controller class which handles updates of ResizeObserver instances.
	 */
	var ResizeObserverController = /** @class */function () {
	  /**
	   * Creates a new instance of ResizeObserverController.
	   *
	   * @private
	   */
	  function ResizeObserverController() {
	    /**
	     * Indicates whether DOM listeners have been added.
	     *
	     * @private {boolean}
	     */
	    this.connected_ = false;
	    /**
	     * Tells that controller has subscribed for Mutation Events.
	     *
	     * @private {boolean}
	     */
	    this.mutationEventsAdded_ = false;
	    /**
	     * Keeps reference to the instance of MutationObserver.
	     *
	     * @private {MutationObserver}
	     */
	    this.mutationsObserver_ = null;
	    /**
	     * A list of connected observers.
	     *
	     * @private {Array<ResizeObserverSPI>}
	     */
	    this.observers_ = [];
	    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
	    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
	  }
	  /**
	   * Adds observer to observers list.
	   *
	   * @param {ResizeObserverSPI} observer - Observer to be added.
	   * @returns {void}
	   */
	  ResizeObserverController.prototype.addObserver = function (observer) {
	    if (!~this.observers_.indexOf(observer)) {
	      this.observers_.push(observer);
	    }
	    // Add listeners if they haven't been added yet.
	    if (!this.connected_) {
	      this.connect_();
	    }
	  };
	  /**
	   * Removes observer from observers list.
	   *
	   * @param {ResizeObserverSPI} observer - Observer to be removed.
	   * @returns {void}
	   */
	  ResizeObserverController.prototype.removeObserver = function (observer) {
	    var observers = this.observers_;
	    var index = observers.indexOf(observer);
	    // Remove observer if it's present in registry.
	    if (~index) {
	      observers.splice(index, 1);
	    }
	    // Remove listeners if controller has no connected observers.
	    if (!observers.length && this.connected_) {
	      this.disconnect_();
	    }
	  };
	  /**
	   * Invokes the update of observers. It will continue running updates insofar
	   * it detects changes.
	   *
	   * @returns {void}
	   */
	  ResizeObserverController.prototype.refresh = function () {
	    var changesDetected = this.updateObservers_();
	    // Continue running updates if changes have been detected as there might
	    // be future ones caused by CSS transitions.
	    if (changesDetected) {
	      this.refresh();
	    }
	  };
	  /**
	   * Updates every observer from observers list and notifies them of queued
	   * entries.
	   *
	   * @private
	   * @returns {boolean} Returns "true" if any observer has detected changes in
	   *      dimensions of it's elements.
	   */
	  ResizeObserverController.prototype.updateObservers_ = function () {
	    // Collect observers that have active observations.
	    var activeObservers = this.observers_.filter(function (observer) {
	      return observer.gatherActive(), observer.hasActive();
	    });
	    // Deliver notifications in a separate cycle in order to avoid any
	    // collisions between observers, e.g. when multiple instances of
	    // ResizeObserver are tracking the same element and the callback of one
	    // of them changes content dimensions of the observed target. Sometimes
	    // this may result in notifications being blocked for the rest of observers.
	    activeObservers.forEach(function (observer) {
	      return observer.broadcastActive();
	    });
	    return activeObservers.length > 0;
	  };
	  /**
	   * Initializes DOM listeners.
	   *
	   * @private
	   * @returns {void}
	   */
	  ResizeObserverController.prototype.connect_ = function () {
	    // Do nothing if running in a non-browser environment or if listeners
	    // have been already added.
	    if (!isBrowser || this.connected_) {
	      return;
	    }
	    // Subscription to the "Transitionend" event is used as a workaround for
	    // delayed transitions. This way it's possible to capture at least the
	    // final state of an element.
	    document.addEventListener('transitionend', this.onTransitionEnd_);
	    window.addEventListener('resize', this.refresh);
	    if (mutationObserverSupported) {
	      this.mutationsObserver_ = new MutationObserver(this.refresh);
	      this.mutationsObserver_.observe(document, {
	        attributes: true,
	        childList: true,
	        characterData: true,
	        subtree: true
	      });
	    } else {
	      document.addEventListener('DOMSubtreeModified', this.refresh);
	      this.mutationEventsAdded_ = true;
	    }
	    this.connected_ = true;
	  };
	  /**
	   * Removes DOM listeners.
	   *
	   * @private
	   * @returns {void}
	   */
	  ResizeObserverController.prototype.disconnect_ = function () {
	    // Do nothing if running in a non-browser environment or if listeners
	    // have been already removed.
	    if (!isBrowser || !this.connected_) {
	      return;
	    }
	    document.removeEventListener('transitionend', this.onTransitionEnd_);
	    window.removeEventListener('resize', this.refresh);
	    if (this.mutationsObserver_) {
	      this.mutationsObserver_.disconnect();
	    }
	    if (this.mutationEventsAdded_) {
	      document.removeEventListener('DOMSubtreeModified', this.refresh);
	    }
	    this.mutationsObserver_ = null;
	    this.mutationEventsAdded_ = false;
	    this.connected_ = false;
	  };
	  /**
	   * "Transitionend" event handler.
	   *
	   * @private
	   * @param {TransitionEvent} event
	   * @returns {void}
	   */
	  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
	    var _b = _a.propertyName,
	      propertyName = _b === void 0 ? '' : _b;
	    // Detect whether transition may affect dimensions of an element.
	    var isReflowProperty = transitionKeys.some(function (key) {
	      return !!~propertyName.indexOf(key);
	    });
	    if (isReflowProperty) {
	      this.refresh();
	    }
	  };
	  /**
	   * Returns instance of the ResizeObserverController.
	   *
	   * @returns {ResizeObserverController}
	   */
	  ResizeObserverController.getInstance = function () {
	    if (!this.instance_) {
	      this.instance_ = new ResizeObserverController();
	    }
	    return this.instance_;
	  };
	  /**
	   * Holds reference to the controller's instance.
	   *
	   * @private {ResizeObserverController}
	   */
	  ResizeObserverController.instance_ = null;
	  return ResizeObserverController;
	}();

	/**
	 * Defines non-writable/enumerable properties of the provided target object.
	 *
	 * @param {Object} target - Object for which to define properties.
	 * @param {Object} props - Properties to be defined.
	 * @returns {Object} Target object.
	 */
	var defineConfigurable = function defineConfigurable(target, props) {
	  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
	    var key = _a[_i];
	    Object.defineProperty(target, key, {
	      value: props[key],
	      enumerable: false,
	      writable: false,
	      configurable: true
	    });
	  }
	  return target;
	};

	/**
	 * Returns the global object associated with provided element.
	 *
	 * @param {Object} target
	 * @returns {Object}
	 */
	var getWindowOf = function getWindowOf(target) {
	  // Assume that the element is an instance of Node, which means that it
	  // has the "ownerDocument" property from which we can retrieve a
	  // corresponding global object.
	  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
	  // Return the local global object if it's not possible extract one from
	  // provided element.
	  return ownerGlobal || global$1;
	};

	// Placeholder of an empty content rectangle.
	var emptyRect = createRectInit(0, 0, 0, 0);
	/**
	 * Converts provided string to a number.
	 *
	 * @param {number|string} value
	 * @returns {number}
	 */
	function toFloat(value) {
	  return parseFloat(value) || 0;
	}
	/**
	 * Extracts borders size from provided styles.
	 *
	 * @param {CSSStyleDeclaration} styles
	 * @param {...string} positions - Borders positions (top, right, ...)
	 * @returns {number}
	 */
	function getBordersSize(styles) {
	  var positions = [];
	  for (var _i = 1; _i < arguments.length; _i++) {
	    positions[_i - 1] = arguments[_i];
	  }
	  return positions.reduce(function (size, position) {
	    var value = styles['border-' + position + '-width'];
	    return size + toFloat(value);
	  }, 0);
	}
	/**
	 * Extracts paddings sizes from provided styles.
	 *
	 * @param {CSSStyleDeclaration} styles
	 * @returns {Object} Paddings box.
	 */
	function getPaddings(styles) {
	  var positions = ['top', 'right', 'bottom', 'left'];
	  var paddings = {};
	  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
	    var position = positions_1[_i];
	    var value = styles['padding-' + position];
	    paddings[position] = toFloat(value);
	  }
	  return paddings;
	}
	/**
	 * Calculates content rectangle of provided SVG element.
	 *
	 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
	 *      to be calculated.
	 * @returns {DOMRectInit}
	 */
	function getSVGContentRect(target) {
	  var bbox = target.getBBox();
	  return createRectInit(0, 0, bbox.width, bbox.height);
	}
	/**
	 * Calculates content rectangle of provided HTMLElement.
	 *
	 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
	 * @returns {DOMRectInit}
	 */
	function getHTMLElementContentRect(target) {
	  // Client width & height properties can't be
	  // used exclusively as they provide rounded values.
	  var clientWidth = target.clientWidth,
	    clientHeight = target.clientHeight;
	  // By this condition we can catch all non-replaced inline, hidden and
	  // detached elements. Though elements with width & height properties less
	  // than 0.5 will be discarded as well.
	  //
	  // Without it we would need to implement separate methods for each of
	  // those cases and it's not possible to perform a precise and performance
	  // effective test for hidden elements. E.g. even jQuery's ':visible' filter
	  // gives wrong results for elements with width & height less than 0.5.
	  if (!clientWidth && !clientHeight) {
	    return emptyRect;
	  }
	  var styles = getWindowOf(target).getComputedStyle(target);
	  var paddings = getPaddings(styles);
	  var horizPad = paddings.left + paddings.right;
	  var vertPad = paddings.top + paddings.bottom;
	  // Computed styles of width & height are being used because they are the
	  // only dimensions available to JS that contain non-rounded values. It could
	  // be possible to utilize the getBoundingClientRect if only it's data wasn't
	  // affected by CSS transformations let alone paddings, borders and scroll bars.
	  var width = toFloat(styles.width),
	    height = toFloat(styles.height);
	  // Width & height include paddings and borders when the 'border-box' box
	  // model is applied (except for IE).
	  if (styles.boxSizing === 'border-box') {
	    // Following conditions are required to handle Internet Explorer which
	    // doesn't include paddings and borders to computed CSS dimensions.
	    //
	    // We can say that if CSS dimensions + paddings are equal to the "client"
	    // properties then it's either IE, and thus we don't need to subtract
	    // anything, or an element merely doesn't have paddings/borders styles.
	    if (Math.round(width + horizPad) !== clientWidth) {
	      width -= getBordersSize(styles, 'left', 'right') + horizPad;
	    }
	    if (Math.round(height + vertPad) !== clientHeight) {
	      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
	    }
	  }
	  // Following steps can't be applied to the document's root element as its
	  // client[Width/Height] properties represent viewport area of the window.
	  // Besides, it's as well not necessary as the <html> itself neither has
	  // rendered scroll bars nor it can be clipped.
	  if (!isDocumentElement(target)) {
	    // In some browsers (only in Firefox, actually) CSS width & height
	    // include scroll bars size which can be removed at this step as scroll
	    // bars are the only difference between rounded dimensions + paddings
	    // and "client" properties, though that is not always true in Chrome.
	    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
	    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
	    // Chrome has a rather weird rounding of "client" properties.
	    // E.g. for an element with content width of 314.2px it sometimes gives
	    // the client width of 315px and for the width of 314.7px it may give
	    // 314px. And it doesn't happen all the time. So just ignore this delta
	    // as a non-relevant.
	    if (Math.abs(vertScrollbar) !== 1) {
	      width -= vertScrollbar;
	    }
	    if (Math.abs(horizScrollbar) !== 1) {
	      height -= horizScrollbar;
	    }
	  }
	  return createRectInit(paddings.left, paddings.top, width, height);
	}
	/**
	 * Checks whether provided element is an instance of the SVGGraphicsElement.
	 *
	 * @param {Element} target - Element to be checked.
	 * @returns {boolean}
	 */
	var isSVGGraphicsElement = function () {
	  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
	  // interface.
	  if (typeof SVGGraphicsElement !== 'undefined') {
	    return function (target) {
	      return target instanceof getWindowOf(target).SVGGraphicsElement;
	    };
	  }
	  // If it's so, then check that element is at least an instance of the
	  // SVGElement and that it has the "getBBox" method.
	  // eslint-disable-next-line no-extra-parens
	  return function (target) {
	    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
	  };
	}();
	/**
	 * Checks whether provided element is a document element (<html>).
	 *
	 * @param {Element} target - Element to be checked.
	 * @returns {boolean}
	 */
	function isDocumentElement(target) {
	  return target === getWindowOf(target).document.documentElement;
	}
	/**
	 * Calculates an appropriate content rectangle for provided html or svg element.
	 *
	 * @param {Element} target - Element content rectangle of which needs to be calculated.
	 * @returns {DOMRectInit}
	 */
	function getContentRect(target) {
	  if (!isBrowser) {
	    return emptyRect;
	  }
	  if (isSVGGraphicsElement(target)) {
	    return getSVGContentRect(target);
	  }
	  return getHTMLElementContentRect(target);
	}
	/**
	 * Creates rectangle with an interface of the DOMRectReadOnly.
	 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
	 *
	 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
	 * @returns {DOMRectReadOnly}
	 */
	function createReadOnlyRect(_a) {
	  var x = _a.x,
	    y = _a.y,
	    width = _a.width,
	    height = _a.height;
	  // If DOMRectReadOnly is available use it as a prototype for the rectangle.
	  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
	  var rect = Object.create(Constr.prototype);
	  // Rectangle's properties are not writable and non-enumerable.
	  defineConfigurable(rect, {
	    x: x,
	    y: y,
	    width: width,
	    height: height,
	    top: y,
	    right: x + width,
	    bottom: height + y,
	    left: x
	  });
	  return rect;
	}
	/**
	 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
	 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
	 *
	 * @param {number} x - X coordinate.
	 * @param {number} y - Y coordinate.
	 * @param {number} width - Rectangle's width.
	 * @param {number} height - Rectangle's height.
	 * @returns {DOMRectInit}
	 */
	function createRectInit(x, y, width, height) {
	  return {
	    x: x,
	    y: y,
	    width: width,
	    height: height
	  };
	}

	/**
	 * Class that is responsible for computations of the content rectangle of
	 * provided DOM element and for keeping track of it's changes.
	 */
	var ResizeObservation = /** @class */function () {
	  /**
	   * Creates an instance of ResizeObservation.
	   *
	   * @param {Element} target - Element to be observed.
	   */
	  function ResizeObservation(target) {
	    /**
	     * Broadcasted width of content rectangle.
	     *
	     * @type {number}
	     */
	    this.broadcastWidth = 0;
	    /**
	     * Broadcasted height of content rectangle.
	     *
	     * @type {number}
	     */
	    this.broadcastHeight = 0;
	    /**
	     * Reference to the last observed content rectangle.
	     *
	     * @private {DOMRectInit}
	     */
	    this.contentRect_ = createRectInit(0, 0, 0, 0);
	    this.target = target;
	  }
	  /**
	   * Updates content rectangle and tells whether it's width or height properties
	   * have changed since the last broadcast.
	   *
	   * @returns {boolean}
	   */
	  ResizeObservation.prototype.isActive = function () {
	    var rect = getContentRect(this.target);
	    this.contentRect_ = rect;
	    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
	  };
	  /**
	   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
	   * from the corresponding properties of the last observed content rectangle.
	   *
	   * @returns {DOMRectInit} Last observed content rectangle.
	   */
	  ResizeObservation.prototype.broadcastRect = function () {
	    var rect = this.contentRect_;
	    this.broadcastWidth = rect.width;
	    this.broadcastHeight = rect.height;
	    return rect;
	  };
	  return ResizeObservation;
	}();
	var ResizeObserverEntry = /** @class */function () {
	  /**
	   * Creates an instance of ResizeObserverEntry.
	   *
	   * @param {Element} target - Element that is being observed.
	   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
	   */
	  function ResizeObserverEntry(target, rectInit) {
	    var contentRect = createReadOnlyRect(rectInit);
	    // According to the specification following properties are not writable
	    // and are also not enumerable in the native implementation.
	    //
	    // Property accessors are not being used as they'd require to define a
	    // private WeakMap storage which may cause memory leaks in browsers that
	    // don't support this type of collections.
	    defineConfigurable(this, {
	      target: target,
	      contentRect: contentRect
	    });
	  }
	  return ResizeObserverEntry;
	}();
	var ResizeObserverSPI = /** @class */function () {
	  /**
	   * Creates a new instance of ResizeObserver.
	   *
	   * @param {ResizeObserverCallback} callback - Callback function that is invoked
	   *      when one of the observed elements changes it's content dimensions.
	   * @param {ResizeObserverController} controller - Controller instance which
	   *      is responsible for the updates of observer.
	   * @param {ResizeObserver} callbackCtx - Reference to the public
	   *      ResizeObserver instance which will be passed to callback function.
	   */
	  function ResizeObserverSPI(callback, controller, callbackCtx) {
	    /**
	     * Collection of resize observations that have detected changes in dimensions
	     * of elements.
	     *
	     * @private {Array<ResizeObservation>}
	     */
	    this.activeObservations_ = [];
	    /**
	     * Registry of the ResizeObservation instances.
	     *
	     * @private {Map<Element, ResizeObservation>}
	     */
	    this.observations_ = new MapShim();
	    if (typeof callback !== 'function') {
	      throw new TypeError('The callback provided as parameter 1 is not a function.');
	    }
	    this.callback_ = callback;
	    this.controller_ = controller;
	    this.callbackCtx_ = callbackCtx;
	  }
	  /**
	   * Starts observing provided element.
	   *
	   * @param {Element} target - Element to be observed.
	   * @returns {void}
	   */
	  ResizeObserverSPI.prototype.observe = function (target) {
	    if (!arguments.length) {
	      throw new TypeError('1 argument required, but only 0 present.');
	    }
	    // Do nothing if current environment doesn't have the Element interface.
	    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
	      return;
	    }
	    if (!(target instanceof getWindowOf(target).Element)) {
	      throw new TypeError('parameter 1 is not of type "Element".');
	    }
	    var observations = this.observations_;
	    // Do nothing if element is already being observed.
	    if (observations.has(target)) {
	      return;
	    }
	    observations.set(target, new ResizeObservation(target));
	    this.controller_.addObserver(this);
	    // Force the update of observations.
	    this.controller_.refresh();
	  };
	  /**
	   * Stops observing provided element.
	   *
	   * @param {Element} target - Element to stop observing.
	   * @returns {void}
	   */
	  ResizeObserverSPI.prototype.unobserve = function (target) {
	    if (!arguments.length) {
	      throw new TypeError('1 argument required, but only 0 present.');
	    }
	    // Do nothing if current environment doesn't have the Element interface.
	    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
	      return;
	    }
	    if (!(target instanceof getWindowOf(target).Element)) {
	      throw new TypeError('parameter 1 is not of type "Element".');
	    }
	    var observations = this.observations_;
	    // Do nothing if element is not being observed.
	    if (!observations.has(target)) {
	      return;
	    }
	    observations["delete"](target);
	    if (!observations.size) {
	      this.controller_.removeObserver(this);
	    }
	  };
	  /**
	   * Stops observing all elements.
	   *
	   * @returns {void}
	   */
	  ResizeObserverSPI.prototype.disconnect = function () {
	    this.clearActive();
	    this.observations_.clear();
	    this.controller_.removeObserver(this);
	  };
	  /**
	   * Collects observation instances the associated element of which has changed
	   * it's content rectangle.
	   *
	   * @returns {void}
	   */
	  ResizeObserverSPI.prototype.gatherActive = function () {
	    var _this = this;
	    this.clearActive();
	    this.observations_.forEach(function (observation) {
	      if (observation.isActive()) {
	        _this.activeObservations_.push(observation);
	      }
	    });
	  };
	  /**
	   * Invokes initial callback function with a list of ResizeObserverEntry
	   * instances collected from active resize observations.
	   *
	   * @returns {void}
	   */
	  ResizeObserverSPI.prototype.broadcastActive = function () {
	    // Do nothing if observer doesn't have active observations.
	    if (!this.hasActive()) {
	      return;
	    }
	    var ctx = this.callbackCtx_;
	    // Create ResizeObserverEntry instance for every active observation.
	    var entries = this.activeObservations_.map(function (observation) {
	      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
	    });
	    this.callback_.call(ctx, entries, ctx);
	    this.clearActive();
	  };
	  /**
	   * Clears the collection of active observations.
	   *
	   * @returns {void}
	   */
	  ResizeObserverSPI.prototype.clearActive = function () {
	    this.activeObservations_.splice(0);
	  };
	  /**
	   * Tells whether observer has active observations.
	   *
	   * @returns {boolean}
	   */
	  ResizeObserverSPI.prototype.hasActive = function () {
	    return this.activeObservations_.length > 0;
	  };
	  return ResizeObserverSPI;
	}();

	// Registry of internal observers. If WeakMap is not available use current shim
	// for the Map collection as it has all required methods and because WeakMap
	// can't be fully polyfilled anyway.
	var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
	/**
	 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
	 * exposing only those methods and properties that are defined in the spec.
	 */
	var ResizeObserver = /** @class */function () {
	  /**
	   * Creates a new instance of ResizeObserver.
	   *
	   * @param {ResizeObserverCallback} callback - Callback that is invoked when
	   *      dimensions of the observed elements change.
	   */
	  function ResizeObserver(callback) {
	    if (!(this instanceof ResizeObserver)) {
	      throw new TypeError('Cannot call a class as a function.');
	    }
	    if (!arguments.length) {
	      throw new TypeError('1 argument required, but only 0 present.');
	    }
	    var controller = ResizeObserverController.getInstance();
	    var observer = new ResizeObserverSPI(callback, controller, this);
	    observers.set(this, observer);
	  }
	  return ResizeObserver;
	}();
	// Expose public methods of ResizeObserver.
	['observe', 'unobserve', 'disconnect'].forEach(function (method) {
	  ResizeObserver.prototype[method] = function () {
	    var _a;
	    return (_a = observers.get(this))[method].apply(_a, arguments);
	  };
	});
	var index$1 = function () {
	  // Export existing implementation if available.
	  if (typeof global$1.ResizeObserver !== 'undefined') {
	    return global$1.ResizeObserver;
	  }
	  return ResizeObserver;
	}();

	var ResizeObserver_es = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': index$1
	});

	var getMargin_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = getMargin;
	var toNumber = function toNumber(n) {
	  return parseInt(n) || 0;
	};
	function getMargin(style) {
	  return {
	    top: style ? toNumber(style.marginTop) : 0,
	    right: style ? toNumber(style.marginRight) : 0,
	    bottom: style ? toNumber(style.marginBottom) : 0,
	    left: style ? toNumber(style.marginLeft) : 0
	  };
	}
	module.exports = exports["default"];
	});

	unwrapExports(getMargin_1);

	var getCloneDimensions_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = getCloneDimensions;
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    'default': obj
	  };
	}

	var _getMargin2 = _interopRequireDefault(getMargin_1);
	function getCloneDimensions(node, options) {
	  var parentNode = node.parentNode;
	  var context = document.createElement('div');
	  var clone = node.cloneNode(true);
	  var style = getComputedStyle(node);
	  var rect = undefined,
	    width = undefined,
	    height = undefined;

	  // give the node some context to measure off of
	  // no height and hidden overflow hide node copy
	  context.style.height = 0;
	  context.style.overflow = 'hidden';

	  // clean up any attributes that might cause a conflict with the original node
	  // i.e. inputs that should focus or submit data
	  clone.setAttribute('id', '');
	  clone.setAttribute('name', '');

	  // set props to get a true dimension calculation
	  if (options.display || style && style.getPropertyValue('display') === 'none') {
	    clone.style.display = options.display || 'block';
	  }
	  if (options.width || style && !parseInt(style.getPropertyValue('width'))) {
	    clone.style.width = options.width || 'auto';
	  }
	  if (options.height || style && !parseInt(style.getPropertyValue('height'))) {
	    clone.style.height = options.height || 'auto';
	  }

	  // append copy to context
	  context.appendChild(clone);

	  // append context to DOM so we can measure
	  parentNode.appendChild(context);

	  // get accurate dimensions
	  rect = clone.getBoundingClientRect();
	  width = clone.offsetWidth;
	  height = clone.offsetHeight;

	  // destroy clone
	  parentNode.removeChild(context);
	  return {
	    rect: {
	      width: width,
	      height: height,
	      top: rect.top,
	      right: rect.right,
	      bottom: rect.bottom,
	      left: rect.left
	    },
	    margin: (0, _getMargin2['default'])(style)
	  };
	}
	module.exports = exports['default'];
	});

	unwrapExports(getCloneDimensions_1);

	var getNodeDimensions_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = getNodeDimensions;
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    'default': obj
	  };
	}

	var _getCloneDimensions2 = _interopRequireDefault(getCloneDimensions_1);

	var _getMargin2 = _interopRequireDefault(getMargin_1);
	function getNodeDimensions(node) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	  var rect = node.getBoundingClientRect();
	  var width = undefined,
	    height = undefined,
	    margin = undefined;

	  // determine if we need to clone the element to get proper dimensions or not
	  if ((!rect.width || !rect.height) && !options.noCloneOnZeroDimension || options.clone) {
	    var cloneDimensions = (0, _getCloneDimensions2['default'])(node, options);
	    rect = cloneDimensions.rect;
	    margin = cloneDimensions.margin;
	  }
	  // if no cloning needed, we need to determine if margin should be accounted for
	  else if (options.margin) {
	    margin = (0, _getMargin2['default'])(getComputedStyle(node));
	  }

	  // include margin in width/height calculation if desired
	  if (options.margin) {
	    width = margin.left + rect.width + margin.right;
	    height = margin.top + rect.height + margin.bottom;
	  } else {
	    width = rect.width;
	    height = rect.height;
	  }
	  return {
	    width: width,
	    height: height,
	    top: rect.top,
	    right: rect.right,
	    bottom: rect.bottom,
	    left: rect.left
	  };
	}
	module.exports = exports['default'];
	});

	unwrapExports(getNodeDimensions_1);

	var _resizeObserverPolyfill = getCjsExportFromNamespace(ResizeObserver_es);

	var Measure_1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];
	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }
	  return target;
	};
	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var _react2 = _interopRequireDefault(React$1__default);

	var _propTypes2 = _interopRequireDefault(propTypes);

	var _reactDom2 = _interopRequireDefault(ReactDOM);

	var _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);

	var _getNodeDimensions2 = _interopRequireDefault(getNodeDimensions_1);
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	}
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	function _possibleConstructorReturn(self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	}
	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }
	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}
	var Measure = function (_Component) {
	  _inherits(Measure, _Component);
	  function Measure(props) {
	    _classCallCheck(this, Measure);
	    var _this = _possibleConstructorReturn(this, (Measure.__proto__ || Object.getPrototypeOf(Measure)).call(this, props));
	    _this.measure = function () {
	      var includeMargin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props.includeMargin;
	      var useClone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.props.useClone;

	      // bail out if we shouldn't measure
	      if (!_this.props.shouldMeasure) return;

	      // if no parent available we need to requery the DOM node
	      if (!_this._node.parentNode) {
	        _this._setDOMNode();
	      }
	      var dimensions = _this.getDimensions(_this._node, includeMargin, useClone);
	      var isChildFunction = typeof _this.props.children === 'function';

	      // determine if we need to update our callback with new dimensions or not
	      _this._propsToMeasure.some(function (prop) {
	        if (dimensions[prop] !== _this._lastDimensions[prop]) {
	          // update our callback if we've found a dimension that has changed
	          _this.props.onMeasure(dimensions);

	          // update state to send dimensions to child function
	          if (isChildFunction && typeof _this !== 'undefined') {
	            _this.setState({
	              dimensions: dimensions
	            });
	          }

	          // store last dimensions to compare changes
	          _this._lastDimensions = dimensions;

	          // we don't need to look any further, bail out
	          return true;
	        }
	      });
	    };
	    _this.state = {
	      dimensions: {
	        width: 0,
	        height: 0,
	        top: 0,
	        right: 0,
	        bottom: 0,
	        left: 0
	      }
	    };
	    _this._node = null;
	    _this._propsToMeasure = _this._getPropsToMeasure(props);
	    _this._lastDimensions = {};
	    return _this;
	  }
	  _createClass(Measure, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _this2 = this;
	      this._setDOMNode();

	      // measure on first render
	      this.measure();

	      // add component to resize observer to detect changes on resize
	      this.resizeObserver = new _resizeObserverPolyfill2["default"](function () {
	        return _this2.measure();
	      });
	      this.resizeObserver.observe(this._node);
	    }
	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(_ref) {
	      var config = _ref.config,
	        whitelist = _ref.whitelist,
	        blacklist = _ref.blacklist;

	      // we store the properties ourselves so we need to update them if the
	      // whitelist or blacklist props have changed
	      if (this.props.whitelist !== whitelist || this.props.blacklist !== blacklist) {
	        this._propsToMeasure = this._getPropsToMeasure({
	          whitelist: whitelist,
	          blacklist: blacklist
	        });
	      }
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.resizeObserver.disconnect(this._node);
	      this._node = null;
	    }
	  }, {
	    key: '_setDOMNode',
	    value: function _setDOMNode() {
	      this._node = _reactDom2["default"].findDOMNode(this);
	    }
	  }, {
	    key: 'getDimensions',
	    value: function getDimensions() {
	      var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._node;
	      var includeMargin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.props.includeMargin;
	      var useClone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.props.useClone;
	      var cloneOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.props.cloneOptions;
	      return (0, _getNodeDimensions2["default"])(node, _extends({
	        margin: includeMargin,
	        clone: useClone
	      }, cloneOptions));
	    }
	  }, {
	    key: '_getPropsToMeasure',
	    value: function _getPropsToMeasure(_ref2) {
	      var whitelist = _ref2.whitelist,
	        blacklist = _ref2.blacklist;
	      return whitelist.filter(function (prop) {
	        return blacklist.indexOf(prop) < 0;
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var children = this.props.children;
	      return React$1__default.Children.only(typeof children === 'function' ? children(this.state.dimensions) : children);
	    }
	  }]);
	  return Measure;
	}(React$1__default.Component);
	Measure.propTypes = {
	  whitelist: _propTypes2["default"].array,
	  blacklist: _propTypes2["default"].array,
	  includeMargin: _propTypes2["default"].bool,
	  useClone: _propTypes2["default"].bool,
	  cloneOptions: _propTypes2["default"].object,
	  shouldMeasure: _propTypes2["default"].bool,
	  onMeasure: _propTypes2["default"].func
	};
	Measure.defaultProps = {
	  whitelist: ['width', 'height', 'top', 'right', 'bottom', 'left'],
	  blacklist: [],
	  includeMargin: true,
	  useClone: false,
	  cloneOptions: {},
	  shouldMeasure: true,
	  onMeasure: function onMeasure() {
	    return null;
	  }
	};
	exports["default"] = Measure;
	module.exports = exports['default'];
	});

	unwrapExports(Measure_1);

	var reactMeasure = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports["default"] = undefined;

	var _Measure2 = _interopRequireDefault(Measure_1);
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : {
	    "default": obj
	  };
	}
	exports["default"] = _Measure2["default"];
	module.exports = exports['default'];
	});

	var Measure = unwrapExports(reactMeasure);

	var ARROW_LEFT = 37;
	var ARROW_RIGHT = 39;
	var SPACE = 32;
	var TAB = 9;

	function _callSuper$b(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var ProgressSlider = /*#__PURE__*/function (_React$Component) {
	  _inherits(ProgressSlider, _React$Component);
	  function ProgressSlider(props, context) {
	    var _this;
	    _classCallCheck(this, ProgressSlider);
	    _this = _callSuper$b(this, ProgressSlider, [props, context]);
	    _this.state = {
	      handleWidth: null,
	      progressHolderWidth: null
	    };
	    _this.measureProgressHolder = function (_ref) {
	      var width = _ref.width;
	      _this.setState({
	        progressHolderWidth: width
	      });
	    };
	    _this.measureHandle = function (_ref2) {
	      var width = _ref2.width;
	      _this.setState({
	        handleWidth: width
	      });
	    };
	    _this.handleStop = function (mouseEvent, dragEvent) {
	      if (_this.props.onSeek) {
	        _this.props.onSeek(_this.positionToTime(dragEvent.x));
	      }
	    };
	    _this.handleDrag = function (mouseEvent, dragEvent) {
	      if (_this.props.onScrub) {
	        _this.props.onScrub(_this.positionToTime(dragEvent.x));
	      }
	    };
	    _this.handleKeyDown = function (event) {
	      var destination;
	      if (event.keyCode == ARROW_LEFT) {
	        destination = Math.max(0, _this.props.currentTime - 1);
	      } else if (event.keyCode == ARROW_RIGHT) {
	        destination = Math.min(_this.props.currentTime + 1, _this.props.duration || Infinity);
	      }
	      if (_this.prop.onSeek) {
	        _this.props.onSeek(destination);
	      }
	    };
	    return _this;
	  }
	  _createClass(ProgressSlider, [{
	    key: "positionToTime",
	    value: function positionToTime(x) {
	      if (this.props.duration && this.state.progressHolderWidth) {
	        var fraction = Math.max(0, Math.min(1, x / this.state.progressHolderWidth));
	        return fraction * this.props.duration;
	      } else {
	        return 0;
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return /*#__PURE__*/React$1__default.createElement("div", {
	        className: "vjs-progress-control",
	        tabIndex: "4",
	        onKeyDown: this.handleKeyDown
	      }, /*#__PURE__*/React$1__default.createElement(Measure, {
	        whitelist: ['width'],
	        onMeasure: this.measureProgressHolder
	      }, /*#__PURE__*/React$1__default.createElement(reactDraggable_1, {
	        onStart: this.handleDrag,
	        onDrag: this.handleDrag,
	        onStop: this.handleStop
	      }, /*#__PURE__*/React$1__default.createElement("div", {
	        className: "vjs-progress-holder"
	      }, /*#__PURE__*/React$1__default.createElement("div", {
	        className: "vjs-load-progress",
	        style: {
	          width: toPercent(this.loadProgress())
	        }
	      }), /*#__PURE__*/React$1__default.createElement("div", {
	        className: "vjs-play-progress",
	        style: {
	          width: toPercent(this.playProgress())
	        }
	      }), /*#__PURE__*/React$1__default.createElement(Measure, {
	        whitelist: ['width'],
	        onMeasure: this.measureHandle
	      }, /*#__PURE__*/React$1__default.createElement("div", {
	        className: "vjs-seek-handle",
	        style: {
	          left: this.handlePosition()
	        }
	      }))))));
	    }
	  }, {
	    key: "handlePosition",
	    value: function handlePosition() {
	      if (this.state.handleWidth && this.state.progressHolderWidth) {
	        return (this.state.progressHolderWidth - this.state.handleWidth) * this.playProgress();
	      } else {
	        return toPercent(this.playProgress());
	      }
	    }
	  }, {
	    key: "loadProgress",
	    value: function loadProgress() {
	      return this.props.duration > 0 ? this.props.bufferedEnd / this.props.duration : 0;
	    }
	  }, {
	    key: "playProgress",
	    value: function playProgress() {
	      return this.props.duration > 0 ? this.props.currentTime / this.props.duration : 0;
	    }
	  }]);
	  return ProgressSlider;
	}(React$1__default.Component);
	ProgressSlider.defaultProps = {
	  currentTime: 0,
	  bufferedEnd: 0
	};
	function toPercent(value) {
	  return value > 0 ? value * 100 + '%' : 0;
	}

	function _callSuper$c(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var MenuBarButton = /*#__PURE__*/function (_React$Component) {
	  _inherits(MenuBarButton, _React$Component);
	  function MenuBarButton(props, context) {
	    var _this;
	    _classCallCheck(this, MenuBarButton);
	    _this = _callSuper$c(this, MenuBarButton, [props, context]);
	    _this.state = {
	      subMenuVisible: false
	    };
	    _this.onLinkClick = function (event) {
	      event.preventDefault();
	      if (_this.props.subMenuItems.length > 0) {
	        _this.setState({
	          subMenuVisible: true
	        });
	      }
	      if (_this.props.onClick) {
	        _this.props.onClick();
	      }
	    };
	    _this.onMouseEnter = function () {
	      if (_this.props.subMenuItems.length > 0) {
	        _this.setState({
	          subMenuVisible: true
	        });
	      }
	      if (_this.props.onMouseEnter) {
	        _this.props.onMouseEnter();
	      }
	    };
	    _this.onMouseLeave = function () {
	      _this.closeMenu();
	      if (_this.props.onMouseEnter) {
	        _this.props.onMouseLeave();
	      }
	    };
	    _this.onFocus = function () {
	      clearTimeout(_this.closeMenuTimeout);
	    };
	    _this.onBlur = function () {
	      clearTimeout(_this.closeMenuTimeout);
	      _this.closeMenuTimeout = setTimeout(function () {
	        _this.closeMenu();
	      }, 100);
	    };
	    _this.closeMenu = function () {
	      _this.setState({
	        subMenuVisible: false
	      });
	    };
	    return _this;
	  }
	  _createClass(MenuBarButton, [{
	    key: "render",
	    value: function render() {
	      var _this2 = this;
	      var props = this.props;
	      return /*#__PURE__*/React.createElement("div", {
	        className: wrapperClassName(props, this.state.subMenuVisible),
	        ref: function ref(wrapper) {
	          return _this2.wrapper = wrapper;
	        },
	        onMouseEnter: this.onMouseEnter,
	        onMouseLeave: this.onMouseLeave,
	        onFocus: this.onFocus,
	        onBlur: this.onBlur
	      }, /*#__PURE__*/React.createElement("a", {
	        className: className$5(props, 'link'),
	        href: "#",
	        tabIndex: "4",
	        title: props.title,
	        onClick: this.onLinkClick
	      }, /*#__PURE__*/React.createElement(Icon, {
	        className: className$5(props, 'icon'),
	        name: props.iconName
	      })), renderSubMenu(props, this.closeMenu));
	    }
	  }]);
	  return MenuBarButton;
	}(React.Component);
	MenuBarButton.defaultProps = {
	  subMenuItems: []
	};
	function renderSubMenu(props, closeMenu) {
	  if (props.subMenuItems.length > 0) {
	    return /*#__PURE__*/React.createElement("ul", {
	      className: "player_controls-menu_bar_button_sub_menu"
	    }, renderSubMenuItems(props, closeMenu));
	  }
	}
	function renderSubMenuItems(props, closeMenu) {
	  return props.subMenuItems.map(function (item) {
	    return /*#__PURE__*/React.createElement("li", {
	      className: itemClassName(item),
	      key: item.value
	    }, /*#__PURE__*/React.createElement("a", {
	      className: "player_controls-menu_bar_button_sub_menu_item_link",
	      href: "#",
	      tabIndex: "4",
	      onClick: subMenuItemClickHandler(props, item.value, closeMenu)
	    }, renderSubMenuItemIcon(item), item.label, renderSubMenuItemAnnotation(props, item)));
	  });
	}
	function wrapperClassName(props, subMenuVisible) {
	  return classnames({
	    'player_controls-menu_bar_button-sub_menu_visible': subMenuVisible
	  }, className$5(props));
	}
	function itemClassName(item) {
	  return classnames('player_controls-menu_bar_button_sub_menu_item', {
	    'player_controls-menu_bar_button_sub_menu_item-active': item.active
	  });
	}
	function renderSubMenuItemIcon(item) {
	  if (item.active) {
	    return /*#__PURE__*/React.createElement(Icon, {
	      className: "player_controls-menu_bar_button_sub_menu_item_icon",
	      name: "activeMenuItem"
	    });
	  }
	}
	function renderSubMenuItemAnnotation(props, item) {
	  if (item.annotation) {
	    return /*#__PURE__*/React.createElement("span", {
	      className: className$5(props, 'sub_menu_item_annotation')
	    }, item.annotation);
	  }
	}
	function subMenuItemClickHandler(props, value, closeMenu) {
	  return function (event) {
	    event.preventDefault();
	    closeMenu();
	    if (props.onSubMenuItemClick) {
	      props.onSubMenuItemClick(value);
	    }
	  };
	}
	function className$5(props) {
	  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    suffix[_key - 1] = arguments[_key];
	  }
	  return classnames(['player_controls-menu_bar_button'].concat(suffix).join('_'), [props.className].concat(suffix).join('_'));
	}

	function QualityMenu(props) {
	  if (props.items.length < 2) {
	    return /*#__PURE__*/React.createElement("noscript", null);
	  }
	  return /*#__PURE__*/React.createElement(MenuBarButton, {
	    className: "player_controls-quality_menu_button",
	    title: props.buttonTitle,
	    iconName: "mediaQuality",
	    subMenuItems: props.items,
	    onSubMenuItemClick: props.onItemClick
	  });
	}
	QualityMenu.defaultProps = {
	  items: []
	};

	function TextTracksMenu(props) {
	  if (props.items.length < 2) {
	    return /*#__PURE__*/React.createElement("noscript", null);
	  }
	  return /*#__PURE__*/React.createElement(MenuBarButton, {
	    className: "player_controls-text_tracks_menu_button",
	    title: props.buttonTitle,
	    iconName: "textTracks",
	    subMenuItems: props.items,
	    onSubMenuItemClick: props.onItemClick
	  });
	}
	TextTracksMenu.defaultProps = {
	  items: []
	};

	function MenuBar(props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: className$6(props)
	  }, renderAdditionalButtons(props), /*#__PURE__*/React.createElement(TextTracksMenu, {
	    buttonTitle: props.textTracksMenuButtonTitle,
	    items: props.textTracksMenuItems,
	    onItemClick: props.onTextTracksMenuItemClick
	  }), /*#__PURE__*/React.createElement(QualityMenu, {
	    buttonTitle: props.qualityMenuButtonTitle,
	    items: props.qualityMenuItems,
	    onItemClick: props.onQualityMenuItemClick
	  }));
	}
	MenuBar.defaultProps = {
	  additionalButtons: [],
	  standAlone: true
	};
	function className$6(props) {
	  return classnames(props.className, 'player_controls-menu_bar', {
	    'player_controls-menu_bar-hidden_on_phone': props.hiddenOnPhone,
	    'player_controls-menu_bar-stand_alone': props.standAlone,
	    'player_controls-menu_bar-inverted': props.inverted
	  });
	}
	function renderAdditionalButtons(props) {
	  return props.additionalButtons.map(function (additionalButton) {
	    return /*#__PURE__*/React.createElement(MenuBarButton, {
	      title: additionalButton.label,
	      iconName: additionalButton.iconName,
	      className: additionalButton.className,
	      key: additionalButton.name,
	      onClick: createHandler(props.onAdditionalButtonClick, additionalButton.name),
	      onMouseEnter: createHandler(props.onAdditionalButtonMouseEnter, additionalButton.name),
	      onMouseLeave: createHandler(props.onAdditionalButtonMouseLeave, additionalButton.name)
	    });
	  });
	}
	function createHandler(handler, name) {
	  if (handler) {
	    return function () {
	      return handler(name);
	    };
	  }
	}

	function _callSuper$d(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function withVisibilityWatching(Component) {
	  return /*#__PURE__*/function (_React$Component) {
	    _inherits(VisibilityWatcher, _React$Component);
	    function VisibilityWatcher(props) {
	      var _this;
	      _classCallCheck(this, VisibilityWatcher);
	      _this = _callSuper$d(this, VisibilityWatcher, [props]);
	      _this.checkVisibility = function () {
	        var style = window.getComputedStyle(_this.element);
	        if (_this.lastVisibility != style.visibility) {
	          if (style.visibility == 'visible' && style.display != 'none') {
	            if (_this.props.onVisible) {
	              _this.props.onVisible();
	            }
	          } else {
	            if (_this.props.onHidden) {
	              _this.props.onHidden();
	            }
	          }
	        }
	        _this.lastVisibility = style.visibility;
	      };
	      return _this;
	    }
	    _createClass(VisibilityWatcher, [{
	      key: "componentDidMount",
	      value: function componentDidMount() {
	        this.element = ReactDOM.findDOMNode(this);
	        this.updateInterval();
	      }
	    }, {
	      key: "componentDidUpdate",
	      value: function componentDidUpdate() {
	        this.updateInterval();
	      }
	    }, {
	      key: "componentWillUnmount",
	      value: function componentWillUnmount() {
	        clearInterval(this.interval);
	        this.interval = null;
	        this.element = null;
	      }
	    }, {
	      key: "updateInterval",
	      value: function updateInterval() {
	        if (this.props.watchVisibility && !this.interval) {
	          this.interval = setInterval(this.checkVisibility, 50);
	        } else if (!this.props.watchVisibility && this.interval) {
	          clearInterval(this.interval);
	          this.interval = null;
	        }
	      }
	    }, {
	      key: "render",
	      value: function render() {
	        return /*#__PURE__*/React$1__default.createElement(Component, this.props);
	      }
	    }]);
	    return VisibilityWatcher;
	  }(React$1__default.Component);
	}

	function PlayerControls(props) {
	  return /*#__PURE__*/React$1__default.createElement(Container, props, /*#__PURE__*/React$1__default.createElement("span", {
	    className: "hint"
	  }, props.hint), /*#__PURE__*/React$1__default.createElement(InfoBox, Object.assign({}, props.infoBox, {
	    hiddenDuringPlayback: props.infoBoxHiddenDuringPlayback
	  })), /*#__PURE__*/React$1__default.createElement("div", {
	    className: controlBarClassNames(props)
	  }, renderLoadingSpinner(props), /*#__PURE__*/React$1__default.createElement("div", {
	    className: "play_button"
	  }, /*#__PURE__*/React$1__default.createElement(PlayButton$1, {
	    title: props.playButtonTitle,
	    iconName: props.playButtonIconName,
	    isPlaying: props.isPlaying,
	    onClick: props.onPlayButtonClick
	  })), renderProgress(props), /*#__PURE__*/React$1__default.createElement("div", {
	    className: "control_bar_text"
	  }, props.controlBarText)), /*#__PURE__*/React$1__default.createElement(MenuBar, {
	    standAlone: false,
	    additionalButtons: props.additionalMenuBarButtons,
	    onAdditionalButtonClick: props.onAdditionalButtonClick,
	    onAdditionalButtonMouseEnter: props.onAdditionalButtonMouseEnter,
	    onAdditionalButtonMouseLeave: props.onAdditionalButtonMouseLeave,
	    qualityMenuButtonTitle: props.qualityMenuButtonTitle,
	    qualityMenuItems: props.qualityMenuItems,
	    onQualityMenuItemClick: props.onQualityMenuItemClick,
	    textTracksMenuButtonTitle: props.textTracksMenuButtonTitle,
	    textTracksMenuItems: props.textTracksMenuItems,
	    onTextTracksMenuItemClick: props.onTextTracksMenuItemClick
	  }));
	}
	function renderLoadingSpinner(props) {
	  if (props.isLoading) {
	    return /*#__PURE__*/React$1__default.createElement(LoadingSpinner, props);
	  }
	}
	function renderProgress(props) {
	  if (props.hasProgress) {
	    return /*#__PURE__*/React$1__default.createElement("div", {
	      className: "player_controls-progress"
	    }, /*#__PURE__*/React$1__default.createElement(CurrentTime, props), /*#__PURE__*/React$1__default.createElement(TimeDivider, null), /*#__PURE__*/React$1__default.createElement(Duration, props), /*#__PURE__*/React$1__default.createElement(ProgressSlider, props));
	  }
	}
	function controlBarClassNames(props) {
	  return classnames('vjs-control-bar', {
	    'with_quality_menu_present': props.qualityMenuItems && props.qualityMenuItems.length >= 2,
	    'with_text_tracks_menu_present': props.textTracksMenuItems && props.textTracksMenuItems.length >= 2
	  });
	}
	var PlayerControls$1 = withVisibilityWatching(PlayerControls);

	var t$1 = memoizedSelector(locale, function (locale) {
	  return function (key, options) {
	    return I18n.t(key, _objectSpread2({
	      locale: locale
	    }, options));
	  };
	});
	function locale(state) {
	  return state.i18n.locale;
	}

	function CloseButton(props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: "close_button text_hidden_only",
	    tabIndex: "4",
	    title: props.t('pageflow.public.close'),
	    onClick: props.onClick
	  }, /*#__PURE__*/React.createElement("div", {
	    className: "label"
	  }, props.t('pageflow.public.close')));
	}
	var CloseButton$1 = connect(combine$1({
	  t: t$1
	}))(CloseButton);

	function editorOnly (Component) {
	  if (!PAGEFLOW_EDITOR) {
	    return function () {
	      return false;
	    };
	  } else {
	    return Component;
	  }
	}



	var components = /*#__PURE__*/Object.freeze({
		__proto__: null,
		PageWrapper: _default,
		PageBackground: PageBackground,
		PageBackgroundImage: PageBackgroundImage,
		PageShadow: PageShadow,
		PageForeground: PageForeground,
		PageContent: PageContent,
		PageScroller: PageScroller$1,
		PageHeader: _default$1,
		PageText: PageText,
		PageLink: PageLink$1,
		PageThumbnail: PageThumbnail$1,
		LazyLoadedPageThumbnail: LazyLoadedPageThumbnail,
		PlayerControls: PlayerControls$1,
		CloseButton: CloseButton$1,
		MenuBar: MenuBar,
		Icon: Icon,
		editorOnly: editorOnly,
		withVisibilityWatching: withVisibilityWatching,
		Draggable: reactDraggable$1,
		Measure: Measure
	});

	var selector$1 = createItemSelector('chapters');
	function chapterAttribute(name, options) {
	  return memoizedSelector(selector$1(options), function (chapter) {
	    return chapter && chapter[name];
	  });
	}
	var chapterAttributes = selector$1;

	var selector$2 = createItemSelector('storylines');
	function storylineAttribute(name, options) {
	  return memoizedSelector(selector$2(options), function (storyline) {
	    return storyline && storyline[name];
	  });
	}

	function currentParentChapterAttributes() {
	  return function (state, props) {
	    var parentPage = currentParentPageAttributes()(state, props);
	    if (!parentPage) {
	      return null;
	    }
	    return chapterAttributes({
	      id: parentPage.chapterId
	    })(state, props);
	  };
	}
	function currentParentPageAttributes() {
	  return function (state, props) {
	    var currentChapterId = pageAttribute('chapterId', {
	      id: state.currentPageId
	    })(state, props);
	    var currentStorylineId = chapterAttribute('storylineId', {
	      id: currentChapterId
	    })(state, props);
	    var currentParentPageId = storylineAttribute('parentPagePermaId', {
	      id: currentStorylineId
	    })(state, props);
	    return pageAttributes({
	      id: currentParentPageId
	    })(state, props);
	  };
	}

	function setting(_ref) {
	  var property = _ref.property;
	  return function (state) {
	    return state.settings[property];
	  };
	}

	var selector$3 = createItemSelector('widgets');
	function widgetAttribute(property, _ref) {
	  var role = _ref.role;
	  return memoizedSelector(selector$3({
	    id: role
	  }), function (widget) {
	    return widget && widget[property];
	  });
	}
	function widgetAttributes(_ref2) {
	  var role = _ref2.role;
	  return memoizedSelector(selector$3({
	    id: role
	  }), function (widget) {
	    return widget;
	  });
	}
	function editingWidget(_ref3) {
	  var role = _ref3.role;
	  return memoizedSelector(selector$3({
	    id: role
	  }), function (widget) {
	    return !!(widget && widget.editing);
	  });
	}



	var selectors = /*#__PURE__*/Object.freeze({
		__proto__: null,
		pageAttribute: pageAttribute,
		pageAttributes: pageAttributes,
		pageIsActive: pageIsActive,
		pageIsPrepared: pageIsPrepared,
		currentParentPageAttributes: currentParentPageAttributes,
		currentParentChapterAttributes: currentParentChapterAttributes,
		t: t$1,
		setting: setting,
		file: file,
		prop: prop,
		widgetAttributes: widgetAttributes,
		editingWidget: editingWidget
	});

	function entryAttribute(name) {
	  return function (state) {
	    return state.entry[name];
	  };
	}
	function isEntryReady(state) {
	  return !!state.entry.isReady;
	}

	function PagePrintImage(_ref) {
	  var page = _ref.page,
	    isEntryReady = _ref.isEntryReady;
	  if (!isEntryReady) {
	    return null;
	  }
	  if (page.backgroundType == 'video' || page.type == 'video') {
	    return /*#__PURE__*/React.createElement(PrintVideoPoster, {
	      videoId: page.videoFileId,
	      posterImageId: page.posterImageId
	    });
	  } else {
	    return /*#__PURE__*/React.createElement(PrintImage, {
	      imageId: page.backgroundImageId
	    });
	  }
	}
	var PagePrintImage$1 = connect(combine$1({
	  isEntryReady: isEntryReady
	}))(PagePrintImage);
	var PrintVideoPoster = connect(combine$1({
	  videoFile: file('videoFiles', {
	    id: prop('videoId')
	  }),
	  posterImageFile: file('imageFiles', {
	    id: prop('posterImageId')
	  })
	}))(function (_ref2) {
	  var videoFile = _ref2.videoFile,
	    posterImageFile = _ref2.posterImageFile;
	  if (posterImageFile) {
	    return /*#__PURE__*/React.createElement(PrintImageTag, {
	      file: posterImageFile
	    });
	  } else {
	    return /*#__PURE__*/React.createElement(PrintImageTag, {
	      file: videoFile
	    });
	  }
	});
	var PrintImage = connectInPage(combine$1({
	  file: file('imageFiles', {
	    id: prop('imageId')
	  }),
	  pageIsPrepared: pageIsPrepared()
	}))(PrintImageTag);
	function PrintImageTag(_ref3) {
	  var file = _ref3.file;
	  if (file && file.isReady && pageIsPrepared) {
	    return /*#__PURE__*/React.createElement("img", {
	      src: file.urls.print,
	      alt: file.alt,
	      className: "print_image"
	    });
	  } else {
	    return /*#__PURE__*/React.createElement("noscript", null);
	  }
	}

	function playerStateClassNames (playerState) {
	  return classnames({
	    'is_playing': playerState.shouldPlay,
	    'is_playing_delayed': playerState.hasBeenPlayingJustNow,
	    'is_paused': !playerState.shouldPlay
	  });
	}

	var TOGGLE_PLAYING = 'MEDIA_TOGGLE_PLAYING';
	var PLAY = 'MEDIA_PLAY';
	var PLAY_AND_FADE_IN = 'MEDIA_PLAY_AND_FADE_IN';
	var PAUSE = 'MEDIA_PAUSE';
	var FADE_OUT_AND_PAUSE = 'MEDIA_FADE_OUT_AND_PAUSE';
	var CHANGE_VOLUME_FACTOR = 'CHANGE_VOLUME_FACTOR';
	var PLAY_FAILED = 'MEDIA_PLAY_FAILED';
	var PLAYING_MUTED = 'MEDIA_PLAYING_MUTED';
	var SCRUB_TO = 'MEDIA_SCRUB_TO';
	var SEEK_TO = 'MEDIA_SEEK_TO';
	var PREBUFFER = 'MEDIA_PREBUFFER';
	var PREBUFFERED = 'MEDIA_PREBUFFERED';
	var ABORT_PREBUFFERING = 'MEDIA_ABORT_PREBUFFERING';
	var BUFFER_UNDERRUN = 'MEDIA_BUFFER_UNDERRUN';
	var BUFFER_UNDERRUN_CONTINUE = 'MEDIA_BUFFER_UNDERRUN_CONTINUE';
	var META_DATA_LOADED = 'MEDIA_META_DATA_LOADED';
	var PROGRESS = 'MEDIA_PROGRESS';
	var PLAYING = 'MEDIA_PLAYING';
	var PAUSED = 'MEDIA_PAUSED';
	var TIME_UPDATE = 'MEDIA_TIME_UPDATE';
	var ENDED = 'MEDIA_ENDED';
	var SEEKING = 'MEDIA_SEEKING';
	var SEEKED = 'MEDIA_SEEKED';
	var WAITING = 'MEDIA_WAITING';
	var HAS_NOT_BEEN_PLAYING_FOR_A_MOMENT = 'MEDIA_HAS_NOT_BEEN_PLAYING_FOR_A_MOMENT';
	var USER_INTERACTION = 'MEDIA_USER_INTERACTION';
	var USER_IDLE = 'MEDIA_USER_IDLE';
	var CONTROLS_ENTERED = 'MEDIA_CONTROLS_ENTERED';
	var CONTROLS_LEFT = 'MEDIA_CONTROLS_LEFT';
	var FOCUS_ENTERED_CONTROLS = 'MEDIA_FOCUS_ENTERED_CONTROLS';
	var FOCUS_LEFT_CONTROLS = 'MEDIA_FOCUS_LEFT_CONTROLS';
	var CONTROLS_HIDDEN = 'MEDIA_CONTROLS_HIDDEN';
	var SHOW_INFO_BOX_DURING_PLAYBACK = 'SHOW_INFO_BOX_DURING_PLAYBACK';
	var HIDE_INFO_BOX_DURING_PLAYBACK = 'HIDE_INFO_BOX_DURING_PLAYBACK';
	var TOGGLE_INFO_BOX_DURING_PLAYBACK = 'TOGGLE_INFO_BOX_DURING_PLAYBACK';
	var SAVE_MEDIA_ELEMENT_ID = 'MEDIA_SAVE_MEDIA_ELEMENT_ID';
	var DISCARD_MEDIA_ELEMENT_ID = 'MEDIA_DISCARD_MEDIA_ELEMENT_ID';
	function actionCreators() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    _ref$scope = _ref.scope,
	    scope = _ref$scope === void 0 ? 'default' : _ref$scope;
	  return {
	    togglePlaying: function togglePlaying() {
	      return pageAction(TOGGLE_PLAYING);
	    },
	    play: function play() {
	      return pageAction(PLAY);
	    },
	    playAndFadeIn: function playAndFadeIn(_ref2) {
	      var fadeDuration = _ref2.fadeDuration;
	      return pageAction(PLAY_AND_FADE_IN, {
	        fadeDuration: fadeDuration
	      });
	    },
	    pause: function pause() {
	      return pageAction(PAUSE);
	    },
	    fadeOutAndPause: function fadeOutAndPause(_ref3) {
	      var fadeDuration = _ref3.fadeDuration;
	      return pageAction(FADE_OUT_AND_PAUSE, {
	        fadeDuration: fadeDuration
	      });
	    },
	    changeVolumeFactor: function changeVolumeFactor(volumeFactor, _ref4) {
	      var fadeDuration = _ref4.fadeDuration;
	      return pageAction(CHANGE_VOLUME_FACTOR, {
	        volumeFactor: volumeFactor,
	        fadeDuration: fadeDuration
	      });
	    },
	    playFailed: function playFailed() {
	      return pageAction(PLAY_FAILED);
	    },
	    playingMuted: function playingMuted() {
	      return pageAction(PLAYING_MUTED);
	    },
	    scrubTo: function scrubTo(time) {
	      return pageAction(SCRUB_TO, {
	        time: time
	      });
	    },
	    seekTo: function seekTo(time) {
	      return pageAction(SEEK_TO, {
	        time: time
	      });
	    },
	    prebuffer: function prebuffer() {
	      return pageAction(PREBUFFER);
	    },
	    prebuffered: function prebuffered() {
	      return pageAction(PREBUFFERED);
	    },
	    abortPrebuffering: function abortPrebuffering() {
	      return pageAction(ABORT_PREBUFFERING);
	    },
	    bufferUnderrun: function bufferUnderrun() {
	      return pageAction(BUFFER_UNDERRUN);
	    },
	    bufferUnderrunContinue: function bufferUnderrunContinue() {
	      return pageAction(BUFFER_UNDERRUN_CONTINUE);
	    },
	    playing: function playing() {
	      return pageAction(PLAYING);
	    },
	    paused: function paused() {
	      return pageAction(PAUSED);
	    },
	    timeUpdate: function timeUpdate(_ref5) {
	      var currentTime = _ref5.currentTime,
	        duration = _ref5.duration;
	      return pageAction(TIME_UPDATE, {
	        currentTime: currentTime,
	        duration: duration
	      });
	    },
	    metaDataLoaded: function metaDataLoaded(_ref6) {
	      var currentTime = _ref6.currentTime,
	        duration = _ref6.duration;
	      return pageAction(META_DATA_LOADED, {
	        currentTime: currentTime,
	        duration: duration
	      });
	    },
	    progress: function progress(_ref7) {
	      var bufferedEnd = _ref7.bufferedEnd;
	      return pageAction(PROGRESS, {
	        bufferedEnd: bufferedEnd
	      });
	    },
	    ended: function ended() {
	      return pageAction(ENDED);
	    },
	    seeking: function seeking() {
	      return pageAction(SEEKING);
	    },
	    seeked: function seeked() {
	      return pageAction(SEEKED);
	    },
	    waiting: function waiting() {
	      return pageAction(WAITING);
	    },
	    hasNotBeenPlayingForAMoment: function hasNotBeenPlayingForAMoment(value) {
	      return pageAction(HAS_NOT_BEEN_PLAYING_FOR_A_MOMENT);
	    },
	    userInteraction: function userInteraction() {
	      return pageAction(USER_INTERACTION);
	    },
	    userIdle: function userIdle() {
	      return pageAction(USER_IDLE);
	    },
	    controlsEntered: function controlsEntered() {
	      return pageAction(CONTROLS_ENTERED);
	    },
	    controlsLeft: function controlsLeft() {
	      return pageAction(CONTROLS_LEFT);
	    },
	    focusEnteredControls: function focusEnteredControls() {
	      return pageAction(FOCUS_ENTERED_CONTROLS);
	    },
	    focusLeftControls: function focusLeftControls() {
	      return pageAction(FOCUS_LEFT_CONTROLS);
	    },
	    controlsHidden: function controlsHidden() {
	      return pageAction(CONTROLS_HIDDEN);
	    },
	    showInfoBoxDuringPlayback: function showInfoBoxDuringPlayback() {
	      return pageAction(SHOW_INFO_BOX_DURING_PLAYBACK);
	    },
	    hideInfoBoxDuringPlayback: function hideInfoBoxDuringPlayback() {
	      return pageAction(HIDE_INFO_BOX_DURING_PLAYBACK);
	    },
	    toggleInfoBoxDuringPlayback: function toggleInfoBoxDuringPlayback() {
	      return pageAction(TOGGLE_INFO_BOX_DURING_PLAYBACK);
	    },
	    saveMediaElementId: function saveMediaElementId(id) {
	      return pageAction(SAVE_MEDIA_ELEMENT_ID, {
	        id: id
	      });
	    },
	    discardMediaElementId: function discardMediaElementId() {
	      return pageAction(DISCARD_MEDIA_ELEMENT_ID);
	    }
	  };
	  function pageAction(type) {
	    var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    return {
	      type: type,
	      meta: {
	        collectionName: 'pages',
	        mediaScope: scope
	      },
	      payload: payload
	    };
	  }
	}
	function updateTextTrackSettings(textTrack) {
	  return update({
	    property: 'textTrack',
	    value: textTrack ? {
	      srclang: textTrack.srclang,
	      kind: textTrack.kind
	    } : {}
	  });
	}
	function updateVideoQualitySetting(value) {
	  return update({
	    property: 'videoQuality',
	    value: value
	  });
	}

	function muted(state) {
	  return state.backgroundMedia.muted;
	}

	function playerState() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    _ref$scope = _ref.scope,
	    scope = _ref$scope === void 0 ? 'default' : _ref$scope;
	  return pageState("media.".concat(scope));
	}
	function playerActions() {
	  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    _ref2$scope = _ref2.scope,
	    scope = _ref2$scope === void 0 ? 'default' : _ref2$scope;
	  return function (dispatch) {
	    return bindActionCreators(actionCreators({
	      scope: scope
	    }), dispatch);
	  };
	}
	function textTracks(_ref3) {
	  var file = _ref3.file,
	    _ref3$defaultTextTrac = _ref3.defaultTextTrackFileId,
	    defaultTextTrackFileId = _ref3$defaultTextTrac === void 0 ? function () {} : _ref3$defaultTextTrac;
	  return memoizedSelector(setting({
	    property: 'textTrack'
	  }), setting({
	    property: 'volume'
	  }), t$1, locale, nestedFiles('textTrackFiles', {
	    parent: file
	  }), defaultTextTrackFileId, function (textTrackSettings, volume, translate, currentLocale, textTrackFiles, defaultTextTrackFileId) {
	    textTrackSettings = textTrackSettings || {};
	    var files = textTrackFiles.map(function (textTrackFile) {
	      return _objectSpread2({
	        displayLabel: displayLabel(textTrackFile, translate)
	      }, textTrackFile);
	    });
	    var autoFile = autoTextTrackFile(files, defaultTextTrackFileId, currentLocale, volume);
	    return {
	      files: files.sort(function (file1, file2) {
	        return (file1.displayLabel || '').localeCompare(file2.displayLabel || '');
	      }),
	      autoFile: autoFile,
	      activeFileId: getActiveTextTrackFileId(files, autoFile, textTrackSettings),
	      mode: textTrackSettings.kind == 'off' ? 'off' : textTrackSettings.kind ? 'user' : 'auto'
	    };
	  });
	}
	function autoTextTrackFile(textTrackFiles, defaultTextTrackFileId, locale, volume) {
	  if (defaultTextTrackFileId) {
	    var defaultTextTrackFile = textTrackFiles.find(function (textTrackFile) {
	      return textTrackFile.permaId == defaultTextTrackFileId;
	    });
	    if (defaultTextTrackFile) {
	      return defaultTextTrackFile;
	    }
	  }
	  var subtitlesInEntryLanguage = textTrackFiles.find(function (textTrackFile) {
	    return textTrackFile.kind == 'subtitles' && textTrackFile.srclang == locale;
	  });
	  var captionsForMutedVideo = volume == 0 && textTrackFiles.find(function (textTrackFile) {
	    return textTrackFile.kind == 'captions';
	  });
	  return subtitlesInEntryLanguage || captionsForMutedVideo;
	}
	function displayLabel(textTrackFile, t) {
	  return textTrackFile.label || t('pageflow.public.languages.' + textTrackFile.srclang || 'unknown', {
	    defaultValue: t('pageflow.public.languages.unknown')
	  });
	}
	function getActiveTextTrackFileId(textTrackFiles, autoTextTrackFile, options) {
	  if (options.kind == 'off') {
	    return null;
	  }
	  var file = textTrackFiles.find(function (textTrackFile) {
	    return textTrackFile.srclang == options.srclang && textTrackFile.kind == options.kind;
	  });
	  if (file) {
	    return file.id;
	  }
	  return autoTextTrackFile && autoTextTrackFile.id;
	}
	function videoQualitySetting() {
	  return setting({
	    property: 'videoQuality'
	  });
	}
	function pageShouldAutoplay(_ref4) {
	  var autoplayWhenBackgroundMediaMuted = _ref4.autoplayWhenBackgroundMediaMuted,
	    id = _ref4.id;
	  return memoizedSelector(autoplayWhenBackgroundMediaMuted, pageHasAutoplayOption({
	    id: id
	  }), muted, function (autoplayWhenBackgroundMediaMuted, autoplayOption, isBackgroudMediaMuted) {
	    return autoplayOption && (!isBackgroudMediaMuted || autoplayWhenBackgroundMediaMuted);
	  });
	}
	function pageHasAutoplayOption(options) {
	  return memoizedSelector(pageAttribute('autoplay', options), function (autoplayOption) {
	    return autoplayOption !== false;
	  });
	}

	function MediaPlayerControls(props) {
	  var actions = props.playerActions;
	  var playerState = props.playerState;
	  var onTextTracksMenuItemClick = function onTextTracksMenuItemClick(value) {
	    if (value == 'off') {
	      props.updateTextTrackSettings({
	        kind: 'off'
	      });
	    } else {
	      props.updateTextTrackSettings(props.textTracks.files.find(function (textTrackFile) {
	        return textTrackFile.id == value;
	      }));
	    }
	  };
	  var PlayerControls = props.playerControlsComponent;
	  return /*#__PURE__*/React$1__default.createElement(PlayerControls, Object.assign({
	    hasProgress: true,
	    controlBarText: props.controlBarText,
	    isLoading: playerState.isLoading || playerState.bufferUnderrun,
	    isPlaying: playerState.shouldPlay,
	    currentTime: playerState.scrubbingAt !== undefined ? playerState.scrubbingAt : playerState.currentTime,
	    bufferedEnd: playerState.bufferedEnd,
	    duration: playerState.duration,
	    mediaElementId: playerState.mediaElementId,
	    onPlayButtonClick: actions.togglePlaying,
	    onScrub: actions.scrubTo,
	    onSeek: actions.seekTo,
	    onMouseEnter: actions.controlsEntered,
	    onMouseLeave: actions.controlsLeft,
	    onFocus: actions.focusEnteredControls,
	    onBlur: actions.focusLeftControls,
	    watchVisibility: playerState.isPlaying,
	    onHidden: actions.controlsHidden,
	    additionalMenuBarButtons: additionalMenuBarButtons(props),
	    infoBoxHiddenDuringPlayback: infoBoxHiddenDuringPlayback(props),
	    onAdditionalButtonMouseEnter: actions.showInfoBoxDuringPlayback,
	    onAdditionalButtonMouseLeave: actions.hideInfoBoxDuringPlayback,
	    onAdditionalButtonClick: actions.toggleInfoBoxDuringPlayback,
	    qualityMenuItems: qualityMenuItems(props.qualities, props.file, props.activeQuality, props.t),
	    qualityMenuButtonTitle: props.t('pageflow.public.media_quality'),
	    onQualityMenuItemClick: props.updateVideoQualitySetting,
	    textTracksMenuItems: textTracksMenuItems(props.textTracks, props.t),
	    textTracksMenuButtonTitle: props.t('pageflow.public.text_tracks'),
	    onTextTracksMenuItemClick: onTextTracksMenuItemClick
	  }, props, {
	    className: className$7(playerState)
	  }));
	}
	MediaPlayerControls.defaultProps = {
	  playerControlsComponent: PlayerControls$1,
	  qualities: [],
	  textTracks: {
	    files: []
	  }
	};
	var MediaPlayerControls$1 = connect(combine$1({
	  activeQuality: videoQualitySetting(),
	  t: t$1
	}), {
	  updateTextTrackSettings: updateTextTrackSettings,
	  updateVideoQualitySetting: updateVideoQualitySetting
	})(MediaPlayerControls);
	function className$7(playerState) {
	  return classnames(playerStateClassNames(playerState));
	}
	function additionalMenuBarButtons(props) {
	  var t = props.t;
	  if (isEmpty(props.infoBox)) {
	    return [];
	  }
	  return [{
	    name: 'toggleInfoBox',
	    className: 'player_controls-toggle_info_box_menu_button',
	    label: t('pageflow.public.toggle_info_box'),
	    iconName: 'toggleInfoBox'
	  }];
	}
	function infoBoxHiddenDuringPlayback(props) {
	  var playerState = props.playerState;
	  if (playerState.infoBoxHiddenDuringPlayback === undefined) {
	    return !!props.textTracks.activeFileId;
	  } else {
	    return playerState.infoBoxHiddenDuringPlayback;
	  }
	}
	function textTracksMenuItems(textTracks, t) {
	  if (!textTracks.files.length) {
	    return [];
	  }
	  var offItem = {
	    value: 'off',
	    label: t('pageflow.public.text_track_modes.none'),
	    active: textTracks.mode == 'off'
	  };
	  var autoItem = {
	    value: 'auto',
	    label: textTracks.autoFile ? t('pageflow.public.text_track_modes.auto', {
	      label: textTracks.autoFile.displayLabel
	    }) : t('pageflow.public.text_track_modes.auto_off'),
	    active: textTracks.mode == 'auto'
	  };
	  return [autoItem, offItem].concat(textTracks.files.map(function (textTrackFile) {
	    return {
	      value: textTrackFile.id,
	      label: textTrackFile.displayLabel,
	      active: textTracks.mode == 'user' && textTrackFile.id == textTracks.activeFileId
	    };
	  }));
	}
	function qualityMenuItems(qualities, videoFile, activeQuality, t) {
	  activeQuality = activeQuality || 'auto';
	  return availableQualities(qualities, videoFile).map(function (value) {
	    return {
	      value: value,
	      label: t("pageflow.public.video_qualities.labels.".concat(value)),
	      annotation: t("pageflow.public.video_qualities.annotations.".concat(value), {
	        defaultValue: ''
	      }),
	      active: value == activeQuality
	    };
	  });
	}
	function availableQualities(qualities, videoFile) {
	  if (!videoFile) {
	    return [];
	  }
	  return qualities.filter(function (quality) {
	    return !!videoFile.urls[quality] || quality == 'auto';
	  });
	}

	function NonJsLinks(props) {
	  if (!props.file) {
	    return /*#__PURE__*/React.createElement("noscript", null);
	  }
	  return /*#__PURE__*/React.createElement("p", {
	    className: "non_js_video"
	  }, /*#__PURE__*/React.createElement("a", {
	    href: url(props),
	    target: "_blank"
	  }, text$1(props)));
	}
	function url(_ref) {
	  var entrySlug = _ref.entrySlug,
	    file = _ref.file;
	  var type = file.collectionName == 'videoFiles' ? 'videos' : 'audio';
	  return "/".concat(entrySlug, "/").concat(type, "/").concat(file.id);
	}
	function text$1(_ref2) {
	  var file = _ref2.file,
	    t = _ref2.t;
	  var type = file.collectionName == 'videoFiles' ? 'video' : 'audio';
	  return t("pageflow.public.open_".concat(type));
	}
	var NonJsLinks$1 = connect(combine$1({
	  t: t$1,
	  entrySlug: entryAttribute('slug')
	}))(NonJsLinks);

	var pageScrollerMarginBottom = memoizedSelector(pageState('media.pageScrollerMargin'), function (pageState) {
	  return pageState && pageState.bottom;
	});

	function MediaPage(props) {
	  var page = props.page;
	  var playerState = props.playerState;
	  var infoBox = {
	    title: page.additionalTitle,
	    description: page.additionalDescription
	  };
	  return /*#__PURE__*/React.createElement(_default, {
	    className: pageWraperClassName(props.className, willAutoplay(props), props.textTracks, playerState)
	  }, /*#__PURE__*/React.createElement(PageBackground, {
	    pageHasPlayerControls: true
	  }, props.children, /*#__PURE__*/React.createElement(PageShadow, {
	    page: page,
	    className: playerStateClassNames(playerState)
	  })), /*#__PURE__*/React.createElement(PageForeground, {
	    onInteraction: function onInteraction() {
	      return playerState.userIsIdle && props.playerActions.userInteraction();
	    },
	    classNames: playerStateClassNames(playerState)
	  }, /*#__PURE__*/React.createElement(MediaPlayerControls$1, {
	    file: props.file,
	    textTracks: props.textTracks,
	    playerState: playerState,
	    playerActions: props.playerActions,
	    qualities: props.qualities,
	    controlBarText: props.controlBarText,
	    infoBox: infoBox,
	    playerControlsComponent: props.playerControlsComponent
	  }), /*#__PURE__*/React.createElement(PageScroller$1, {
	    className: playerStateClassNames(playerState),
	    marginBottom: props.dynamicPageScrollerMargin && props.pageScrollerMarginBottom
	  }, /*#__PURE__*/React.createElement(_default$1, {
	    page: page
	  }), /*#__PURE__*/React.createElement(PagePrintImage$1, {
	    page: page
	  }), /*#__PURE__*/React.createElement(PageText, {
	    page: page,
	    marginBottom: props.dynamicPageScrollerMargin ? 'none' : 'for_player_controls'
	  }, /*#__PURE__*/React.createElement(NonJsLinks$1, {
	    file: props.file
	  })))));
	}
	MediaPage.defaultProps = {
	  playerControlsCanOverlapPageText: true
	};
	var MediaPage$1 = connectInPage(combine$1({
	  pageScrollerMarginBottom: pageScrollerMarginBottom,
	  textTracks: textTracks({
	    file: prop('file'),
	    defaultTextTrackFileId: prop('page.defaultTextTrackFileId')
	  }),
	  hasAutoplaySupport: has$3('autoplay support'),
	  shouldAutoplay: pageShouldAutoplay({
	    id: prop('page.permaId'),
	    autoplayWhenBackgroundMediaMuted: prop('autoplayWhenBackgroundMediaMuted')
	  })
	}))(MediaPage);
	function willAutoplay(props) {
	  return props.shouldAutoplay && props.hasAutoplaySupport && !props.playerState.playFailed;
	}
	function pageWraperClassName(className, autoplay, textTracks, playerState) {
	  return classnames(className, {
	    'has_text_tracks': !!textTracks.activeFileId,
	    'is_idle': playerState.isPlaying && playerState.userIsIdle,
	    'is_control_bar_focused': playerState.focusInsideControls,
	    'is_control_bar_hovered': playerState.userHoveringControls,
	    'is_control_bar_hidden': playerState.controlsHidden,
	    'unplayed': playerState.unplayed && !autoplay,
	    'should_play': playerState.shouldPlay,
	    'has_played': playerState.hasPlayed
	  });
	}

	function PageFilePlayer(props) {
	  var fileReady = props.file && props.file.isReady;
	  if (fileReady) {
	    var StructuredDataComponent = props.structuredDataComponent || function () {
	      return null;
	    };
	    return /*#__PURE__*/React.createElement("div", {
	      style: {
	        height: '100%'
	      }
	    }, renderFile(props), /*#__PURE__*/React.createElement(StructuredDataComponent, {
	      file: props.file
	    }));
	  } else {
	    return /*#__PURE__*/React.createElement("noscript", null);
	  }
	}
	function renderFile(props) {
	  if (props.pageIsPrepared) {
	    var FilePlayer = props.playerComponent;
	    return /*#__PURE__*/React.createElement(FilePlayer, {
	      file: props.file,
	      posterImageFile: props.posterImageFile,
	      playerState: props.playerState,
	      playerActions: props.playerActions,
	      atmoDuringPlayback: props.atmoDuringPlayback,
	      fit: props.fit,
	      position: props.position,
	      loop: props.loop,
	      muted: props.muted,
	      playsInline: props.playsInline,
	      defaultTextTrackFileId: props.defaultTextTrackFileId,
	      textTracksEnabled: props.textTracksEnabled,
	      textTrackPosition: props.textTrackPosition
	    });
	  } else if (props.preloadComponent && props.pageIsPreloaded) {
	    var Preload = props.preloadComponent;
	    return /*#__PURE__*/React.createElement(Preload, {
	      file: props.file,
	      posterImageFile: props.posterImageFile
	    });
	  } else {
	    return /*#__PURE__*/React.createElement("noscript", null);
	  }
	}
	var PageFilePlayer$1 = connectInPage(combine$1({
	  pageIsPrepared: pageIsPrepared(),
	  pageIsPreloaded: pageIsPreloaded(),
	  atmoDuringPlayback: pageAttribute('atmoDuringPlayback'),
	  defaultTextTrackFileId: pageAttribute('defaultTextTrackFileId')
	}))(PageFilePlayer);

	function _callSuper$e(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }

	// This component acts as an isolation layer between React and
	// Video.js. During initialization, Video.js rearranges the DOM,
	// wraps the video tag into a div and adds further elements.
	//
	// While the original media tag could easily be built using React,
	// once the DOM has been changed, there is no secure way to update the
	// tag using React.
	//
	// To avoid this problem, this component allows re-rendering the
	// media tag while discarding all changes made by Video.js. This is
	// achieved by constructing the media tag as a detached DOM node and
	// replacing the inner HTML of the element.
	//
	// The `onSetup`/`onDispose` callback props can be used to
	// re-initialize Video.js on a fresh media tag.
	//
	// The component performs a deep comparison of its props to decide
	// whether the media tag has to be refreshed.
	var MediaTag = /*#__PURE__*/function (_React$Component) {
	  _inherits(MediaTag, _React$Component);
	  function MediaTag() {
	    _classCallCheck(this, MediaTag);
	    return _callSuper$e(this, MediaTag, arguments);
	  }
	  _createClass(MediaTag, [{
	    key: "render",
	    value: function render() {
	      var _this = this;
	      return /*#__PURE__*/React$1__default.createElement("div", {
	        ref: function ref(element) {
	          return _this.containerElement = element;
	        },
	        dangerouslySetInnerHTML: this.mediaTagHTML()
	      });
	    }
	  }, {
	    key: "shouldComponentUpdate",
	    value: function shouldComponentUpdate(nextProps) {
	      return nextProps.tagName !== this.props.tagName || nextProps.poster !== this.props.poster || nextProps.loop !== this.props.loop || nextProps.muted !== this.props.muted || nextProps.playsInline !== this.props.playsInline || !deepEqual(nextProps.sources, this.props.sources) || !deepEqual(nextProps.tracks, this.props.tracks);
	    }
	  }, {
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      this.triggerOnSetup();
	    }
	  }, {
	    key: "componentWillUpdate",
	    value: function componentWillUpdate() {
	      this.triggerOnDispose();
	    }
	  }, {
	    key: "componentDidUpdate",
	    value: function componentDidUpdate() {
	      this.triggerOnSetup();
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      this.triggerOnDispose();
	    }
	  }, {
	    key: "triggerOnSetup",
	    value: function triggerOnSetup() {
	      if (this.props.onSetup) {
	        this.props.onSetup(this.containerElement.firstElementChild);
	      }
	    }
	  }, {
	    key: "triggerOnDispose",
	    value: function triggerOnDispose() {
	      if (this.props.onDispose) {
	        this.props.onDispose();
	      }
	    }
	  }, {
	    key: "mediaTagHTML",
	    value: function mediaTagHTML() {
	      var wrapper = document.createElement('div');
	      var mediaElement = document.createElement(this.props.tagName);
	      mediaElement.setAttribute('preload', 'none');
	      mediaElement.setAttribute('crossorigin', 'anonymous');
	      mediaElement.setAttribute('alt', this.props.alt);
	      if (this.props.poster) {
	        mediaElement.setAttribute('data-poster', this.props.poster);
	      }
	      if (this.props.loop) {
	        mediaElement.setAttribute('loop', 'true');
	      }
	      if (this.props.muted) {
	        mediaElement.setAttribute('muted', 'true');
	      }
	      if (this.props.playsInline) {
	        mediaElement.setAttribute('playsinline', 'true');
	      }
	      this.props.sources.forEach(function (source) {
	        var sourceElement = document.createElement('source');
	        sourceElement.setAttribute('src', source.src);
	        sourceElement.setAttribute('type', source.type);
	        mediaElement.appendChild(sourceElement);
	      });
	      this.props.tracks.forEach(function (track) {
	        var trackElement = document.createElement('track');
	        trackElement.setAttribute('src', track.src);
	        trackElement.setAttribute('id', track.id);
	        trackElement.setAttribute('kind', track.kind);
	        trackElement.setAttribute('srclang', track.srclang);
	        trackElement.setAttribute('label', track.label);
	        mediaElement.appendChild(trackElement);
	      });
	      wrapper.appendChild(mediaElement);
	      return {
	        __html: wrapper.innerHTML.replace('preload="none"', 'preload="auto"')
	      };
	    }
	  }]);
	  return MediaTag;
	}(React$1__default.Component);
	MediaTag.defaultProps = {
	  tagName: 'video',
	  sources: [],
	  tracks: []
	};

	// This function assumes that that the parameters are arrays of
	// objects containing only skalar values. It is not a full deep
	// equality check, but  suffices for the use case.
	function deepEqual(a, b) {
	  if (a.length !== b.length) {
	    return false;
	  }
	  for (var i = 0; i < a.length; i++) {
	    var aItem = a[i];
	    var bItem = b[i];
	    if (Object.keys(aItem).length !== Object.keys(bItem).length) {
	      return false;
	    }
	    for (var key in aItem) {
	      if (aItem[key] !== bItem[key]) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	function createPageflowPlayer(element, _ref) {
	  var emulateTextTracksDisplay = _ref.emulateTextTracksDisplay,
	    atmoSettings = _ref.atmoSettings,
	    mediaContext = _ref.mediaContext,
	    playsInline = _ref.playsInline;
	  var isAudio = element.tagName.toLowerCase() == 'audio';
	  var player = new pageflow.VideoPlayer(element, {
	    controlBar: false,
	    loadingSpinner: false,
	    bigPlayButton: false,
	    errorDisplay: false,
	    textTrackSettings: false,
	    poster: element.getAttribute('data-poster'),
	    html5: {
	      nativeCaptions: !isAudio && pageflow.browser.has('iphone platform')
	    },
	    bufferUnderrunWaiting: true,
	    useSlimPlayerControlsDuringPhonePlayback: !playsInline && !isAudio,
	    fullscreenDuringPhonePlayback: !playsInline && !isAudio,
	    fallbackToMutedAutoplay: !isAudio,
	    volumeFading: true,
	    hooks: pageflow.atmo.createMediaPlayerHooks(atmoSettings),
	    mediaEvents: true,
	    context: mediaContext
	  });
	  player.textTrackSettings = {
	    getValues: function getValues() {
	      return {};
	    }
	  };
	  player.addClass('video-js');
	  player.addClass('player');
	  return player;
	}

	function watchPlayer (player, actions) {
	  player.on('loadedmetadata', function () {
	    return actions.metaDataLoaded({
	      currentTime: player.currentTime(),
	      duration: player.duration()
	    });
	  });
	  player.on('progress', function () {
	    return actions.progress({
	      bufferedEnd: player.bufferedEnd()
	    });
	  });
	  player.on('play', actions.playing);
	  player.on('playfailed', actions.playFailed);
	  player.on('playmuted', actions.playingMuted);
	  player.on('pause', actions.paused);
	  player.on('waiting', actions.waiting);
	  player.on('seeking', actions.seeking);
	  player.on('seeked', actions.seeked);
	  player.on('bufferunderrun', actions.bufferUnderrun);
	  player.on('bufferunderruncontinue', actions.bufferUnderrunContinue);
	  player.on('timeupdate', function () {
	    return actions.timeUpdate({
	      currentTime: player.currentTime(),
	      duration: player.duration()
	    });
	  });
	  player.on('ended', actions.ended);
	}

	function initPlayer(player, getPlayerState, playerActions, prevFileId, fileId) {
	  var playerState = getPlayerState();
	  if (fileId === prevFileId) {
	    if (playerState.currentTime > 0) {
	      player.currentTime(playerState.currentTime);
	    }
	  }
	  if (playerState.shouldPrebuffer) {
	    player.prebuffer().then(playerActions.prebuffered, function () {});
	  }
	  if (playerState.isPlaying) {
	    player.play();
	  }
	  player.on('canplay', function () {
	    if (getPlayerState().shouldPlay && player.paused()) {
	      player.play();
	    }
	  });
	}
	function updatePlayer(player, playerState, nextPlayerState, playerActions) {
	  if (!playerState.shouldPrebuffer && nextPlayerState.shouldPrebuffer) {
	    player.prebuffer().then(function () {
	      return setTimeout(playerActions.prebuffered, 0);
	    });
	  }
	  if (!playerState.shouldPlay && nextPlayerState.shouldPlay) {
	    if (nextPlayerState.fadeDuration) {
	      player.playAndFadeIn(nextPlayerState.fadeDuration);
	    } else {
	      player.play();
	    }
	  } else if (playerState.shouldPlay && !nextPlayerState.shouldPlay && nextPlayerState.isPlaying) {
	    if (nextPlayerState.fadeDuration) {
	      player.fadeOutAndPause(nextPlayerState.fadeDuration);
	    } else {
	      player.pause();
	    }
	  }
	  if (nextPlayerState.shouldSeekTo !== undefined && nextPlayerState.shouldSeekTo !== playerState.shouldSeekTo) {
	    player.currentTime(nextPlayerState.shouldSeekTo);
	  }
	}

	function initTextTracks(player, getActiveTexTrackFileId, getPosition) {
	  player.on('pause', function () {
	    updateOnNextPlay(player, getActiveTexTrackFileId, getPosition);
	  });
	  player.textTracks().on('addtrack', function () {
	    updateTextTracks(player, null, getActiveTexTrackFileId(), getPosition());
	  });
	  updateTextTracks(player, null, getActiveTexTrackFileId(), getPosition());
	  updateOnNextPlay(player, getActiveTexTrackFileId, getPosition);
	}
	function updateOnNextPlay(player, getActiveTexTrackFileId, getPosition) {
	  player.one('timeupdate', function () {
	    updateTextTracks(player, null, getActiveTexTrackFileId(), getPosition());
	  });
	}
	function updateTextTracks(player, prevActiveTextTrackFileId, activeTextTrackFileId, position) {
	  if (prevActiveTextTrackFileId != activeTextTrackFileId) {
	    updateMode(player, activeTextTrackFileId);
	  }
	  updatePosition(player, position);
	}
	function updateMode(player, activeTextTrackFileId) {
	  [].slice.call(player.textTracks()).forEach(function (textTrack) {
	    if (textTrack.id == "text_track_file_".concat(activeTextTrackFileId)) {
	      textTrack.mode = 'showing';
	    } else {
	      textTrack.mode = 'disabled';
	    }
	  });
	}
	function updatePosition(player, position) {
	  player.updateCueLineSettings(position);
	}
	function textTracksFromFiles(textTrackFiles, textTracksEnabled) {
	  if (!textTracksEnabled) {
	    return [];
	  }
	  return textTrackFiles.filter(function (textTrackFile) {
	    return textTrackFile.isReady;
	  }).map(function (textTrackFile) {
	    return {
	      id: "text_track_file_".concat(textTrackFile.id),
	      kind: textTrackFile.kind,
	      label: textTrackFile.displayLabel,
	      srclang: textTrackFile.srclang,
	      src: textTrackFile.urls.vtt
	    };
	  });
	}

	function widgetPresent(typeName) {
	  return function (state) {
	    return state.widgetPresence[typeName];
	  };
	}

	function isFeatureEnabled(name) {
	  return function (state) {
	    return state.features.indexOf(name) >= 0;
	  };
	}

	function _callSuper$f(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	function createFilePlayer (_ref) {
	  var tagName = _ref.tagName,
	    sources = _ref.sources,
	    _ref$poster = _ref.poster,
	    poster = _ref$poster === void 0 ? function () {} : _ref$poster,
	    _ref$emulateTextTrack = _ref.emulateTextTracksDisplay,
	    emulateTextTracksDisplay = _ref$emulateTextTrack === void 0 ? false : _ref$emulateTextTrack,
	    _ref$createPlayer = _ref.createPlayer,
	    createPlayer = _ref$createPlayer === void 0 ? createPageflowPlayer : _ref$createPlayer;
	  var FilePlayer = /*#__PURE__*/function (_React$Component) {
	    _inherits(FilePlayer, _React$Component);
	    function FilePlayer(props, context) {
	      var _this;
	      _classCallCheck(this, FilePlayer);
	      _this = _callSuper$f(this, FilePlayer, [props, context]);
	      _this.displaysTextTracksInNativePlayer = _this.props.hasNativeVideoPlayer && tagName == 'video';
	      _this.initiallyMuted = _this.props.muted;
	      _this.updateAtmoSettings();
	      _this.setupMediaTag = function (element) {
	        _this.player = createPlayer(element, {
	          emulateTextTracksDisplay: emulateTextTracksDisplay,
	          atmoSettings: _this.atmoSettings,
	          mediaContext: _this.context.mediaContext,
	          playsInline: props.playsInline
	        });
	        _this.player.ready(function () {
	          _this.props.playerActions.saveMediaElementId(element.id);
	          initPlayer(_this.player, function () {
	            return _this.props.playerState;
	          }, _this.props.playerActions, _this.prevFileId, _this.props.file.id);
	          if (!_this.displaysTextTracksInNativePlayer) {
	            initTextTracks(_this.player, function () {
	              return _this.props.textTracks.activeFileId;
	            }, function () {
	              return _this.props.textTrackPosition;
	            });
	          }
	          watchPlayer(_this.player, _this.props.playerActions);
	          _this.prevFileId = _this.props.file.id;
	        }, true);
	      };
	      _this.disposeMediaTag = function () {
	        _this.player.dispose();
	        _this.player = null;
	        _this.props.playerActions.discardMediaElementId();
	      };
	      return _this;
	    }
	    _createClass(FilePlayer, [{
	      key: "componentDidUpdate",
	      value: function componentDidUpdate(prevProps) {
	        var _this2 = this;
	        if (!this.player) {
	          return;
	        }
	        this.player.ready(function () {
	          updatePlayerMuted(_this2.player, prevProps.muted, _this2.props.muted);
	          updatePlayerVolumeFactor(_this2.player, prevProps.playerState.volumeFactor, _this2.props.playerState.volumeFactor, _this2.props.playerState.volumeFactorFadeDuration);
	          updatePlayer(_this2.player, prevProps.playerState, _this2.props.playerState, _this2.props.playerActions);
	        }, true);
	        if (!this.displaysTextTracksInNativePlayer) {
	          updateTextTracks(this.player, prevProps.textTracks.activeFileId, this.props.textTracks.activeFileId, this.props.textTrackPosition);
	        }
	        this.updateAtmoSettings();
	      }
	    }, {
	      key: "updateAtmoSettings",
	      value: function updateAtmoSettings() {
	        this.atmoSettings = this.atmoSettings || {};
	        this.atmoSettings['atmo_during_playback'] = this.props.atmoDuringPlayback;
	      }
	    }, {
	      key: "render",
	      value: function render() {
	        return /*#__PURE__*/React$1__default.createElement(MediaTag, {
	          tagName: tagName,
	          sources: sources(this.props.file, this.props.quality, {
	            hasHighBandwidth: this.props.hasHighBandwidth,
	            hasBrokenOggSupport: this.props.hasBrokenOggSupport,
	            forceBestQuality: this.props.forceBestQuality,
	            forceFullhdQuality: this.props.forceFullhdQuality
	          }),
	          tracks: textTracksFromFiles(this.props.textTracks.files, this.props.textTracksEnabled),
	          poster: poster(this.props.file, this.props.posterImageFile),
	          loop: this.props.loop,
	          muted: this.initiallyMuted,
	          playsInline: this.props.playsInline,
	          alt: this.props.file.alt,
	          onSetup: this.setupMediaTag,
	          onDispose: this.disposeMediaTag
	        });
	      }
	    }]);
	    return FilePlayer;
	  }(React$1__default.Component);
	  FilePlayer.contextTypes = {
	    mediaContext: React$1__default.PropTypes.object
	  };
	  FilePlayer.defaultProps = {
	    textTracksEnabled: true,
	    textTracks: {
	      files: []
	    }
	  };
	  var result = connect(combine$1({
	    textTracks: textTracks({
	      file: prop('file'),
	      defaultTextTrackFileId: prop('defaultTextTrackFileId')
	    }),
	    quality: setting({
	      property: 'videoQuality'
	    }),
	    hasNativeVideoPlayer: has$3('native video player'),
	    hasHighBandwidth: has$3('high bandwidth'),
	    hasBrokenOggSupport: has$3('broken ogg support'),
	    forceBestQuality: isFeatureEnabled('force_best_video_quality'),
	    forceFullhdQuality: isFeatureEnabled('force_fullhd_video_quality'),
	    textTrackPosition: textTrackPosition
	  }), {
	    updateTextTrackSettings: updateTextTrackSettings
	  })(FilePlayer);
	  result.WrappedComponent = FilePlayer;
	  return result;
	}
	var slimPlayerControlsPresent = widgetPresent('slimPlayerControls');
	function textTrackPosition(state, _ref2) {
	  var playerState = _ref2.playerState,
	    textTrackPosition = _ref2.textTrackPosition;
	  if (textTrackPosition) {
	    return textTrackPosition;
	  }
	  if (slimPlayerControlsPresent(state)) {
	    // see pageflow.VideoPlayer#updateCueLineSettings for explanation of values.
	    if (playerState.controlsHidden) {
	      return 'auto.lazy';
	    } else {
	      return 'auto.translated';
	    }
	  } else {
	    return playerState.controlsHidden ? 'auto.lazy' : 'top';
	  }
	}
	function updatePlayerMuted(player, prevMuted, muted) {
	  if (prevMuted !== muted) {
	    player.muted(muted);
	  }
	}
	function updatePlayerVolumeFactor(player, prevVolumeFactor, volumeFactor, fadeDuration) {
	  if (prevVolumeFactor !== volumeFactor) {
	    player.changeVolumeFactor(volumeFactor, fadeDuration);
	  }
	}

	var AudioFilePlayer = createFilePlayer({
	  tagName: 'audio',
	  sources: function sources(audioFile, _, _ref) {
	    var hasBrokenOggSupport = _ref.hasBrokenOggSupport;
	    return [!hasBrokenOggSupport && {
	      type: 'audio/ogg',
	      src: "".concat(audioFile.urls.ogg, "?u=1")
	    }, {
	      type: 'audio/mp4',
	      src: "".concat(audioFile.urls.m4a, "?u=1")
	    }, {
	      type: 'audio/mp3',
	      src: "".concat(audioFile.urls.mp3, "?u=1")
	    }].filter(Boolean);
	  },
	  emulateTextTracksDisplay: true
	});

	function ensureProtocol(protocol, url) {
	  if (url && url.match(/^\/\//)) {
	    return "".concat(protocol, ":").concat(url);
	  }
	  return url;
	}

	function formatTimeDuration(durationInMs) {
	  var seconds = Math.round(durationInMs / 1000) % 60;
	  var minutes = Math.floor(durationInMs / 1000 / 60) % 60;
	  var hours = Math.floor(durationInMs / 1000 / 60 / 60);
	  var result = 'PT';
	  if (hours > 0) {
	    result += "".concat(hours, "H");
	  }
	  if (minutes > 0) {
	    result += "".concat(minutes, "M");
	  }
	  if (seconds > 0 || minutes == 0 && hours == 0) {
	    result += "".concat(seconds, "S");
	  }
	  return result;
	}

	function StructuredData(_ref) {
	  var data = _ref.data,
	    isEnabled = _ref.isEnabled;
	  if (isEnabled) {
	    return /*#__PURE__*/React.createElement("script", {
	      type: "application/ld+json",
	      dangerouslySetInnerHTML: {
	        __html: JSON.stringify(data)
	      }
	    });
	  } else {
	    return null;
	  }
	}
	var StructuredData$1 = connect(combine$1({
	  isEnabled: isFeatureEnabled('structured_data')
	}))(StructuredData);

	function VideoStructuredData(_ref) {
	  var file = _ref.file,
	    entryPublishedAt = _ref.entryPublishedAt;
	  var data = {
	    '@context': 'http://schema.org',
	    '@type': 'AudioObject',
	    name: file.basename,
	    description: file.alt,
	    url: ensureProtocol('https', file.urls.mp3),
	    duration: formatTimeDuration(file.durationInMs),
	    datePublished: entryPublishedAt,
	    uploadDate: file.createdAt,
	    copyrightHolder: {
	      '@type': 'Organization',
	      name: file.rights
	    }
	  };
	  return /*#__PURE__*/React.createElement(StructuredData$1, {
	    data: data
	  });
	}
	var AudioStructuredData = connect(combine$1({
	  entryPublishedAt: entryAttribute('publishedAt')
	}))(VideoStructuredData);

	function PageAudioFilePlayer(props) {
	  return /*#__PURE__*/React.createElement(PageFilePlayer$1, Object.assign({}, props, {
	    playerComponent: AudioFilePlayer,
	    structuredDataComponent: AudioStructuredData
	  }));
	}

	function getDimensions (videoFile, fit, position, wrapperDimensions) {
	  if (!wrapperDimensions || !wrapperDimensions.height || !fit || fit == 'contain') {
	    return;
	  }
	  var videoWidth, videoHeight, factor;
	  var videoRatio = videoFile.width / videoFile.height;
	  var wrapperRatio = wrapperDimensions.width / wrapperDimensions.height;
	  var scaleToFit = wrapperRatio > videoRatio ? 'width' : 'height';
	  if (scaleToFit == 'width') {
	    videoHeight = wrapperDimensions.height;
	    videoWidth = videoHeight * videoRatio;
	    factor = wrapperDimensions.width / videoWidth;
	  } else {
	    videoWidth = wrapperDimensions.width;
	    videoHeight = videoWidth / videoRatio;
	    factor = wrapperDimensions.height / videoHeight;
	  }
	  if (fit == 'smart_contain' && factor > 1.2) {
	    return;
	  }
	  var width = videoWidth * factor;
	  var height = videoHeight * factor;
	  var positionX = position[0] !== undefined && fit == 'cover' ? position[0] : 50;
	  var positionY = position[1] !== undefined && fit == 'cover' ? position[1] : 50;
	  return {
	    left: (wrapperDimensions.width - width) * positionX / 100,
	    top: (wrapperDimensions.height - height) * positionY / 100,
	    width: width,
	    height: height
	  };
	}

	function cueOffsetClassName(dimensions, wrapperDimensions) {
	  if (!dimensions || !wrapperDimensions) {
	    return;
	  }
	  var clippedSizeLeft = Math.max(0, -dimensions.left);
	  var clippedSizeRight = Math.max(0, dimensions.width - wrapperDimensions.width + dimensions.left);
	  var clippedSizeTop = Math.max(0, -dimensions.top);
	  var clippedSizeBottom = Math.max(0, dimensions.height - wrapperDimensions.height + dimensions.top);
	  return ['cue_offset', "cue_offset_".concat(Math.ceil(clippedSizeBottom / 10)), "cue_margin_left_".concat(Math.ceil(clippedSizeLeft / 10)), "cue_margin_right_".concat(Math.ceil(clippedSizeRight / 10)), "cue_margin_top_".concat(Math.ceil(clippedSizeTop / 10)), "cue_margin_bottom_".concat(Math.ceil(clippedSizeBottom / 10))].join(' ');
	}

	function Positioner(props) {
	  return /*#__PURE__*/React$1__default.createElement(Measure, {
	    whitelist: ['width', 'height'],
	    cloneOptions: {
	      noCloneOnZeroDimension: true
	    }
	  }, function (wrapperDimensions) {
	    return renderWrapper(props, wrapperDimensions);
	  });
	}
	function renderWrapper(props, wrapperDimensions) {
	  var dimensions = getDimensions(props.videoFile, props.fit, props.position, wrapperDimensions);
	  return /*#__PURE__*/React$1__default.createElement("div", {
	    className: "uncropped_media_wrapper"
	  }, /*#__PURE__*/React$1__default.createElement("div", {
	    className: cueOffsetClassName(dimensions, wrapperDimensions),
	    style: style$1(dimensions)
	  }, props.children));
	}
	function style$1(dimensions) {
	  return dimensions && _objectSpread2({
	    position: 'absolute'
	  }, dimensions);
	}

	function sources (videoFile, quality) {
	  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	    hasHighBandwidth = _ref.hasHighBandwidth,
	    forceBestQuality = _ref.forceBestQuality,
	    forceFullhdQuality = _ref.forceFullhdQuality;
	  quality = quality || 'auto';
	  if (forceBestQuality) {
	    return [{
	      type: 'video/mp4',
	      src: videoFile.urls['4k'] || videoFile.urls.fullhd || videoFile.urls.high
	    }];
	  }
	  if (forceFullhdQuality) {
	    return [{
	      type: 'video/mp4',
	      src: videoFile.urls.fullhd || videoFile.urls.high
	    }];
	  } else if (quality == 'auto') {
	    var fallbackQuality = hasHighBandwidth ? 'high' : 'medium';
	    var result = [{
	      type: 'application/x-mpegURL',
	      src: "".concat(videoFile.urls['hls-playlist'], "?u=1")
	    }, {
	      type: 'video/mp4',
	      src: "".concat(videoFile.urls[fallbackQuality], "?u=1")
	    }];
	    if (videoFile.urls['dash-playlist']) {
	      result = [{
	        type: 'application/dash+xml',
	        src: "".concat(videoFile.urls['dash-playlist'])
	      }].concat(result);
	    }
	    return result;
	  } else {
	    if (!videoFile.urls[quality]) {
	      quality = 'high';
	    }
	    return [{
	      type: 'video/mp4',
	      src: "".concat(videoFile.urls[quality], "?u=1")
	    }];
	  }
	}

	function _callSuper$g(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var FilePlayer = createFilePlayer({
	  tagName: 'video',
	  sources: sources,
	  poster: poster
	});
	function VideoFilePlayer(props) {
	  return /*#__PURE__*/React$1__default.createElement(Positioner, {
	    videoFile: props.file,
	    fit: props.fit,
	    position: props.position
	  }, /*#__PURE__*/React$1__default.createElement(FilePlayer, {
	    file: props.file,
	    posterImageFile: props.posterImageFile,
	    playerState: props.playerState,
	    playerActions: props.playerActions,
	    atmoDuringPlayback: props.atmoDuringPlayback,
	    defaultTextTrackFileId: props.defaultTextTrackFileId,
	    textTracksEnabled: props.textTracksEnabled,
	    loop: props.loop,
	    muted: props.muted,
	    playsInline: props.playsInline
	  }));
	}
	var VideoFilePlayerPreload = /*#__PURE__*/function (_React$Component) {
	  _inherits(VideoFilePlayerPreload, _React$Component);
	  function VideoFilePlayerPreload() {
	    _classCallCheck(this, VideoFilePlayerPreload);
	    return _callSuper$g(this, VideoFilePlayerPreload, arguments);
	  }
	  _createClass(VideoFilePlayerPreload, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      var _this$props = this.props,
	        file = _this$props.file,
	        posterImageFile = _this$props.posterImageFile,
	        preloadImage = _this$props.preloadImage;
	      var posterUrl = poster(file, posterImageFile);
	      if (posterUrl) {
	        preloadImage(posterUrl);
	      }
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return null;
	    }
	  }]);
	  return VideoFilePlayerPreload;
	}(React$1__default.Component);
	VideoFilePlayerPreload.defaultProps = {
	  preloadImage: preloadImage
	};
	function poster(videoFile, posterImageFile) {
	  var style = has$2('mobile platform') ? 'medium' : 'large';
	  return posterImageFile ? posterImageFile.urls[style] : videoFile.urls["poster_".concat(style)];
	}

	function VideoStructuredData$1(_ref) {
	  var file = _ref.file,
	    entryPublishedAt = _ref.entryPublishedAt;
	  var data = {
	    '@context': 'http://schema.org',
	    '@type': 'VideoObject',
	    name: file.basename,
	    description: file.alt,
	    url: ensureProtocol('https', file.urls.high),
	    thumbnailUrl: ensureProtocol('https', file.urls.poster_medium),
	    width: file.width,
	    height: file.height,
	    duration: formatTimeDuration(file.durationInMs),
	    datePublished: entryPublishedAt,
	    uploadDate: file.createdAt,
	    copyrightHolder: {
	      '@type': 'Organization',
	      name: file.rights
	    }
	  };
	  return /*#__PURE__*/React.createElement(StructuredData$1, {
	    data: data
	  });
	}
	var VideoStructuredData$2 = connect(combine$1({
	  entryPublishedAt: entryAttribute('publishedAt')
	}))(VideoStructuredData$1);

	function PageVideoFilePlayer(props) {
	  return /*#__PURE__*/React.createElement(PageFilePlayer$1, Object.assign({}, props, {
	    playerComponent: VideoFilePlayer,
	    preloadComponent: VideoFilePlayerPreload,
	    structuredDataComponent: VideoStructuredData$2
	  }));
	}
	var VideoPlayer = connect(combine$1({
	  file: file('videoFiles', {
	    id: prop('videoFileId')
	  }),
	  posterImageFile: file('imageFiles', {
	    id: prop('posterImageFileId')
	  }),
	  muted: muted$1
	}))(PageVideoFilePlayer);
	function muted$1(state, props) {
	  return props.muted || muted(state);
	}
	function PageVideoPlayer(props) {
	  var page = props.page;
	  var videoProperty = camelize.concat(props.propertyNamePrefix, props.videoPropertyBaseName);
	  var posterProperty = camelize.concat(props.propertyNamePrefix, props.posterImagePropertyBaseName);
	  return /*#__PURE__*/React.createElement(VideoPlayer, {
	    videoFileId: page["".concat(videoProperty, "Id")],
	    posterImageFileId: page["".concat(posterProperty, "Id")],
	    playerState: props.playerState,
	    playerActions: props.playerActions,
	    fit: props.fit,
	    position: [page["".concat(videoProperty, "X")], page["".concat(videoProperty, "Y")]],
	    textTracksEnabled: props.textTracksEnabled,
	    loop: props.loop,
	    muted: props.muted,
	    playsInline: props.playsInline
	  });
	}
	PageVideoPlayer.defaultProps = {
	  videoPropertyBaseName: 'videoFile',
	  posterImagePropertyBaseName: 'posterImage',
	  fit: 'smart_contain'
	};

	function _callSuper$h(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var PlayerMediaContextProvider = /*#__PURE__*/function (_React$Component) {
	  _inherits(PlayerMediaContextProvider, _React$Component);
	  function PlayerMediaContextProvider() {
	    _classCallCheck(this, PlayerMediaContextProvider);
	    return _callSuper$h(this, PlayerMediaContextProvider, arguments);
	  }
	  _createClass(PlayerMediaContextProvider, [{
	    key: "getChildContext",
	    value: function getChildContext() {
	      return {
	        mediaContext: _objectSpread2(_objectSpread2({}, this.context.mediaContext), {}, {
	          playbackMode: this.props.playbackMode,
	          playerDescription: this.props.playerDescription
	        })
	      };
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return this.props.children;
	    }
	  }]);
	  return PlayerMediaContextProvider;
	}(React$1__default.Component);
	PlayerMediaContextProvider.contextTypes = {
	  mediaContext: React$1__default.PropTypes.object
	};
	PlayerMediaContextProvider.childContextTypes = {
	  mediaContext: React$1__default.PropTypes.object
	};

	function MobilePageVideoPoster(props) {
	  var candidate = findCandidate(props);
	  if (candidate) {
	    return /*#__PURE__*/React.createElement(PageBackgroundImage, {
	      page: props.page,
	      propertyBaseName: candidate.propertyBaseName,
	      fileCollection: candidate.collection
	    });
	  } else {
	    return /*#__PURE__*/React.createElement("noscript", null);
	  }
	}
	function findCandidate(props) {
	  return candidates(props.propertyNamePrefix).find(function (candidate) {
	    return props.fileExists(candidate.collection, props.page["".concat(candidate.propertyBaseName, "Id")]);
	  });
	}
	function candidates(prefix) {
	  return [{
	    propertyBaseName: camelize.concat(prefix, 'mobilePosterImage'),
	    collection: 'imageFiles'
	  }, {
	    propertyBaseName: camelize.concat(prefix, 'posterImage'),
	    collection: 'imageFiles'
	  }, {
	    propertyBaseName: camelize.concat(prefix, 'videoFile'),
	    collection: 'videoFiles'
	  }];
	}
	var MobilePageVideoPoster$1 = connect(combine$1({
	  fileExists: fileExists()
	}))(MobilePageVideoPoster);

	function PageBackgroundVideo(props) {
	  if (props.hasMobilePlatform && mobilePosterExists(props)) {
	    return /*#__PURE__*/React.createElement(MobilePageVideoPoster$1, {
	      page: props.page,
	      propertyNamePrefix: props.propertyNamePrefix
	    });
	  } else {
	    return /*#__PURE__*/React.createElement(PlayerMediaContextProvider, {
	      playbackMode: "loop",
	      playerDescription: "Background Video Player"
	    }, /*#__PURE__*/React.createElement(PageVideoPlayer, Object.assign({
	      loop: true,
	      fit: "cover",
	      muted: !props.hasAutoplaySupport,
	      playsInline: true,
	      textTracksEnabled: false
	    }, props)));
	  }
	}
	function mobilePosterExists(props) {
	  var property = camelize.concat(props.propertyNamePrefix, 'mobilePosterImageId');
	  return props.fileExists('imageFiles', props.page[property]);
	}
	var PageBackgroundVideo$1 = connect(combine$1({
	  fileExists: fileExists(),
	  hasMobilePlatform: has$3('mobile platform'),
	  hasAutoplaySupport: has$3('autoplay support')
	}))(PageBackgroundVideo);

	function ImageStructuredData(_ref) {
	  var file = _ref.file,
	    entryPublishedAt = _ref.entryPublishedAt;
	  if (file) {
	    var data = {
	      '@context': 'http://schema.org',
	      '@type': 'ImageObject',
	      name: file.basename,
	      description: file.alt,
	      url: ensureProtocol('https', file.urls.large),
	      width: file.width,
	      height: file.height,
	      datePublished: entryPublishedAt,
	      uploadDate: file.createdAt,
	      copyrightHolder: {
	        '@type': 'Organization',
	        name: file.rights
	      }
	    };
	    return /*#__PURE__*/React.createElement(StructuredData$1, {
	      data: data
	    });
	  } else {
	    return null;
	  }
	}
	var ImageStructuredData$1 = connect(combine$1({
	  file: file('imageFiles', {
	    id: prop('fileId')
	  }),
	  entryPublishedAt: entryAttribute('publishedAt')
	}))(ImageStructuredData);

	function PageBackgroundAsset(_ref) {
	  var page = _ref.page,
	    playerState = _ref.playerState,
	    playerActions = _ref.playerActions,
	    propertyNamePrefix = _ref.propertyNamePrefix;
	  var typePropertyName = camelize.concat(propertyNamePrefix, 'backgroundType');
	  if (page[typePropertyName] == 'video') {
	    return /*#__PURE__*/React.createElement(PageBackgroundVideo$1, {
	      page: page,
	      playerState: playerState,
	      playerActions: playerActions,
	      propertyNamePrefix: propertyNamePrefix
	    });
	  } else {
	    return /*#__PURE__*/React.createElement(PageBackgroundImage, {
	      page: page,
	      propertyNamePrefix: propertyNamePrefix,
	      structuredDataComponent: ImageStructuredData$1
	    });
	  }
	}
	var PageBackgroundAsset$1 = connectInPage(combine$1({
	  page: pageAttributes(),
	  playerState: playerState({
	    scope: 'background'
	  })
	}), combine({
	  playerActions: playerActions({
	    scope: 'background'
	  })
	}))(PageBackgroundAsset);

	function MediaPageBackground(props) {
	  return /*#__PURE__*/React.createElement(PageBackground, null, /*#__PURE__*/React.createElement(PageBackgroundAsset$1, {
	    propertyNamePrefix: props.propertyNamePrefix
	  }), /*#__PURE__*/React.createElement(PageShadow, {
	    page: props.page
	  }));
	}

	function InfoBox$1(props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: "waveform_player_controls-info_box"
	  }, renderTitle(props), renderDescription(props));
	}
	function renderTitle(props) {
	  if (!isBlank(props.title)) {
	    return /*#__PURE__*/React.createElement("h3", {
	      className: titleClassName(props)
	    }, props.title);
	  }
	}
	function titleClassName(props) {
	  var titleAndDescriptionPresent = !isBlank(props.title) && !isBlank(props.description);
	  return classnames('waveform_player_controls-info_box-title', {
	    'waveform_player_controls-info_box-title-with_separator': titleAndDescriptionPresent
	  });
	}
	function renderDescription(props) {
	  if (!isBlank(props.description)) {
	    return /*#__PURE__*/React.createElement("p", {
	      className: "waveform_player_controls-info_box-description",
	      dangerouslySetInnerHTML: {
	        __html: props.description
	      }
	    });
	  }
	}

	var SET_BOTTOM = 'MEDIA_PAGE_SCROLLER_MARGIN_SET_BOTTOM';
	function setPageScrollerMarginBottom(value) {
	  return {
	    type: SET_BOTTOM,
	    payload: {
	      value: value
	    },
	    meta: {
	      collectionName: 'pages'
	    }
	  };
	}

	function Container$2(props) {
	  return /*#__PURE__*/React.createElement(Measure, {
	    whitelist: ['height'],
	    onMeasure: function onMeasure(_ref) {
	      var height = _ref.height;
	      return props.setPageScrollerMarginBottom(height);
	    }
	  }, /*#__PURE__*/React.createElement("div", {
	    className: "waveform_player_controls-container"
	  }, props.children));
	}
	var Container$3 = connectInPage(null, {
	  setPageScrollerMarginBottom: setPageScrollerMarginBottom
	})(Container$2);

	function PlayButton$2(props) {
	  return /*#__PURE__*/React.createElement("a", {
	    href: "#",
	    className: className$8(props),
	    id: props.id,
	    tabIndex: "4",
	    title: props.title,
	    onClick: clickHandler$1(props)
	  }, /*#__PURE__*/React.createElement(Icon, {
	    name: props.isPlaying ? 'pause' : 'play'
	  }));
	}
	var PlayButton$3 = pageSkipLinkTarget(PlayButton$2);
	function className$8(props) {
	  return classnames('waveform_player_controls-play_button', {
	    'waveform_player_controls-play_button-inverted': props.inverted
	  });
	}
	function clickHandler$1(props) {
	  return function (event) {
	    event.preventDefault();
	    if (props.onClick) {
	      props.onClick();
	    }
	  };
	}

	function mainColor(state) {
	  return state.theme.mainColor;
	}

	var waveColor = 'rgba(170, 170, 170, 1)';
	var waveColorForInvertedPage = 'rgba(0, 0, 0, 0.5)';
	var cursorColor = '#fff';
	var cursorColorForInvertedPage = '#888';
	function Waveform(props) {
	  if (props.pageIsPrepared && props.mediaElementId) {
	    return /*#__PURE__*/React.createElement(Measure, {
	      whitelist: ['height']
	    }, function (_ref) {
	      var height = _ref.height;
	      return /*#__PURE__*/React.createElement("div", {
	        className: "waveform_player_controls-wave"
	      }, /*#__PURE__*/React.createElement("div", {
	        className: "waveform_player_controls-wave_wrapper"
	      }, /*#__PURE__*/React.createElement(Wavesurfer, {
	        mediaElt: "#".concat(props.mediaElementId),
	        options: {
	          normalize: true,
	          removeMediaElementOnDestroy: false,
	          hideScrollbar: true,
	          progressColor: props.waveformColor || props.mainColor,
	          waveColor: props.inverted ? waveColorForInvertedPage : waveColor,
	          cursorColor: props.inverted ? cursorColorForInvertedPage : cursorColor,
	          height: height
	        }
	      }), /*#__PURE__*/React.createElement(PlayButton$3, {
	        isPlaying: props.isPlaying,
	        title: props.playButtonTitle,
	        inverted: props.inverted,
	        onClick: props.onPlayButtonClick
	      })));
	    });
	  } else {
	    return null;
	  }
	}
	var Waveform$1 = connectInPage(combine$1({
	  pageIsPrepared: pageIsPrepared(),
	  waveformColor: pageAttribute('waveformColor'),
	  mainColor: mainColor
	}))(Waveform);

	function TimesDisplay(props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: "waveform_player_controls-times_display"
	  }, /*#__PURE__*/React.createElement(TimeDisplay, {
	    value: props.currentTime,
	    className: "waveform_player_controls-times_display-current_time"
	  }), "/", /*#__PURE__*/React.createElement(TimeDisplay, {
	    value: props.duration,
	    className: "waveform_player_controls-times_display-duration"
	  }));
	}

	function WaveformPlayerControls(props) {
	  return /*#__PURE__*/React.createElement("div", {
	    className: className$9(props)
	  }, /*#__PURE__*/React.createElement(Container$3, null, /*#__PURE__*/React.createElement(Waveform$1, {
	    isPlaying: props.isPlaying,
	    inverted: props.inverted,
	    playButtonTitle: props.playButtonTitle,
	    mediaElementId: props.mediaElementId,
	    onPlayButtonClick: props.onPlayButtonClick
	  }), /*#__PURE__*/React.createElement(TimesDisplay, {
	    currentTime: props.currentTime,
	    duration: props.duration
	  }), /*#__PURE__*/React.createElement(InfoBox$1, props.infoBox)), /*#__PURE__*/React.createElement(MenuBar, {
	    inverted: props.inverted,
	    qualityMenuButtonTitle: props.qualityMenuButtonTitle,
	    qualityMenuItems: props.qualityMenuItems,
	    onQualityMenuItemClick: props.onQualityMenuItemClick,
	    textTracksMenuButtonTitle: props.textTracksMenuButtonTitle,
	    textTracksMenuItems: props.textTracksMenuItems,
	    hiddenOnPhone: !props.isPlaying,
	    onTextTracksMenuItemClick: props.onTextTracksMenuItemClick
	  }));
	}
	var WaveformPlayerControls$1 = connectInPage(combine$1({
	  inverted: pageAttribute('invert')
	}))(WaveformPlayerControls);
	function className$9(props) {
	  return classnames('waveform_player_controls', {
	    'waveform_player_controls-inverted': props.inverted
	  });
	}

	var HOTKEY_SPACE = 'HOTKEY_SPACE';
	var HOTKEY_TAB = 'HOTKEY_TAB';
	function space(_ref) {
	  var currentPageId = _ref.currentPageId;
	  return pageAction(HOTKEY_SPACE, currentPageId);
	}
	function tab(_ref2) {
	  var currentPageId = _ref2.currentPageId;
	  return pageAction(HOTKEY_TAB, currentPageId);
	}

	function createReducer () {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    _ref$scope = _ref.scope,
	    scope = _ref$scope === void 0 ? 'default' : _ref$scope;
	  return function reducer() {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var action = arguments.length > 1 ? arguments[1] : undefined;
	    if (action.meta && action.meta.mediaScope && action.meta.mediaScope !== scope) {
	      return state;
	    }
	    switch (action.type) {
	      case PAGE_WILL_ACTIVATE:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          hasPlayed: false,
	          unplayed: true,
	          infoBoxHiddenDuringPlayback: undefined,
	          userIsIdle: false
	        });
	      case PAGE_WILL_DEACTIVATE:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldPrebuffer: false
	        });
	      case PLAY:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldPlay: true,
	          playFailed: false,
	          hasBeenPlayingJustNow: true,
	          unplayed: false,
	          fadeDuration: null,
	          isLoading: true
	        });
	      case PLAYING:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldPlay: true,
	          isPlaying: true
	        });
	      case PLAY_FAILED:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldPlay: false,
	          playFailed: true,
	          hasBeenPlayingJustNow: false,
	          unplayed: true,
	          fadeDuration: null,
	          isLoading: false
	        });
	      case PLAY_AND_FADE_IN:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldPlay: true,
	          hasBeenPlayingJustNow: true,
	          fadeDuration: action.payload.fadeDuration,
	          isLoading: true
	        });
	      case PAUSE:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldPlay: false,
	          fadeDuration: null,
	          isLoading: false
	        });
	      case PAUSED:
	        if (state.bufferUnderrun) {
	          return _objectSpread2(_objectSpread2({}, state), {}, {
	            isPlaying: false,
	            hasPlayed: true
	          });
	        }
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldPlay: false,
	          isPlaying: false,
	          fadeDuration: null,
	          isLoading: false
	        });
	      case FADE_OUT_AND_PAUSE:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldPlay: false,
	          fadeDuration: action.payload.fadeDuration,
	          isLoading: false
	        });
	      case CHANGE_VOLUME_FACTOR:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          volumeFactor: action.payload.volumeFactor,
	          volumeFactorFadeDuration: action.payload.fadeDuration
	        });
	      case PREBUFFER:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldPrebuffer: true
	        });
	      case PREBUFFERED:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldPrebuffer: false
	        });
	      case WAITING:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          isLoading: true
	        });
	      case BUFFER_UNDERRUN:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          bufferUnderrun: true
	        });
	      case BUFFER_UNDERRUN_CONTINUE:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          bufferUnderrun: false
	        });
	      case SCRUB_TO:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          scrubbingAt: action.payload.time
	        });
	      case SEEK_TO:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldSeekTo: action.payload.time
	        });
	      case SEEKING:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          isLoading: true
	        });
	      case SEEKED:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          scrubbingAt: undefined,
	          isLoading: false
	        });
	      case META_DATA_LOADED:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          currentTime: action.payload.currentTime,
	          duration: action.payload.duration
	        });
	      case PROGRESS:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          bufferedEnd: action.payload.bufferedEnd
	        });
	      case TIME_UPDATE:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          currentTime: action.payload.currentTime,
	          duration: action.payload.duration,
	          isLoading: false
	        });
	      case ENDED:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          shouldPlay: false,
	          isPlaying: false
	        });
	      case HAS_NOT_BEEN_PLAYING_FOR_A_MOMENT:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          hasBeenPlayingJustNow: false
	        });
	      case HOTKEY_TAB:
	      case USER_INTERACTION:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          userIsIdle: false,
	          controlsHidden: false
	        });
	      case USER_IDLE:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          userIsIdle: true
	        });
	      case CONTROLS_ENTERED:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          userHoveringControls: true
	        });
	      case CONTROLS_LEFT:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          userHoveringControls: false
	        });
	      case FOCUS_ENTERED_CONTROLS:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          focusInsideControls: true
	        });
	      case FOCUS_LEFT_CONTROLS:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          focusInsideControls: false
	        });
	      case CONTROLS_HIDDEN:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          controlsHidden: true,
	          infoBoxHiddenDuringPlayback: true
	        });
	      case HIDE_INFO_BOX_DURING_PLAYBACK:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          infoBoxHiddenDuringPlayback: true
	        });
	      case SHOW_INFO_BOX_DURING_PLAYBACK:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          infoBoxHiddenDuringPlayback: false
	        });
	      case TOGGLE_INFO_BOX_DURING_PLAYBACK:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          infoBoxHiddenDuringPlayback: !state.infoBoxHiddenDuringPlayback
	        });
	      case SAVE_MEDIA_ELEMENT_ID:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          mediaElementId: action.payload.id
	        });
	      case DISCARD_MEDIA_ELEMENT_ID:
	        return _objectSpread2(_objectSpread2({}, state), {}, {
	          mediaElementId: null
	        });
	      default:
	        return state;
	    }
	  };
	}

	function pageScrollerMarginReducer () {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case SET_BOTTOM:
	      return _objectSpread2(_objectSpread2({}, state), {}, {
	        bottom: action.payload.value
	      });
	    default:
	      return state;
	  }
	}

	function _regeneratorRuntime$4() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$4 = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	var _marked$2 = /*#__PURE__*/_regeneratorRuntime$4().mark(_callee$1);
	function _callee$1() {
	  return _regeneratorRuntime$4().wrap(function _callee$(_context) {
	    while (1) switch (_context.prev = _context.next) {
	      case 0:
	        _context.next = 2;
	        return lib_7([HOTKEY_SPACE, TOGGLE_PLAYING], toggle$1, actionCreators());
	      case 2:
	      case "end":
	        return _context.stop();
	    }
	  }, _marked$2);
	}
	function toggle$1(_ref) {
	  var play = _ref.play,
	    pause = _ref.pause;
	  return /*#__PURE__*/_regeneratorRuntime$4().mark(function _callee2() {
	    var state;
	    return _regeneratorRuntime$4().wrap(function _callee2$(_context2) {
	      while (1) switch (_context2.prev = _context2.next) {
	        case 0:
	          _context2.next = 2;
	          return select(playerState());
	        case 2:
	          state = _context2.sent;
	          if (!state.shouldPlay) {
	            _context2.next = 8;
	            break;
	          }
	          _context2.next = 6;
	          return put(pause());
	        case 6:
	          _context2.next = 12;
	          break;
	        case 8:
	          _context2.next = 10;
	          return call(function () {
	            return pageflow.backgroundMedia.unmute();
	          });
	        case 10:
	          _context2.next = 12;
	          return put(play());
	        case 12:
	        case "end":
	          return _context2.stop();
	      }
	    }, _callee2);
	  })();
	}

	function _regeneratorRuntime$5() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$5 = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	var _marked$3 = /*#__PURE__*/_regeneratorRuntime$5().mark(_callee$2),
	  _marked2$1 = /*#__PURE__*/_regeneratorRuntime$5().mark(muteBackgoundAudio);
	function _callee$2() {
	  return _regeneratorRuntime$5().wrap(function _callee$(_context) {
	    while (1) switch (_context.prev = _context.next) {
	      case 0:
	        _context.next = 2;
	        return lib_7([PLAY_FAILED, PLAYING_MUTED], muteBackgoundAudio);
	      case 2:
	      case "end":
	        return _context.stop();
	    }
	  }, _marked$3);
	}
	function muteBackgoundAudio() {
	  return _regeneratorRuntime$5().wrap(function muteBackgoundAudio$(_context2) {
	    while (1) switch (_context2.prev = _context2.next) {
	      case 0:
	        _context2.next = 2;
	        return call(function () {
	          return pageflow.backgroundMedia.mute();
	        });
	      case 2:
	      case "end":
	        return _context2.stop();
	    }
	  }, _marked2$1);
	}

	var MUTE = 'BACKGROUND_MEDIA_MUTE';
	var UNMUTE = 'BACKGROUND_MEDIA_UNMUTE';
	function mute() {
	  return {
	    type: MUTE
	  };
	}
	function unmute() {
	  return {
	    type: UNMUTE
	  };
	}

	var _marked$4 = /*#__PURE__*/_regeneratorRuntime$6().mark(_callee2),
	  _marked2$2 = /*#__PURE__*/_regeneratorRuntime$6().mark(prebufferAndPlayOnUnmute),
	  _marked3 = /*#__PURE__*/_regeneratorRuntime$6().mark(prebufferAndPlay);
	function _regeneratorRuntime$6() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$6 = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	var _actionCreators = actionCreators(),
	  play = _actionCreators.play,
	  prebuffer = _actionCreators.prebuffer,
	  waiting = _actionCreators.waiting;
	function _callee2(options) {
	  return _regeneratorRuntime$6().wrap(function _callee2$(_context2) {
	    while (1) switch (_context2.prev = _context2.next) {
	      case 0:
	        _context2.next = 2;
	        return lib_7(PAGE_DID_ACTIVATE, /*#__PURE__*/_regeneratorRuntime$6().mark(function _callee(action) {
	          return _regeneratorRuntime$6().wrap(function _callee$(_context) {
	            while (1) switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return [race({
	                  task: call(prebufferAndPlay, options),
	                  cancel: take(PAGE_WILL_DEACTIVATE)
	                }), race({
	                  task: call(prebufferAndPlayOnUnmute, options),
	                  cancel: take(PAGE_WILL_DEACTIVATE)
	                })];
	              case 2:
	              case "end":
	                return _context.stop();
	            }
	          }, _callee);
	        }));
	      case 2:
	      case "end":
	        return _context2.stop();
	    }
	  }, _marked$4);
	}
	function prebufferAndPlayOnUnmute(options) {
	  var _yield$race, unmute;
	  return _regeneratorRuntime$6().wrap(function prebufferAndPlayOnUnmute$(_context3) {
	    while (1) switch (_context3.prev = _context3.next) {
	      case 0:
	        _context3.t0 = options.retryOnUnmute;
	        if (!_context3.t0) {
	          _context3.next = 5;
	          break;
	        }
	        _context3.next = 4;
	        return select(pageHasAutoplayOption());
	      case 4:
	        _context3.t0 = _context3.sent;
	      case 5:
	        if (!_context3.t0) {
	          _context3.next = 12;
	          break;
	        }
	        _context3.next = 8;
	        return race({
	          unmute: take(UNMUTE),
	          cancel: take(PAGE_WILL_DEACTIVATE)
	        });
	      case 8:
	        _yield$race = _context3.sent;
	        unmute = _yield$race.unmute;
	        if (!unmute) {
	          _context3.next = 12;
	          break;
	        }
	        return _context3.delegateYield(prebufferAndPlay(options), "t1", 12);
	      case 12:
	      case "end":
	        return _context3.stop();
	    }
	  }, _marked2$2);
	}
	function prebufferAndPlay(options) {
	  var autoplay;
	  return _regeneratorRuntime$6().wrap(function prebufferAndPlay$(_context4) {
	    while (1) switch (_context4.prev = _context4.next) {
	      case 0:
	        return _context4.delegateYield(autoplayPage(options), "t0", 1);
	      case 1:
	        autoplay = _context4.t0;
	        if (!autoplay) {
	          _context4.next = 5;
	          break;
	        }
	        _context4.next = 5;
	        return put(waiting());
	      case 5:
	        _context4.next = 7;
	        return [take(PREBUFFERED), put(prebuffer())];
	      case 7:
	        if (!autoplay) {
	          _context4.next = 12;
	          break;
	        }
	        _context4.next = 10;
	        return call(lib_4$1, 1000);
	      case 10:
	        _context4.next = 12;
	        return put(play());
	      case 12:
	      case "end":
	        return _context4.stop();
	    }
	  }, _marked3);
	}
	function autoplayPage(_ref) {
	  var canAutoplay = _ref.canAutoplay,
	    _autoplayWhenBackgroundMediaMuted = _ref.autoplayWhenBackgroundMediaMuted;
	  return /*#__PURE__*/_regeneratorRuntime$6().mark(function _callee3() {
	    var shouldAutoplay;
	    return _regeneratorRuntime$6().wrap(function _callee3$(_context5) {
	      while (1) switch (_context5.prev = _context5.next) {
	        case 0:
	          _context5.next = 2;
	          return select(pageShouldAutoplay({
	            autoplayWhenBackgroundMediaMuted: function autoplayWhenBackgroundMediaMuted() {
	              return _autoplayWhenBackgroundMediaMuted;
	            }
	          }));
	        case 2:
	          shouldAutoplay = _context5.sent;
	          return _context5.abrupt("return", shouldAutoplay && canAutoplay);
	        case 4:
	        case "end":
	          return _context5.stop();
	      }
	    }, _callee3);
	  })();
	}

	var _marked$5 = /*#__PURE__*/_regeneratorRuntime$7().mark(_callee3$1);
	function _regeneratorRuntime$7() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$7 = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function _callee3$1() {
	  return _regeneratorRuntime$7().wrap(function _callee3$(_context3) {
	    while (1) switch (_context3.prev = _context3.next) {
	      case 0:
	        _context3.next = 2;
	        return lib_7(PLAY, /*#__PURE__*/_regeneratorRuntime$7().mark(function _callee() {
	          return _regeneratorRuntime$7().wrap(function _callee$(_context) {
	            while (1) switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return select(pageIsActive());
	              case 2:
	                if (!_context.sent) {
	                  _context.next = 5;
	                  break;
	                }
	                _context.next = 5;
	                return call(disable);
	              case 5:
	              case "end":
	                return _context.stop();
	            }
	          }, _callee);
	        }));
	      case 2:
	        _context3.next = 4;
	        return lib_7([PAUSE, ENDED], /*#__PURE__*/_regeneratorRuntime$7().mark(function _callee2() {
	          return _regeneratorRuntime$7().wrap(function _callee2$(_context2) {
	            while (1) switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.next = 2;
	                return select(pageIsActive());
	              case 2:
	                if (!_context2.sent) {
	                  _context2.next = 5;
	                  break;
	                }
	                _context2.next = 5;
	                return call(enable);
	              case 5:
	              case "end":
	                return _context2.stop();
	            }
	          }, _callee2);
	        }));
	      case 4:
	      case "end":
	        return _context3.stop();
	    }
	  }, _marked$5);
	}
	function disable() {
	  pageflow.events.trigger('scroll_indicator:disable');
	}
	function enable() {
	  pageflow.events.trigger('scroll_indicator:enable');
	}

	var _marked$6 = /*#__PURE__*/_regeneratorRuntime$8().mark(_callee3$2);
	function _regeneratorRuntime$8() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$8 = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function _callee3$2() {
	  var _actionCreators, hasNotBeenPlayingForAMoment;
	  return _regeneratorRuntime$8().wrap(function _callee3$(_context3) {
	    while (1) switch (_context3.prev = _context3.next) {
	      case 0:
	        _actionCreators = actionCreators(), hasNotBeenPlayingForAMoment = _actionCreators.hasNotBeenPlayingForAMoment;
	        _context3.next = 3;
	        return lib_7([PAUSE, ENDED], /*#__PURE__*/_regeneratorRuntime$8().mark(function _callee2() {
	          return _regeneratorRuntime$8().wrap(function _callee2$(_context2) {
	            while (1) switch (_context2.prev = _context2.next) {
	              case 0:
	                _context2.next = 2;
	                return race({
	                  task: call( /*#__PURE__*/_regeneratorRuntime$8().mark(function _callee(action) {
	                    return _regeneratorRuntime$8().wrap(function _callee$(_context) {
	                      while (1) switch (_context.prev = _context.next) {
	                        case 0:
	                          _context.next = 2;
	                          return call(lib_4$1, 700);
	                        case 2:
	                          _context.next = 4;
	                          return put(hasNotBeenPlayingForAMoment(false));
	                        case 4:
	                        case "end":
	                          return _context.stop();
	                      }
	                    }, _callee);
	                  })),
	                  cancel: take(PLAYING)
	                });
	              case 2:
	              case "end":
	                return _context2.stop();
	            }
	          }, _callee2);
	        }));
	      case 3:
	      case "end":
	        return _context3.stop();
	    }
	  }, _marked$6);
	}

	function _regeneratorRuntime$9() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$9 = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	var _marked$7 = /*#__PURE__*/_regeneratorRuntime$9().mark(_callee$3),
	  _marked2$3 = /*#__PURE__*/_regeneratorRuntime$9().mark(putAfterDelay);
	function _callee$3() {
	  var _actionCreators, userIdle;
	  return _regeneratorRuntime$9().wrap(function _callee$(_context) {
	    while (1) switch (_context.prev = _context.next) {
	      case 0:
	        _actionCreators = actionCreators(), userIdle = _actionCreators.userIdle;
	        _context.next = 3;
	        return lib_6([PLAY, USER_INTERACTION, HOTKEY_TAB], putAfterDelay, userIdle);
	      case 3:
	      case "end":
	        return _context.stop();
	    }
	  }, _marked$7);
	}
	function putAfterDelay(actionCreator) {
	  return _regeneratorRuntime$9().wrap(function putAfterDelay$(_context2) {
	    while (1) switch (_context2.prev = _context2.next) {
	      case 0:
	        _context2.next = 2;
	        return call(lib_4$1, 3000);
	      case 2:
	        _context2.next = 4;
	        return put(actionCreator());
	      case 4:
	      case "end":
	        return _context2.stop();
	    }
	  }, _marked2$3);
	}

	function _regeneratorRuntime$a() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$a = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function fadeOutWhenPageWillDeactivate () {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    scope = _ref.scope;
	  return /*#__PURE__*/_regeneratorRuntime$a().mark(function _callee2() {
	    var _actionCreators, fadeOutAndPause;
	    return _regeneratorRuntime$a().wrap(function _callee2$(_context2) {
	      while (1) switch (_context2.prev = _context2.next) {
	        case 0:
	          _actionCreators = actionCreators({
	            scope: scope
	          }), fadeOutAndPause = _actionCreators.fadeOutAndPause;
	          _context2.next = 3;
	          return lib_7(PAGE_DID_DEACTIVATE, /*#__PURE__*/_regeneratorRuntime$a().mark(function _callee() {
	            return _regeneratorRuntime$a().wrap(function _callee$(_context) {
	              while (1) switch (_context.prev = _context.next) {
	                case 0:
	                  _context.next = 2;
	                  return put(fadeOutAndPause({
	                    fadeDuration: 400
	                  }));
	                case 2:
	                case "end":
	                  return _context.stop();
	              }
	            }, _callee);
	          }));
	        case 3:
	        case "end":
	          return _context2.stop();
	      }
	    }, _callee2);
	  })();
	}

	var _marked$8 = /*#__PURE__*/_regeneratorRuntime$b().mark(_callee2$1);
	function _regeneratorRuntime$b() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$b = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function _callee2$1() {
	  return _regeneratorRuntime$b().wrap(function _callee2$(_context2) {
	    while (1) switch (_context2.prev = _context2.next) {
	      case 0:
	        _context2.next = 2;
	        return lib_7(ENDED, /*#__PURE__*/_regeneratorRuntime$b().mark(function _callee() {
	          var autoChangePage, pageIsStillActive;
	          return _regeneratorRuntime$b().wrap(function _callee$(_context) {
	            while (1) switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return select(pageAttribute('autoChangePageOnEnded'));
	              case 2:
	                autoChangePage = _context.sent;
	                _context.next = 5;
	                return select(pageIsActive());
	              case 5:
	                pageIsStillActive = _context.sent;
	                if (!(autoChangePage && pageIsStillActive)) {
	                  _context.next = 9;
	                  break;
	                }
	                _context.next = 9;
	                return call(goToNextPage);
	              case 9:
	              case "end":
	                return _context.stop();
	            }
	          }, _callee);
	        }));
	      case 2:
	      case "end":
	        return _context2.stop();
	    }
	  }, _marked$8);
	}
	function goToNextPage() {
	  pageflow.slides.next();
	}

	function _regeneratorRuntime$c() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$c = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function pageSaga () {
	  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  return /*#__PURE__*/_regeneratorRuntime$c().mark(function _callee() {
	    var sagas;
	    return _regeneratorRuntime$c().wrap(function _callee$(_context) {
	      while (1) switch (_context.prev = _context.next) {
	        case 0:
	          sagas = [_callee$1(), _callee$2(), _callee3$1()];
	          if (!options.playsInNativePlayer || !options.playsInNativePlayer()) {
	            sagas.push([_callee2$1(), fadeOutWhenPageWillDeactivate(), _callee3$2()]);
	          }
	          if (!has$2('mobile platform')) {
	            sagas.push([_callee2(_objectSpread2(_objectSpread2({}, options), {}, {
	              canAutoplay: has$2('autoplay support')
	            }))]);
	          }
	          if (options.hideControls) {
	            sagas.push([_callee$3()]);
	          }
	          _context.next = 6;
	          return sagas;
	        case 6:
	        case "end":
	          return _context.stop();
	      }
	    }, _callee);
	  })();
	}

	function _regeneratorRuntime$d() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$d = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function fadeInWhenPageWillActivate () {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	    scope = _ref.scope;
	  return /*#__PURE__*/_regeneratorRuntime$d().mark(function _callee2() {
	    var actions;
	    return _regeneratorRuntime$d().wrap(function _callee2$(_context2) {
	      while (1) switch (_context2.prev = _context2.next) {
	        case 0:
	          actions = actionCreators({
	            scope: scope
	          });
	          _context2.next = 3;
	          return lib_7(PAGE_WILL_ACTIVATE, /*#__PURE__*/_regeneratorRuntime$d().mark(function _callee(action) {
	            return _regeneratorRuntime$d().wrap(function _callee$(_context) {
	              while (1) switch (_context.prev = _context.next) {
	                case 0:
	                  _context.next = 2;
	                  return [race({
	                    task: [put(actions.prebuffer()), call(playSilentlyWhenPrebuffered, actions), call(fadeInOnPageDidActivateAndPrebuffered, actions)],
	                    cancel: take(PAGE_WILL_DEACTIVATE)
	                  })];
	                case 2:
	                case "end":
	                  return _context.stop();
	              }
	            }, _callee);
	          }));
	        case 3:
	        case "end":
	          return _context2.stop();
	      }
	    }, _callee2);
	  })();
	}
	function playSilentlyWhenPrebuffered(_ref2) {
	  var prebuffer = _ref2.prebuffer,
	    changeVolumeFactor = _ref2.changeVolumeFactor,
	    play = _ref2.play;
	  return /*#__PURE__*/_regeneratorRuntime$d().mark(function _callee3() {
	    return _regeneratorRuntime$d().wrap(function _callee3$(_context3) {
	      while (1) switch (_context3.prev = _context3.next) {
	        case 0:
	          _context3.next = 2;
	          return put(changeVolumeFactor(0, {
	            fadeDuration: 0
	          }));
	        case 2:
	          _context3.next = 4;
	          return take(PREBUFFERED);
	        case 4:
	          _context3.next = 6;
	          return put(play());
	        case 6:
	        case "end":
	          return _context3.stop();
	      }
	    }, _callee3);
	  })();
	}
	function fadeInOnPageDidActivateAndPrebuffered(_ref3) {
	  var changeVolumeFactor = _ref3.changeVolumeFactor;
	  return /*#__PURE__*/_regeneratorRuntime$d().mark(function _callee4() {
	    return _regeneratorRuntime$d().wrap(function _callee4$(_context4) {
	      while (1) switch (_context4.prev = _context4.next) {
	        case 0:
	          _context4.next = 2;
	          return [take(PREBUFFERED), take(PAGE_DID_ACTIVATE)];
	        case 2:
	          _context4.next = 4;
	          return put(changeVolumeFactor(1, {
	            fadeDuration: 1000
	          }));
	        case 4:
	        case "end":
	          return _context4.stop();
	      }
	    }, _callee4);
	  })();
	}

	function _regeneratorRuntime$e() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$e = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function reduxModule(options) {
	  return {
	    reducers: {
	      'media.default': createReducer({
	        scope: 'default'
	      }),
	      'media.pageScrollerMargin': pageScrollerMarginReducer
	    },
	    saga: /*#__PURE__*/_regeneratorRuntime$e().mark(function saga() {
	      return _regeneratorRuntime$e().wrap(function saga$(_context) {
	        while (1) switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return pageSaga(options);
	          case 2:
	          case "end":
	            return _context.stop();
	        }
	      }, saga);
	    })
	  };
	}
	var pageBackgroundReduxModule = {
	  reducers: {
	    'media.background': createReducer({
	      scope: 'background'
	    })
	  },
	  saga: /*#__PURE__*/_regeneratorRuntime$e().mark(function saga() {
	    return _regeneratorRuntime$e().wrap(function saga$(_context2) {
	      while (1) switch (_context2.prev = _context2.next) {
	        case 0:
	          _context2.next = 2;
	          return [fadeInWhenPageWillActivate({
	            scope: 'background'
	          }), fadeOutWhenPageWillDeactivate({
	            scope: 'background'
	          }), _callee$2()];
	        case 2:
	        case "end":
	          return _context2.stop();
	      }
	    }, saga);
	  })
	};

	function textIsHidden(state) {
	  return state.hideText.isActive;
	}
	function textHasBeenHidden(state) {
	  return state.hideText.hasBeenActive;
	}

	function _callSuper$i(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }

	/**
	 * @desc
	 * Use to build pages that have a play button to hide the page's text
	 * and allow interacting with elements placed in the {@link
	 * pageflow.react.components.PageBackground|PageBackground}.
	 *
	 * @alias pageflow.react.components.PageWithInteractiveBackground
	 * @class
	 * @since 12.1
	 */
	var PageWithInteractiveBackground = /*#__PURE__*/function (_React$Component) {
	  _inherits(PageWithInteractiveBackground, _React$Component);
	  function PageWithInteractiveBackground(props, context) {
	    var _this;
	    _classCallCheck(this, PageWithInteractiveBackground);
	    _this = _callSuper$i(this, PageWithInteractiveBackground, [props, context]);
	    _this.onPlayButtonClick = function () {
	      pageflow.hideText.activate();
	      if (_this.props.onEnterBackground) {
	        _this.props.onEnterBackground();
	      }
	    };
	    _this.onCloseButtonClick = function () {
	      pageflow.hideText.deactivate();
	      if (_this.props.onLeaveBackground) {
	        _this.props.onLeaveBackground();
	      }
	    };
	    return _this;
	  }
	  _createClass(PageWithInteractiveBackground, [{
	    key: "render",
	    value: function render() {
	      var page = this.props.page;
	      return /*#__PURE__*/React$1__default.createElement(_default, {
	        className: classnames({
	          unplayed: !this.props.textHasBeenHidden
	        }, 'hide_content_with_text')
	      }, /*#__PURE__*/React$1__default.createElement(CloseButton$1, {
	        onClick: this.onCloseButtonClick
	      }), /*#__PURE__*/React$1__default.createElement(MenuBar, {
	        additionalButtons: this.props.additionalMenuBarButtons,
	        onAdditionalButtonClick: this.props.onAdditionalButtonClick,
	        qualityMenuButtonTitle: this.props.qualityMenuButtonTitle,
	        qualityMenuItems: this.props.qualityMenuItems,
	        onQualityMenuItemClick: this.props.onQualityMenuItemClick,
	        hiddenOnPhone: this.props.textHasBeenHidden && !this.props.textIsHidden
	      }), /*#__PURE__*/React$1__default.createElement(PageBackground, {
	        pageHasPlayerControls: true
	      }, /*#__PURE__*/React$1__default.createElement("div", {
	        className: "uncropped_media_wrapper"
	      }, this.props.children), /*#__PURE__*/React$1__default.createElement(PageShadow, {
	        page: page
	      })), /*#__PURE__*/React$1__default.createElement(PageForeground, null, /*#__PURE__*/React$1__default.createElement(PlayerControls$1, {
	        playButtonTitle: "Starten",
	        playButtonIconName: this.props.playButtonIconName,
	        controlBarText: page.controlBarText || this.props.defaultControlBarText,
	        onPlayButtonClick: this.onPlayButtonClick,
	        infoBox: {
	          title: page.additionalTitle,
	          description: page.additionalDescription
	        }
	      }), /*#__PURE__*/React$1__default.createElement(PageScroller$1, null, /*#__PURE__*/React$1__default.createElement(_default$1, {
	        page: page
	      }), /*#__PURE__*/React$1__default.createElement(PageText, {
	        page: page
	      }))));
	    }
	  }]);
	  return PageWithInteractiveBackground;
	}(React$1__default.Component);
	var PageWithInteractiveBackground$1 = connectInPage(combine$1({
	  textIsHidden: textIsHidden,
	  textHasBeenHidden: textHasBeenHidden
	}))(PageWithInteractiveBackground);

	var ACTIVATE = 'HIDE_TEXT_ACTIVATE';
	var DEACTIVATE = 'HIDE_TEXT_DEACTIVATE';
	function activate() {
	  return {
	    type: ACTIVATE
	  };
	}
	function deactivate() {
	  return {
	    type: DEACTIVATE
	  };
	}

	var _marked$9 = /*#__PURE__*/_regeneratorRuntime$f().mark(_callee2$2);
	function _regeneratorRuntime$f() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$f = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function _callee2$2() {
	  return _regeneratorRuntime$f().wrap(function _callee2$(_context2) {
	    while (1) switch (_context2.prev = _context2.next) {
	      case 0:
	        _context2.next = 2;
	        return lib_7(DEACTIVATE, /*#__PURE__*/_regeneratorRuntime$f().mark(function _callee() {
	          return _regeneratorRuntime$f().wrap(function _callee$(_context) {
	            while (1) switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return select(pageIsActive());
	              case 2:
	                if (!_context.sent) {
	                  _context.next = 5;
	                  break;
	                }
	                _context.next = 5;
	                return call(enable$1);
	              case 5:
	              case "end":
	                return _context.stop();
	            }
	          }, _callee);
	        }));
	      case 2:
	      case "end":
	        return _context2.stop();
	    }
	  }, _marked$9);
	}
	function enable$1() {
	  pageflow.events.trigger('scroll_indicator:enable');
	}

	var reduxModule$1 = {
	  name: 'interactivePageBackground',
	  saga: _callee2$2
	};

	function _objectWithoutPropertiesLoose$1(source, excluded) {
	  if (source == null) return {};
	  var target = {};
	  var sourceKeys = Object.keys(source);
	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (excluded.indexOf(key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	function _objectWithoutProperties(source, excluded) {
	  if (source == null) return {};
	  var target = _objectWithoutPropertiesLoose$1(source, excluded);
	  var key, i;

	  if (Object.getOwnPropertySymbols) {
	    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

	    for (i = 0; i < sourceSymbolKeys.length; i++) {
	      key = sourceSymbolKeys[i];
	      if (excluded.indexOf(key) >= 0) continue;
	      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
	      target[key] = source[key];
	    }
	  }

	  return target;
	}

	var _excluded = ["component", "reduxModules"];
	function _regeneratorRuntime$g() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$g = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function PageTypeRegistry() {
	  var pageTypes = [];
	  this.register = function (name, _ref) {
	    var component = _ref.component,
	      _ref$reduxModules = _ref.reduxModules,
	      reduxModules = _ref$reduxModules === void 0 ? [] : _ref$reduxModules,
	      options = _objectWithoutProperties(_ref, _excluded);
	    if (!component) {
	      fail('Requires component option to be present');
	    }
	    if (!Array.isArray(reduxModules)) {
	      fail('Expected reduxModules option to be an array.');
	    }
	    var sagas = [];
	    var reducers = reduxModules.reduce(function (result, module) {
	      if (typeof module !== 'object' || new Set(Object.keys(module).concat(['name', 'reducers', 'saga'])).size != 3) {
	        fail('Expected redux module to be object with name, reducers and saga properties at most.');
	      }
	      if (module.reducers && typeof module.reducers !== 'object') {
	        fail("Expected reducers property of ".concat(module.name, " reduxModule to be object."));
	      }
	      if (module.saga) {
	        sagas.push(module.saga);
	      }
	      return _objectSpread2(_objectSpread2({}, result), module.reducers);
	    }, {});
	    pageTypes.push(_objectSpread2({
	      name: name,
	      component: component,
	      reducer: Object.keys(reducers).length ? combineReducers(reducers) : undefined,
	      saga: /*#__PURE__*/_regeneratorRuntime$g().mark(function saga() {
	        return _regeneratorRuntime$g().wrap(function saga$(_context) {
	          while (1) switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return sagas.map(function (saga) {
	                return saga();
	              });
	            case 2:
	            case "end":
	              return _context.stop();
	          }
	        }, saga);
	      })
	    }, options));
	    function fail(message) {
	      throw new Error("".concat(message, " Check registerPageType call of ").concat(name, " page type."));
	    }
	  };
	  this.forEach = function () {
	    return pageTypes.forEach.apply(pageTypes, arguments);
	  };
	  this.reduce = function () {
	    return pageTypes.reduce.apply(pageTypes, arguments);
	  };
	  this.findByName = function (pageTypeName) {
	    return pageTypes.find(function (_ref2) {
	      var name = _ref2.name,
	        component = _ref2.component;
	      return name == pageTypeName;
	    });
	  };
	}

	var registry = new PageTypeRegistry();
	var registerPageType = registry.register;

	function registerPageTypeWithDefaultBackground (name, customPageType) {
	  registerPageType(name, {
	    component: PageBackgroundAsset$1,
	    selectTargetElement: function selectTargetElement(pageElement) {
	      return pageElement.find('.page_background_asset')[0];
	    },
	    mixin: _objectSpread2({
	      scroller: true
	    }, customPageType),
	    reduxModules: [pageBackgroundReduxModule]
	  });
	}

	function WidgetTypeRegistry() {
	  var widgetTypes = [];
	  this.register = function (name, _ref) {
	    var component = _ref.component;
	    widgetTypes.push({
	      name: name,
	      component: component
	    });
	  };
	  this.findByName = function (widgetTypeName) {
	    var result = widgetTypes.find(function (_ref2) {
	      var name = _ref2.name;
	      return name == widgetTypeName;
	    });
	    if (!result) {
	      throw "Widget type with name \"".concat(widgetTypeName, "\" not found.");
	    }
	    return result;
	  };
	  this.forEach = function () {
	    widgetTypes.forEach.apply(widgetTypes, arguments);
	  };
	}

	var registry$1 = new WidgetTypeRegistry();
	var registerWidgetType = registry$1.register;

	function _regeneratorRuntime$h() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$h = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	function createStore$1 (reduxModules, options) {
	  var sagaMiddleware = createSagaMiddleware();
	  var sagas = [];
	  var middlewares = [];
	  if (!options.isServerSide) {
	    var _createSagasAndMiddle = createSagasAndMiddlewares(reduxModules, options);
	    sagas = _createSagasAndMiddle.sagas;
	    middlewares = _createSagasAndMiddle.middlewares;
	  }
	  var store = createStore(createReducer$1(reduxModules, options), {}, devToolsInDevelopment(applyMiddleware.apply(void 0, [sagaMiddleware].concat(_toConsumableArray(middlewares)))));
	  sagaMiddleware.run( /*#__PURE__*/_regeneratorRuntime$h().mark(function _callee() {
	    return _regeneratorRuntime$h().wrap(function _callee$(_context) {
	      while (1) switch (_context.prev = _context.next) {
	        case 0:
	          _context.next = 2;
	          return sagas;
	        case 2:
	        case "end":
	          return _context.stop();
	      }
	    }, _callee);
	  }));
	  init(reduxModules, _objectSpread2(_objectSpread2({}, options), {}, {
	    dispatch: store.dispatch,
	    getState: store.getState
	  }));
	  return store;
	}
	function createReducer$1(reduxModules, options) {
	  var reducers = reduxModules.reduce(function (result, reduxModule) {
	    return reduxModule.createReducers ? _objectSpread2(_objectSpread2({}, result), reduxModule.createReducers(options)) : result;
	  }, {});
	  return Object.keys(reducers).length ? combineReducers(reducers) : function (state, action) {
	    return state;
	  };
	}
	function createSagasAndMiddlewares(reduxModules, options) {
	  var sagas = [];
	  var middlewares = [];
	  reduxModules.forEach(function (reduxModule) {
	    var middleware;
	    if (reduxModule.createMiddleware) {
	      middleware = reduxModule.createMiddleware(options);
	      middlewares.push(middleware);
	    }
	    if (reduxModule.createSaga) {
	      sagas.push(call(reduxModule.createSaga(_objectSpread2(_objectSpread2({}, options), {}, {
	        middleware: middleware
	      }))));
	    }
	  });
	  return {
	    sagas: sagas,
	    middlewares: middlewares
	  };
	}
	function init(reduxModules, options) {
	  reduxModules.forEach(function (reduxModule) {
	    if (reduxModule.init) {
	      reduxModule.init(options);
	    }
	  });
	}
	function devToolsInDevelopment(enhancer) {
	  if ((typeof process === 'undefined' || "production" !== 'production') && typeof __REDUX_DEVTOOLS_EXTENSION_COMPOSE__ !== 'undefined') {
	    return window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(enhancer);
	  } else {
	    return enhancer;
	  }
	}

	var initialState = {
	  muted: false
	};
	function backgroundMedia () {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case MUTE:
	      return {
	        muted: true
	      };
	    case UNMUTE:
	      return {
	        muted: false
	      };
	    default:
	      return state;
	  }
	}

	function UnmuteButton(props) {
	  var t = props.t,
	    muted = props.muted,
	    unmute = props.unmute;
	  if (muted) {
	    return /*#__PURE__*/React$1__default.createElement("div", {
	      className: "background_media_unmute_button"
	    }, /*#__PURE__*/React$1__default.createElement("a", {
	      title: t('pageflow.public.mute_off'),
	      onClick: function onClick() {
	        playUnmuteSound();
	        unmute();
	      },
	      href: "#"
	    }));
	  } else {
	    return null;
	  }
	}
	function playUnmuteSound() {
	  new pageflow.AudioPlayer([{
	    src: pageflow.assetUrls.unmuteSound,
	    type: 'audio/mpeg'
	  }], {
	    codecs: ['mp3']
	  }).play();
	}
	function register() {
	  registerWidgetType('unmute_button', {
	    component: connect(combine$1({
	      t: t$1,
	      muted: muted
	    }), {
	      unmute: unmute
	    })(UnmuteButton)
	  });
	}

	function _regeneratorRuntime$i() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$i = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	var backgroundMedia$1 = {
	  init: function init(_ref) {
	    var isServerSide = _ref.isServerSide,
	      events = _ref.events,
	      dispatch = _ref.dispatch;
	    if (!isServerSide) {
	      events.on('background_media:mute', function (page) {
	        return dispatch(mute());
	      });
	      events.on('background_media:unmute', function (page) {
	        return dispatch(unmute());
	      });
	    }
	  },
	  createReducers: function createReducers() {
	    return {
	      backgroundMedia: backgroundMedia
	    };
	  },
	  createSaga: function createSaga(_ref2) {
	    var backgroundMedia = _ref2.backgroundMedia;
	    return /*#__PURE__*/_regeneratorRuntime$i().mark(function _callee2() {
	      return _regeneratorRuntime$i().wrap(function _callee2$(_context2) {
	        while (1) switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return lib_7(UNMUTE, /*#__PURE__*/_regeneratorRuntime$i().mark(function _callee() {
	              return _regeneratorRuntime$i().wrap(function _callee$(_context) {
	                while (1) switch (_context.prev = _context.next) {
	                  case 0:
	                    _context.next = 2;
	                    return call(function () {
	                      return backgroundMedia.unmute();
	                    });
	                  case 2:
	                  case "end":
	                    return _context.stop();
	                }
	              }, _callee);
	            }));
	          case 2:
	          case "end":
	            return _context2.stop();
	        }
	      }, _callee2);
	    });
	  }
	};
	function registerWidgetTypes() {
	  register();
	}

	function isCookieNoticeVisible(state) {
	  return state.cookieNotice.visible;
	}

	function privacyLinkUrl(state) {
	  return state.site.privacy_link_url;
	}

	var REQUEST = 'COOKIE_NOTICE_REQUEST';
	var DISMISS = 'COOKIE_NOTICE_DISMISS';
	function request() {
	  return {
	    type: REQUEST
	  };
	}
	function dismiss() {
	  return {
	    type: DISMISS
	  };
	}

	function CookieNoticeBar(props) {
	  var isCookieNoticeVisible = props.isCookieNoticeVisible,
	    editing = props.editing,
	    t = props.t,
	    dismiss = props.dismiss;
	  if (isCookieNoticeVisible || editing) {
	    return /*#__PURE__*/React$1__default.createElement("div", {
	      className: "cookie_notice_bar"
	    }, /*#__PURE__*/React$1__default.createElement("div", {
	      className: "cookie_notice_bar-content"
	    }, renderText(props), /*#__PURE__*/React$1__default.createElement("a", {
	      className: "cookie_notice_bar-dismiss",
	      onClick: dismiss
	    }, t('pageflow.public.dismiss_cookie_notice'))));
	  } else {
	    return /*#__PURE__*/React$1__default.createElement("noscript", null);
	  }
	}
	function renderText(_ref) {
	  var privacyLinkUrl = _ref.privacyLinkUrl,
	    t = _ref.t,
	    locale = _ref.locale;
	  var text = t('pageflow.public.cookie_notice_html', {
	    privacyLinkUrl: "".concat(privacyLinkUrl, "?lang=").concat(locale)
	  });
	  return /*#__PURE__*/React$1__default.createElement("span", {
	    className: "cookie_notice_bar-text",
	    dangerouslySetInnerHTML: {
	      __html: text
	    }
	  });
	}
	function register$1() {
	  registerWidgetType('cookie_notice_bar', {
	    component: connect(combine$1({
	      isCookieNoticeVisible: isCookieNoticeVisible,
	      privacyLinkUrl: privacyLinkUrl,
	      editing: editingWidget({
	        role: 'cookie_notice'
	      }),
	      t: t$1,
	      locale: locale
	    }), {
	      dismiss: dismiss
	    })(CookieNoticeBar)
	  });
	}

	function createReducer$2 (_ref) {
	  var hasBeenDismissed = _ref.hasBeenDismissed;
	  var initialState = {
	    dismissed: hasBeenDismissed,
	    visible: false
	  };
	  return function () {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	    var action = arguments.length > 1 ? arguments[1] : undefined;
	    switch (action.type) {
	      case REQUEST:
	        if (!state.dismissed) {
	          return _objectSpread2(_objectSpread2({}, state), {}, {
	            visible: true
	          });
	        }
	        return state;
	      case DISMISS:
	        return {
	          dismissed: true,
	          visible: false
	        };
	      default:
	        return state;
	    }
	  };
	}

	function _regeneratorRuntime$j() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$j = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	var COOKIE_KEY = 'cookie_notice_dismissed';
	var cookieNotice = {
	  init: function init(_ref) {
	    var isServerSide = _ref.isServerSide,
	      events = _ref.events,
	      dispatch = _ref.dispatch;
	    if (!isServerSide) {
	      events.on('cookie_notice:request', function () {
	        return dispatch(request());
	      });
	    }
	  },
	  createReducers: function createReducers(_ref2) {
	    var cookies = _ref2.cookies;
	    return {
	      cookieNotice: createReducer$2({
	        hasBeenDismissed: cookies && cookies.hasItem(COOKIE_KEY)
	      })
	    };
	  },
	  createSaga: function createSaga(_ref3) {
	    var widgetsApi = _ref3.widgetsApi,
	      cookies = _ref3.cookies;
	    return /*#__PURE__*/_regeneratorRuntime$j().mark(function _callee3() {
	      return _regeneratorRuntime$j().wrap(function _callee3$(_context3) {
	        while (1) switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.next = 2;
	            return lib_7(REQUEST, /*#__PURE__*/_regeneratorRuntime$j().mark(function _callee() {
	              var resetWidgetMargin;
	              return _regeneratorRuntime$j().wrap(function _callee$(_context) {
	                while (1) switch (_context.prev = _context.next) {
	                  case 0:
	                    _context.next = 2;
	                    return select(isCookieNoticeVisible);
	                  case 2:
	                    if (!_context.sent) {
	                      _context.next = 10;
	                      break;
	                    }
	                    _context.next = 5;
	                    return cps(ensureWidgetMarginBottom, widgetsApi);
	                  case 5:
	                    resetWidgetMargin = _context.sent;
	                    _context.next = 8;
	                    return take(DISMISS);
	                  case 8:
	                    _context.next = 10;
	                    return call(resetWidgetMargin);
	                  case 10:
	                  case "end":
	                    return _context.stop();
	                }
	              }, _callee);
	            }));
	          case 2:
	            _context3.next = 4;
	            return lib_7(DISMISS, /*#__PURE__*/_regeneratorRuntime$j().mark(function _callee2() {
	              return _regeneratorRuntime$j().wrap(function _callee2$(_context2) {
	                while (1) switch (_context2.prev = _context2.next) {
	                  case 0:
	                    _context2.next = 2;
	                    return call(function () {
	                      cookies.setItem(COOKIE_KEY, true);
	                    });
	                  case 2:
	                  case "end":
	                    return _context2.stop();
	                }
	              }, _callee2);
	            }));
	          case 4:
	          case "end":
	            return _context3.stop();
	        }
	      }, _callee3);
	    });
	  }
	};
	function ensureWidgetMarginBottom(widgetsApi, callback) {
	  widgetsApi.use({
	    name: 'cookie_notice_bar_visible',
	    insteadOf: 'cookie_notice_bar'
	  }, function (reset) {
	    return callback(null, reset);
	  });
	}
	function registerWidgetTypes$1() {
	  register$1();
	}

	var featuresModule = {
	  createReducers: function createReducers(_ref) {
	    var enabledFeatureNames = _ref.enabledFeatureNames;
	    return {
	      features: function features() {
	        return enabledFeatureNames;
	      }
	    };
	  }
	};

	var INIT = 'SITE_INIT';
	function init$1(site) {
	  return {
	    type: INIT,
	    payload: {
	      site: site
	    }
	  };
	}

	function reducer () {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case INIT:
	      return action.payload.site;
	    default:
	      return state;
	  }
	}

	var siteModule = {
	  init: function init(_ref) {
	    var site = _ref.site,
	      dispatch = _ref.dispatch;
	    dispatch(init$1(site));
	  },
	  createReducers: function createReducers() {
	    return {
	      site: reducer
	    };
	  }
	};

	var storylinesModule = {
	  init: function init(_ref) {
	    var storylines = _ref.storylines,
	      dispatch = _ref.dispatch;
	    watch({
	      collection: storylines,
	      collectionName: 'storylines',
	      dispatch: dispatch,
	      attributes: ['id'],
	      includeConfiguration: true
	    });
	  },
	  createReducers: function createReducers() {
	    return {
	      storylines: createCollectionReducer('storylines')
	    };
	  }
	};

	var chaptersModule = {
	  init: function init(_ref) {
	    var chapters = _ref.chapters,
	      dispatch = _ref.dispatch;
	    watch({
	      collection: chapters,
	      collectionName: 'chapters',
	      dispatch: dispatch,
	      attributes: ['id', 'title', 'position', 'storyline_id']
	    });
	  },
	  createReducers: function createReducers() {
	    return {
	      chapters: createCollectionReducer('chapters')
	    };
	  }
	};

	var INIT$1 = 'PAGE_TYPES_INIT';
	function init$2(_ref) {
	  var pageTypes = _ref.pageTypes;
	  return {
	    type: INIT$1,
	    payload: {
	      pageTypes: pageTypes
	    }
	  };
	}

	function reducer$1 () {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case INIT$1:
	      return action.payload.pageTypes;
	    default:
	      return state;
	  }
	}

	var pageTypesModule = {
	  createReducers: function createReducers() {
	    return {
	      pageTypes: reducer$1
	    };
	  },
	  init: function init(_ref) {
	    var pageTypesSeed = _ref.pageTypesSeed,
	      dispatch = _ref.dispatch;
	    dispatch(init$2({
	      pageTypes: camelize.deep(pageTypesSeed)
	    }));
	  }
	};

	var PAGE_CHANGE = 'CURRENT_PAGE_CHANGE';
	function pageChange(_ref) {
	  var id = _ref.id;
	  return {
	    type: PAGE_CHANGE,
	    payload: {
	      id: id
	    }
	  };
	}

	function currentPageId () {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case PAGE_CHANGE:
	      return action.payload.id;
	    default:
	      return state;
	  }
	}

	function watch$1 (events, dispatch) {
	  events.on('page:change', function (page) {
	    return dispatch(pageChange({
	      id: page.getPermaId()
	    }));
	  });
	}

	var currentModule = {
	  init: function init(_ref) {
	    var isServerSide = _ref.isServerSide,
	      events = _ref.events,
	      dispatch = _ref.dispatch;
	    if (!isServerSide) {
	      watch$1(events, dispatch);
	    }
	  },
	  createReducers: function createReducers() {
	    return {
	      currentPageId: currentPageId
	    };
	  }
	};

	var filesModule = {
	  init: function init(_ref) {
	    var files = _ref.files,
	      dispatch = _ref.dispatch;
	    Object.keys(files).forEach(function (collectionName) {
	      watch({
	        collection: files[collectionName],
	        collectionName: camelize(collectionName),
	        dispatch: dispatch,
	        idAttribute: 'perma_id',
	        attributes: ['id', 'perma_id', 'basename', 'processed_extension', 'variants', 'is_ready', 'parent_file_id', 'parent_file_model_type', 'width', 'height', 'duration_in_ms', 'rights', 'created_at'],
	        includeConfiguration: true
	      });
	    });
	  },
	  createReducers: function createReducers(_ref2) {
	    var files = _ref2.files,
	      _ref2$fileUrlTemplate = _ref2.fileUrlTemplates,
	      _fileUrlTemplates = _ref2$fileUrlTemplate === void 0 ? {} : _ref2$fileUrlTemplate,
	      _ref2$modelTypes = _ref2.modelTypes,
	      _modelTypes = _ref2$modelTypes === void 0 ? {} : _ref2$modelTypes;
	    _fileUrlTemplates = camelize.keys(_fileUrlTemplates);
	    _modelTypes = camelize.keys(_modelTypes);
	    return {
	      files: combineReducers(Object.keys(files).reduce(function (result, collectionName) {
	        collectionName = camelize(collectionName);
	        result[collectionName] = createCollectionReducer(collectionName, {
	          idAttribute: 'permaId'
	        });
	        return result;
	      }, {})),
	      fileUrlTemplates: function fileUrlTemplates(state) {
	        return _fileUrlTemplates;
	      },
	      modelTypes: function modelTypes(state) {
	        return _modelTypes;
	      }
	    };
	  }
	};

	function reducer$2 () {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case LOAD:
	      return action.payload.settings;
	    default:
	      return state;
	  }
	}

	function _regeneratorRuntime$k() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$k = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	var settingsModule = {
	  init: function init(_ref) {
	    var isServerSide = _ref.isServerSide,
	      settings = _ref.settings,
	      dispatch = _ref.dispatch;
	    if (!isServerSide) {
	      dispatch(load({
	        settings: settings.toJSON()
	      }));
	      settings.on('change', function () {
	        return dispatch(load({
	          settings: settings.toJSON()
	        }));
	      });
	    }
	  },
	  createReducers: function createReducers() {
	    return {
	      settings: reducer$2
	    };
	  },
	  createSaga: function createSaga(_ref2) {
	    var settings = _ref2.settings;
	    return /*#__PURE__*/_regeneratorRuntime$k().mark(function _callee2() {
	      return _regeneratorRuntime$k().wrap(function _callee2$(_context2) {
	        while (1) switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return lib_7(UPDATE, /*#__PURE__*/_regeneratorRuntime$k().mark(function _callee(action) {
	              return _regeneratorRuntime$k().wrap(function _callee$(_context) {
	                while (1) switch (_context.prev = _context.next) {
	                  case 0:
	                    _context.next = 2;
	                    return call([settings, settings.set], action.payload.property, action.payload.value);
	                  case 2:
	                  case "end":
	                    return _context.stop();
	                }
	              }, _callee);
	            }));
	          case 2:
	          case "end":
	            return _context2.stop();
	        }
	      }, _callee2);
	    });
	  }
	};

	var INIT$2 = 'I18N_INIT';
	function init$3(_ref) {
	  var locale = _ref.locale;
	  return {
	    type: INIT$2,
	    payload: {
	      locale: locale
	    }
	  };
	}

	function reducer$3 () {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case INIT$2:
	      return {
	        locale: action.payload.locale
	      };
	    default:
	      return state;
	  }
	}

	var i18nModule = {
	  createReducers: function createReducers() {
	    return {
	      i18n: reducer$3
	    };
	  },
	  init: function init(_ref) {
	    var locale = _ref.locale,
	      dispatch = _ref.dispatch;
	    dispatch(init$3({
	      locale: locale
	    }));
	  }
	};

	var UPDATE$1 = 'ENTRY_UPDATE';
	var READY = 'ENTRY_READY';
	function update$1(_ref) {
	  var entry = _ref.entry;
	  return {
	    type: UPDATE$1,
	    payload: {
	      entry: entry
	    }
	  };
	}
	function ready() {
	  return {
	    type: READY
	  };
	}

	function reducer$4 () {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case UPDATE$1:
	      return _objectSpread2(_objectSpread2({}, state), action.payload.entry);
	    case READY:
	      return _objectSpread2(_objectSpread2({}, state), {}, {
	        isReady: true
	      });
	    default:
	      return state;
	  }
	}

	var entryModule = {
	  init: function init(_ref) {
	    var entry = _ref.entry,
	      dispatch = _ref.dispatch,
	      events = _ref.events,
	      isServerSide = _ref.isServerSide;
	    if (!isServerSide) {
	      events.once('ready', function () {
	        return dispatch(ready());
	      });
	    }
	    if (Backbone.Model && entry instanceof Backbone.Model) {
	      watchModel({
	        entry: entry,
	        dispatch: dispatch
	      });
	    } else {
	      loadFromSeed$1({
	        entry: entry,
	        dispatch: dispatch
	      });
	    }
	  },
	  createReducers: function createReducers() {
	    return {
	      entry: reducer$4
	    };
	  }
	};
	function watchModel(_ref2) {
	  var entry = _ref2.entry,
	    dispatch = _ref2.dispatch;
	  updateFromModel({
	    entry: entry,
	    dispatch: dispatch
	  });
	  entry.metadata.on('change:title', function () {
	    updateFromModel({
	      entry: entry,
	      dispatch: dispatch
	    });
	  });
	}
	function updateFromModel(_ref3) {
	  var entry = _ref3.entry,
	    dispatch = _ref3.dispatch;
	  dispatch(update$1({
	    entry: {
	      slug: entry.get('slug'),
	      title: entry.metadata.get('title') || entry.get('entry_title'),
	      publishedAt: null
	    }
	  }));
	}
	function loadFromSeed$1(_ref4) {
	  var entry = _ref4.entry,
	    dispatch = _ref4.dispatch;
	  dispatch(update$1({
	    entry: {
	      slug: entry.slug,
	      title: entry.title,
	      publishedAt: entry.published_at
	    }
	  }));
	}

	var hotkeysModule = {
	  init: function init(_ref) {
	    var isServerSide = _ref.isServerSide,
	      window = _ref.window,
	      getState = _ref.getState,
	      dispatch = _ref.dispatch;
	    if (isServerSide) {
	      return;
	    }
	    window.addEventListener('keydown', function (event) {
	      var currentPageId = getState().currentPageId;
	      if (event.keyCode == SPACE) {
	        dispatch(space({
	          currentPageId: currentPageId
	        }));
	      } else if (event.keyCode == TAB) {
	        dispatch(tab({
	          currentPageId: currentPageId
	        }));
	      }
	    });
	  }
	};

	function watch$2 (hideText, dispatch) {
	  hideText.on('activate', function (page) {
	    return dispatch(activate());
	  });
	  hideText.on('deactivate', function (page) {
	    return dispatch(deactivate());
	  });
	}

	var initialState$1 = {
	  isActive: false,
	  hasBeenActive: false
	};
	function hideText () {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState$1;
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case ACTIVATE:
	      return {
	        isActive: true,
	        hasBeenActive: true
	      };
	    case DEACTIVATE:
	      return _objectSpread2(_objectSpread2({}, state), {}, {
	        isActive: false
	      });
	    case PAGE_CHANGE:
	      return _objectSpread2(_objectSpread2({}, state), {}, {
	        hasBeenActive: false
	      });
	    default:
	      return state;
	  }
	}

	var hideTextModule = {
	  init: function init(_ref) {
	    var isServerSide = _ref.isServerSide,
	      hideText = _ref.hideText,
	      dispatch = _ref.dispatch;
	    if (!isServerSide) {
	      watch$2(hideText, dispatch);
	    }
	  },
	  createReducers: function createReducers() {
	    return {
	      hideText: hideText
	    };
	  }
	};

	var widgetsModule = {
	  init: function init(_ref) {
	    var widgets = _ref.widgets,
	      dispatch = _ref.dispatch;
	    watch({
	      collection: widgets,
	      collectionName: 'widgets',
	      dispatch: dispatch,
	      attributes: ['role', 'type_name', 'editing'],
	      includeConfiguration: true
	    });
	  },
	  createReducers: function createReducers() {
	    return {
	      widgets: createCollectionReducer('widgets', {
	        idAttribute: 'role'
	      })
	    };
	  }
	};
	function createWidgetType(Component, store) {
	  return {
	    enhance: function enhance(element) {
	      ReactDOM.render( /*#__PURE__*/React.createElement(Provider, {
	        store: store
	      }, /*#__PURE__*/React.createElement(Component, null)), element[0]);
	    }
	  };
	}

	var LOAD$1 = 'WIDGETS_LOAD';
	function load$1(_ref) {
	  var widgets = _ref.widgets;
	  return {
	    type: LOAD$1,
	    payload: {
	      widgets: widgets
	    }
	  };
	}

	function reducer$5 () {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case LOAD$1:
	      return action.payload.widgets;
	    default:
	      return state;
	  }
	}

	var widgetPresenceModule = {
	  init: function init(_ref) {
	    var isServerSide = _ref.isServerSide,
	      events = _ref.events,
	      widgetsApi = _ref.widgetsApi,
	      dispatch = _ref.dispatch;
	    function update() {
	      dispatch(load$1({
	        widgets: {
	          classicPlayerControls: widgetsApi.isPresent('classic_player_controls'),
	          slimPlayerControls: widgetsApi.isPresent('slim_player_controls')
	        }
	      }));
	    }
	    if (!isServerSide) {
	      events.on('widgets:update', update);
	      update();
	    }
	  },
	  createReducers: function createReducers() {
	    return {
	      widgetPresence: reducer$5
	    };
	  }
	};

	var INIT$3 = 'THEME_INIT';
	function init$4(payload) {
	  return {
	    type: INIT$3,
	    payload: payload
	  };
	}

	function reducer$6 () {
	  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var action = arguments.length > 1 ? arguments[1] : undefined;
	  switch (action.type) {
	    case INIT$3:
	      return action.payload;
	    default:
	      return state;
	  }
	}

	var themeModule = {
	  createReducers: function createReducers() {
	    return {
	      theme: reducer$6
	    };
	  },
	  init: function init(_ref) {
	    var dispatch = _ref.dispatch,
	      isServerSide = _ref.isServerSide;
	    if (!isServerSide) {
	      var probe = document.getElementById('theme_probe-main_color');
	      dispatch(init$4({
	        mainColor: window.getComputedStyle(probe)['background-color']
	      }));
	    }
	  }
	};

	function isConsentUIVisible(state) {
	  return state.consent.uiVisible;
	}
	function requestedVendors(state) {
	  return state.consent.requestedVendors;
	}

	function ToggleOnIcon (props) {
	  return /*#__PURE__*/React.createElement(Container$1, Object.assign({}, props, {
	    viewBoxLeft: 60,
	    viewBoxTop: 170,
	    viewBoxWidth: 90,
	    viewBoxHeight: 157
	  }), /*#__PURE__*/React.createElement("path", {
	    fill: "currentColor",
	    d: "m 150.00015,296.99993 a 50,50 0 0 0 50.00004,-50.00005 50,50 0 0 0 -50.00004,-50.00004 H 50.000048 A 50,50 0 0 0 0,246.99988 50,50 0 0 0 50.000048,296.99993 Z"
	  }), /*#__PURE__*/React.createElement("circle", {
	    cx: "-150.0002",
	    cy: "-246.99979",
	    fill: "#fff",
	    r: "40",
	    transform: "scale(-1)"
	  }), /*#__PURE__*/React.createElement("path", {
	    fillOpacity: "0",
	    stroke: "#fff",
	    strokeWidth: "6",
	    d: "M 87,227 50,264 34,246"
	  }));
	}

	function ToggleOffIcon (props) {
	  return /*#__PURE__*/React.createElement(Container$1, Object.assign({}, props, {
	    viewBoxLeft: 60,
	    viewBoxTop: 170,
	    viewBoxWidth: 90,
	    viewBoxHeight: 157
	  }), /*#__PURE__*/React.createElement("path", {
	    fill: "currentColor",
	    d: "M 188.97656 744.56641 A 188.97638 188.97638 0 0 0 0 933.54297 A 188.97638 188.97638 0 0 0 188.97656 1122.5195 L 566.92969 1122.5195 A 188.97638 188.97638 0 0 0 755.90625 933.54297 A 188.97638 188.97638 0 0 0 566.92969 744.56641 L 188.97656 744.56641 z ",
	    transform: "scale(0.26458333)"
	  }), /*#__PURE__*/React.createElement("circle", {
	    id: "path3721-7",
	    cx: "50",
	    cy: "247",
	    fill: "#ffffff",
	    r: "40"
	  }), /*#__PURE__*/React.createElement("path", {
	    fillOpacity: "0",
	    stroke: "#fff",
	    strokeWidth: "6",
	    d: "m 110.10252,271.89748 49.79539,-49.79494"
	  }), /*#__PURE__*/React.createElement("path", {
	    fillOpacity: "0",
	    stroke: "#fff",
	    strokeWidth: "6",
	    d: "M 159.89746,271.89748 110.10252,222.10209"
	  }));
	}

	function _callSuper$j(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var Toggle = /*#__PURE__*/function (_React$Component) {
	  _inherits(Toggle, _React$Component);
	  function Toggle(props) {
	    var _this;
	    _classCallCheck(this, Toggle);
	    _this = _callSuper$j(this, Toggle, [props]);
	    _this.state = {
	      checked: props.defaultChecked
	    };
	    _this.handleClick = _this.onClick.bind(_assertThisInitialized(_this));
	    return _this;
	  }
	  _createClass(Toggle, [{
	    key: "onClick",
	    value: function onClick() {
	      var checked = !this.state.checked;
	      this.setState({
	        checked: checked
	      });
	      this.props.onChange({
	        target: {
	          checked: checked
	        }
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var checked = this.state.checked;
	      var Icon = checked ? ToggleOnIcon : ToggleOffIcon;
	      return /*#__PURE__*/React$1__default.createElement("button", {
	        id: this.props.id,
	        className: this.props.className,
	        role: "switch",
	        "aria-checked": checked,
	        onClick: this.handleClick
	      }, /*#__PURE__*/React$1__default.createElement(Icon, {
	        width: 50,
	        height: 35
	      }));
	    }
	  }]);
	  return Toggle;
	}(React$1__default.Component);

	function _callSuper$k(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var VendorList = /*#__PURE__*/function (_React$Component) {
	  _inherits(VendorList, _React$Component);
	  function VendorList(props) {
	    var _this;
	    _classCallCheck(this, VendorList);
	    _this = _callSuper$k(this, VendorList, [props]);
	    _this.state = {};
	    _this.handleVendorInfoClick = _this.onVendorInfoClick.bind(_assertThisInitialized(_this));
	    return _this;
	  }
	  _createClass(VendorList, [{
	    key: "onVendorInfoClick",
	    value: function onVendorInfoClick(vendorName) {
	      this.setState(_defineProperty({}, vendorName, !this.state[vendorName]));
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      return /*#__PURE__*/React$1__default.createElement("div", {
	        className: "consent_vendor_list"
	      }, this.renderVendors());
	    }
	  }, {
	    key: "renderVendors",
	    value: function renderVendors() {
	      var _this2 = this;
	      if (!this.props.vendors.length) {
	        return /*#__PURE__*/React$1__default.createElement("div", {
	          className: "consent_vendor_list-blank"
	        }, this.props.t('pageflow.public.consent_no_vendors'));
	      }
	      return this.props.vendors.map(function (vendor) {
	        var id = "consent_vendor_list-vendor_".concat(vendor.name);
	        return /*#__PURE__*/React$1__default.createElement("div", {
	          key: id,
	          className: "consent_vendor_list-vendor"
	        }, /*#__PURE__*/React$1__default.createElement("label", {
	          htmlFor: id
	        }, vendor.displayName), /*#__PURE__*/React$1__default.createElement(Toggle, {
	          id: id,
	          className: "consent_vendor_list-toggle",
	          defaultChecked: vendor.state === 'accepted',
	          onChange: function onChange(event) {
	            return _this2.props.onVendorInputChange(vendor.name, event);
	          }
	        }), /*#__PURE__*/React$1__default.createElement("button", {
	          className: "consent_vendor_list-expand_vendor",
	          title: _this2.props.t('pageflow.public.consent_expand_vendor'),
	          onClick: function onClick() {
	            return _this2.handleVendorInfoClick(vendor.name);
	          }
	        }, /*#__PURE__*/React$1__default.createElement(InfoIcon, {
	          width: 20,
	          height: 20
	        })), _this2.renderVendorDescription(vendor));
	      });
	    }
	  }, {
	    key: "renderVendorDescription",
	    value: function renderVendorDescription(vendor) {
	      if (this.state[vendor.name]) {
	        return /*#__PURE__*/React$1__default.createElement("p", {
	          dangerouslySetInnerHTML: {
	            __html: vendor.description
	          }
	        });
	      } else {
	        return null;
	      }
	    }
	  }]);
	  return VendorList;
	}(React$1__default.Component);

	var REQUEST$1 = 'CONSENT_REQUEST';
	var DENY_ALL = 'CONSENT_DENY_ALL';
	var ACCEPT_ALL = 'CONSENT_ACCEPT_ALL';
	var SAVE = 'CONSENT_SAVE';
	function request$1(_ref) {
	  var vendors = _ref.vendors;
	  return {
	    type: REQUEST$1,
	    payload: {
	      vendors: vendors
	    }
	  };
	}
	function denyAll() {
	  return {
	    type: DENY_ALL
	  };
	}
	function acceptAll() {
	  return {
	    type: ACCEPT_ALL
	  };
	}
	function save(vendors) {
	  return {
	    type: SAVE,
	    payload: vendors
	  };
	}

	function _callSuper$l(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var ConsentBar = /*#__PURE__*/function (_React$Component) {
	  _inherits(ConsentBar, _React$Component);
	  function ConsentBar(props) {
	    var _this;
	    _classCallCheck(this, ConsentBar);
	    _this = _callSuper$l(this, ConsentBar, [props]);
	    _this.state = {
	      checked: {}
	    };
	    _this.handleSaveButtonClick = _this.onSaveButtonClick.bind(_assertThisInitialized(_this));
	    _this.handleAcceptAllButtonClick = _this.onAcceptAllButtonClick.bind(_assertThisInitialized(_this));
	    _this.handleDenyAllAllButtonClick = _this.onDenyAllButtonClick.bind(_assertThisInitialized(_this));
	    _this.handleVendorInputChange = _this.onVendorInputChange.bind(_assertThisInitialized(_this));
	    return _this;
	  }
	  _createClass(ConsentBar, [{
	    key: "onSaveButtonClick",
	    value: function onSaveButtonClick() {
	      var _this2 = this;
	      if (this.props.editing) {
	        return;
	      }
	      var signal = this.props.requestedVendors.reduce(function (result, _ref) {
	        var name = _ref.name;
	        return _objectSpread2(_objectSpread2({}, result), {}, _defineProperty({}, name, _this2.state.checked[name] || false));
	      }, {});
	      this.props.save(signal);
	    }
	  }, {
	    key: "onAcceptAllButtonClick",
	    value: function onAcceptAllButtonClick() {
	      if (!this.props.editing) {
	        this.props.acceptAll();
	      }
	    }
	  }, {
	    key: "onDenyAllButtonClick",
	    value: function onDenyAllButtonClick() {
	      if (!this.props.editing) {
	        this.props.denyAll();
	      }
	    }
	  }, {
	    key: "onVendorInputChange",
	    value: function onVendorInputChange(vendorName, event) {
	      this.setState({
	        checked: _objectSpread2(_objectSpread2({}, this.state.checked), {}, _defineProperty({}, vendorName, event.target.checked))
	      });
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this3 = this;
	      var _this$props = this.props,
	        editing = _this$props.editing,
	        t = _this$props.t,
	        requestedVendors = _this$props.requestedVendors,
	        visible = _this$props.visible;
	      if (visible || editing) {
	        return /*#__PURE__*/React$1__default.createElement("div", {
	          className: classnames('consent_bar', {
	            'consent_bar-expanded': this.state.showVendorBox
	          })
	        }, /*#__PURE__*/React$1__default.createElement("div", {
	          className: "consent_bar-content"
	        }, renderText$1(this.props), /*#__PURE__*/React$1__default.createElement("div", {
	          className: "consent_bar-vendor_box"
	        }, /*#__PURE__*/React$1__default.createElement("h3", null, t('pageflow.public.consent_settings')), /*#__PURE__*/React$1__default.createElement(VendorList, {
	          vendors: requestedVendors,
	          t: t,
	          onVendorInputChange: this.handleVendorInputChange
	        }), /*#__PURE__*/React$1__default.createElement("button", {
	          className: "consent_bar-save",
	          onClick: this.handleSaveButtonClick
	        }, t('pageflow.public.consent_save'))), /*#__PURE__*/React$1__default.createElement("div", {
	          className: "consent_bar-buttons"
	        }, /*#__PURE__*/React$1__default.createElement("button", {
	          className: "consent_bar-configure",
	          onClick: function onClick() {
	            return _this3.setState({
	              showVendorBox: !_this3.state.showVendorBox
	            });
	          }
	        }, /*#__PURE__*/React$1__default.createElement(GearIcon, {
	          width: 10,
	          height: 10
	        }), t('pageflow.public.consent_configure')), /*#__PURE__*/React$1__default.createElement("div", {
	          className: "consent_bar-decision_buttons"
	        }, /*#__PURE__*/React$1__default.createElement("button", {
	          className: "consent_bar-deny_all",
	          onClick: this.handleDenyAllAllButtonClick
	        }, t('pageflow.public.consent_deny_all')), /*#__PURE__*/React$1__default.createElement("button", {
	          className: "consent_bar-accept_all",
	          onClick: this.handleAcceptAllButtonClick
	        }, t('pageflow.public.consent_accept_all'))))));
	      } else {
	        return /*#__PURE__*/React$1__default.createElement("noscript", null);
	      }
	    }
	  }]);
	  return ConsentBar;
	}(React$1__default.Component);
	function renderText$1(_ref2) {
	  var privacyLinkUrl = _ref2.privacyLinkUrl,
	    t = _ref2.t,
	    locale = _ref2.locale,
	    requestedVendors = _ref2.requestedVendors;
	  var vendorNames = requestedVendors.map(function (vendor) {
	    return vendor.name;
	  }).join(',');
	  var text = t('pageflow.public.consent_prompt_html', {
	    privacyLinkUrl: "".concat(privacyLinkUrl, "?lang=").concat(locale, "&vendors=").concat(vendorNames, "#consent")
	  });
	  return /*#__PURE__*/React$1__default.createElement("span", {
	    className: "consent_bar-text",
	    dangerouslySetInnerHTML: {
	      __html: text
	    }
	  });
	}
	function register$2() {
	  registerWidgetType('consent_bar', {
	    component: connect(combine$1({
	      privacyLinkUrl: privacyLinkUrl,
	      editing: editingWidget({
	        role: 'cookie_notice'
	      }),
	      t: t$1,
	      locale: locale,
	      requestedVendors: requestedVendors,
	      visible: isConsentUIVisible
	    }), {
	      acceptAll: acceptAll,
	      denyAll: denyAll,
	      save: save
	    })(ConsentBar)
	  });
	}

	function Settings(_ref) {
	  var consent = _ref.consent,
	    t = _ref.t,
	    queryString = _ref.queryString;
	  var vendors = consent.relevantVendors({
	    include: vendorsFromQueryString(queryString)
	  });
	  return /*#__PURE__*/React$1__default.createElement("div", null, /*#__PURE__*/React$1__default.createElement(VendorList, {
	    vendors: vendors,
	    t: t,
	    onVendorInputChange: handleInputChange
	  }));
	  function handleInputChange(vendorName, event) {
	    event.target.checked ? consent.accept(vendorName) : consent.deny(vendorName);
	  }
	}
	function vendorsFromQueryString(queryString) {
	  var match = queryString && queryString.match(/vendors=([^&]+)/);
	  if (match) {
	    return match[1].split(',');
	  }
	  return [];
	}

	function createReducer$3 () {
	  var initialState = {
	    uiVisible: false,
	    requestedVendors: []
	  };
	  return function () {
	    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
	    var action = arguments.length > 1 ? arguments[1] : undefined;
	    switch (action.type) {
	      case REQUEST$1:
	        return {
	          requestedVendors: action.payload.vendors,
	          uiVisible: true
	        };
	      case ACCEPT_ALL:
	        return {
	          uiVisible: false
	        };
	      case DENY_ALL:
	        return {
	          uiVisible: false
	        };
	      case SAVE:
	        return {
	          uiVisible: false
	        };
	      default:
	        return state;
	    }
	  };
	}

	function _regeneratorRuntime$l() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$l = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
	var consentModule = {
	  createReducers: function createReducers() {
	    return {
	      consent: createReducer$3()
	    };
	  },
	  createSaga: function createSaga(_ref) {
	    var widgetsApi = _ref.widgetsApi,
	      consent = _ref.consent;
	    return /*#__PURE__*/_regeneratorRuntime$l().mark(function _callee() {
	      var _yield$call, acceptAll, denyAll, save, vendors;
	      return _regeneratorRuntime$l().wrap(function _callee$(_context) {
	        while (1) switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return call(function () {
	              return consent.requested();
	            });
	          case 2:
	            _yield$call = _context.sent;
	            acceptAll = _yield$call.acceptAll;
	            denyAll = _yield$call.denyAll;
	            save = _yield$call.save;
	            vendors = _yield$call.vendors;
	            _context.next = 9;
	            return put(request$1({
	              vendors: vendors
	            }));
	          case 9:
	            _context.next = 11;
	            return lib_7(ACCEPT_ALL, function () {
	              acceptAll();
	            });
	          case 11:
	            _context.next = 13;
	            return lib_7(DENY_ALL, function () {
	              denyAll();
	            });
	          case 13:
	            _context.next = 15;
	            return lib_7(SAVE, function (action) {
	              save(action.payload);
	            });
	          case 15:
	          case "end":
	            return _context.stop();
	        }
	      }, _callee);
	    });
	  }
	};
	function registerWidgetTypes$2() {
	  register$2();
	}

	function boot (pageflow) {
	  var isEditor = !!pageflow.storylines;
	  var isServerSide = !pageflow.settings;
	  var seed = pageflow.seed;
	  var collections = isEditor ? pageflow : seed;
	  var options = {
	    isServerSide: isServerSide,
	    locale: seed.locale,
	    entry: collections.entry,
	    enabledFeatureNames: seed['enabled_feature_names'],
	    fileUrlTemplates: seed['file_url_templates'],
	    modelTypes: seed['file_model_types'],
	    pageTypesSeed: seed['page_types'],
	    pageTypes: registry,
	    site: seed.site,
	    files: collections.files || {},
	    storylines: collections.storylines,
	    chapters: collections.chapters,
	    pages: collections.pages,
	    widgets: isEditor ? pageflow.entry.widgets : seed.widgets,
	    cookies: pageflow.cookies,
	    hideText: pageflow.hideText,
	    events: pageflow.events,
	    settings: pageflow.settings,
	    widgetsApi: pageflow.widgets,
	    backgroundMedia: pageflow.backgroundMedia,
	    consent: pageflow.consent,
	    window: isServerSide ? null : window
	  };
	  var store = createStore$1([backgroundMedia$1, cookieNotice, featuresModule, i18nModule, siteModule, entryModule, currentModule, storylinesModule, chaptersModule, pagesModule, filesModule, settingsModule, hideTextModule, widgetsModule, widgetPresenceModule, pageTypesModule, hotkeysModule, themeModule, consentModule], options);
	  if (!isServerSide) {
	    registry.forEach(function (options) {
	      return pageflow.pageType.register(options.name, createPageType(_objectSpread2(_objectSpread2({}, options), {}, {
	        Component: options.component,
	        store: store
	      })));
	    });
	    registry$1.forEach(function (_ref) {
	      var name = _ref.name,
	        component = _ref.component;
	      return pageflow.widgetTypes.register(name, createWidgetType(component, store));
	    });
	  }
	  return store;
	}

	function _callSuper$m(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var PageProvider$1 = createItemScopeProvider('pages');
	var _default$2 = /*#__PURE__*/function (_React$Component) {
	  _inherits(_default, _React$Component);
	  function _default() {
	    _classCallCheck(this, _default);
	    return _callSuper$m(this, _default, arguments);
	  }
	  _createClass(_default, [{
	    key: "componentWillMount",
	    value: function componentWillMount() {
	      this.store = boot({
	        seed: this.props.resolverSeed
	      });
	      this.pageComponent = registry.findByName(this.props.pageType).component;
	    }
	  }, {
	    key: "render",
	    value: function render(props) {
	      var PageComponent = this.pageComponent;
	      return /*#__PURE__*/React$1__default.createElement(Provider, {
	        store: this.store
	      }, /*#__PURE__*/React$1__default.createElement(PageProvider$1, {
	        itemId: this.props.pageId
	      }, /*#__PURE__*/React$1__default.createElement(PageComponent, null)));
	    }
	  }]);
	  return _default;
	}(React$1__default.Component);

	function _callSuper$n(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var _default$3 = /*#__PURE__*/function (_React$Component) {
	  _inherits(_default, _React$Component);
	  function _default() {
	    _classCallCheck(this, _default);
	    return _callSuper$n(this, _default, arguments);
	  }
	  _createClass(_default, [{
	    key: "componentWillMount",
	    value: function componentWillMount() {
	      this.store = boot({
	        seed: this.props.resolverSeed
	      });
	      this.widgetComponent = registry$1.findByName(this.props.widgetTypeName).component;
	    }
	  }, {
	    key: "render",
	    value: function render(props) {
	      var WidgetComponent = this.widgetComponent;
	      return /*#__PURE__*/React$1__default.createElement(Provider, {
	        store: this.store
	      }, /*#__PURE__*/React$1__default.createElement(WidgetComponent, null));
	    }
	  }]);
	  return _default;
	}(React$1__default.Component);

	function _callSuper$o(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var PageProvider$2 = createItemScopeProvider('pages');
	var _default$4 = /*#__PURE__*/function (_React$Component) {
	  _inherits(_default, _React$Component);
	  function _default() {
	    _classCallCheck(this, _default);
	    return _callSuper$o(this, _default, arguments);
	  }
	  _createClass(_default, [{
	    key: "componentWillMount",
	    value: function componentWillMount() {
	      this.store = boot({
	        seed: this.props.resolverSeed
	      });
	    }
	  }, {
	    key: "render",
	    value: function render(props) {
	      return /*#__PURE__*/React$1__default.createElement(Provider, {
	        store: this.store
	      }, /*#__PURE__*/React$1__default.createElement(PageProvider$2, {
	        itemId: this.props.pageId
	      }, /*#__PURE__*/React$1__default.createElement(PageBackgroundAsset$1, null)));
	    }
	  }]);
	  return _default;
	}(React$1__default.Component);

	function AudioPage(props) {
	  var playerControlsVariant = props.page.audioPlayerControlsVariant;
	  return /*#__PURE__*/React.createElement(MediaPage$1, {
	    className: "audio_page supports_text_position_center",
	    page: props.page,
	    file: props.audioFile,
	    playerState: props.playerState,
	    playerActions: props.playerActions,
	    controlBarText: props.t('pageflow.public.start_audio'),
	    playerControlsComponent: playerControlsComponent(playerControlsVariant),
	    dynamicPageScrollerMargin: playerControlsVariant == 'waveform',
	    autoplayWhenBackgroundMediaMuted: false
	  }, /*#__PURE__*/React.createElement(PageBackgroundAsset$1, null), /*#__PURE__*/React.createElement(PlayerMediaContextProvider, {
	    playbackMode: props.page.autoplay === false ? 'manual' : 'autoplay',
	    playerDescription: "Audio Page Player"
	  }, /*#__PURE__*/React.createElement(PageAudioFilePlayer, {
	    file: props.audioFile,
	    playerState: props.playerState,
	    playerActions: props.playerActions,
	    textTrackPosition: textTrackPosition$1(playerControlsVariant)
	  })));
	}
	function playerControlsComponent(variant) {
	  if (variant == 'waveform') {
	    return WaveformPlayerControls$1;
	  } else {
	    return PlayerControls$1;
	  }
	}
	function textTrackPosition$1(variant) {
	  if (variant == 'waveform') {
	    return 'top';
	  }
	}
	function register$3() {
	  registerPageType('audio', {
	    component: connectInPage(combine$1({
	      page: pageAttributes(),
	      audioFile: file('audioFiles', {
	        id: pageAttribute('audioFileId')
	      }),
	      playerState: playerState(),
	      t: t$1
	    }), combine({
	      playerActions: playerActions()
	    }))(AudioPage),
	    reduxModules: [reduxModule({
	      retryOnUnmute: true
	    }), pageBackgroundReduxModule]
	  });
	}

	function PlainPage(props) {
	  var page = props.page;
	  return /*#__PURE__*/React.createElement(_default, {
	    className: "supports_text_position_center"
	  }, /*#__PURE__*/React.createElement(MediaPageBackground, {
	    page: page
	  }), /*#__PURE__*/React.createElement(PageForeground, null, /*#__PURE__*/React.createElement(PageScroller$1, null, /*#__PURE__*/React.createElement(_default$1, {
	    page: page
	  }), /*#__PURE__*/React.createElement(PagePrintImage$1, {
	    page: page
	  }), /*#__PURE__*/React.createElement(PageText, {
	    page: page
	  }))));
	}
	function register$4() {
	  registerPageType('background_image', {
	    component: connectInPage(combine$1({
	      page: pageAttributes()
	    }))(PlainPage),
	    reduxModules: [pageBackgroundReduxModule]
	  });
	}

	var qualities = ['auto', '4k', 'fullhd', 'medium'];
	function VideoPage(props) {
	  return /*#__PURE__*/React.createElement(MediaPage$1, {
	    className: "video_page supports_text_position_center",
	    page: props.page,
	    file: props.videoFile,
	    qualities: qualities,
	    playerState: props.playerState,
	    playerActions: props.playerActions,
	    controlBarText: props.t('pageflow.public.start_video'),
	    autoplayWhenBackgroundMediaMuted: true
	  }, /*#__PURE__*/React.createElement(PlayerMediaContextProvider, {
	    playbackMode: props.page.autoplay === false ? 'manual' : 'autoplay',
	    playerDescription: "Video Page Player"
	  }, /*#__PURE__*/React.createElement(PageVideoPlayer, {
	    page: props.page,
	    playerState: props.playerState,
	    playerActions: props.playerActions,
	    fit: props.page.contain ? 'contain' : 'smart_contain'
	  })), /*#__PURE__*/React.createElement(MobilePageVideoPoster$1, {
	    page: props.page
	  }));
	}
	function register$5() {
	  registerPageType('video', {
	    component: connectInPage(combine$1({
	      page: pageAttributes(),
	      videoFile: file('videoFiles', {
	        id: pageAttribute('videoFileId')
	      }),
	      playerState: playerState(),
	      t: t$1
	    }), combine({
	      playerActions: playerActions()
	    }))(VideoPage),
	    reduxModules: [reduxModule({
	      hideControls: true,
	      autoplayWhenBackgroundMediaMuted: true,
	      playsInNativePlayer: has$3('native video player')
	    })]
	  });
	}

	function register$6() {
	  register$4();
	  register$5();
	  register$3();
	}

	function _callSuper$p(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var inlineStyle = {
	  position: 'absolute',
	  top: 0,
	  left: 0,
	  width: '100%',
	  height: '100%',
	  backgroundColor: '#3b5159'
	};
	var ClassicLoadingSpinner = /*#__PURE__*/function (_React$Component) {
	  _inherits(ClassicLoadingSpinner, _React$Component);
	  function ClassicLoadingSpinner(props) {
	    var _this;
	    _classCallCheck(this, ClassicLoadingSpinner);
	    _this = _callSuper$p(this, ClassicLoadingSpinner, [props]);
	    _this.state = {
	      fading: false,
	      hidden: false
	    };
	    return _this;
	  }
	  _createClass(ClassicLoadingSpinner, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      var _this2 = this;
	      if (PAGEFLOW_EDITOR) {
	        this.setState({
	          hidden: true
	        });
	        return;
	      }
	      this.fadeTimeout = setTimeout(function () {
	        pageflow.ready.then(function () {
	          _this2.setState({
	            fading: true
	          });
	          _this2.hiddenTimeout = setTimeout(function () {
	            _this2.setState({
	              hidden: true
	            });
	          }, 1000);
	        });
	      }, 1000);
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      clearTimeout(this.fadeTimeout);
	      clearTimeout(this.hiddenTimeout);
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var editing = this.props.editing;
	      var _this$state = this.state,
	        hidden = _this$state.hidden,
	        fading = _this$state.fading;
	      if (editing || !hidden) {
	        return /*#__PURE__*/React$1__default.createElement("div", {
	          className: classnames('loading_spinner', {
	            fade: !editing && fading
	          }),
	          onTouchMove: preventScrollBouncing,
	          style: inlineStyle
	        }, /*#__PURE__*/React$1__default.createElement("div", {
	          className: "loading_inner"
	        }, /*#__PURE__*/React$1__default.createElement("div", {
	          className: "left_circle"
	        }), /*#__PURE__*/React$1__default.createElement("div", {
	          className: "right_circle"
	        }), /*#__PURE__*/React$1__default.createElement("div", {
	          className: "loading_spinner_inner"
	        }, /*#__PURE__*/React$1__default.createElement("div", null))));
	      } else {
	        return /*#__PURE__*/React$1__default.createElement("noscript", null);
	      }
	    }
	  }]);
	  return ClassicLoadingSpinner;
	}(React$1__default.Component);
	function preventScrollBouncing(e) {
	  e.preventDefault();
	}
	function register$7() {
	  registerWidgetType('classic_loading_spinner', {
	    component: connect(combine$1({
	      editing: editingWidget({
	        role: 'loading_spinner'
	      })
	    }))(ClassicLoadingSpinner)
	  });
	}

	function _callSuper$q(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var MediaLoadingSpinnerComponent = /*#__PURE__*/function (_React$Component) {
	  _inherits(MediaLoadingSpinnerComponent, _React$Component);
	  function MediaLoadingSpinnerComponent(props) {
	    var _this;
	    _classCallCheck(this, MediaLoadingSpinnerComponent);
	    _this = _callSuper$q(this, MediaLoadingSpinnerComponent, [props]);
	    _this.state = {
	      hidden: false,
	      animating: false
	    };
	    return _this;
	  }
	  _createClass(MediaLoadingSpinnerComponent, [{
	    key: "componentDidMount",
	    value: function componentDidMount() {
	      var _this2 = this;
	      if (PAGEFLOW_EDITOR) {
	        this.setState({
	          hidden: true,
	          animating: true
	        });
	      } else {
	        this.setState({
	          animating: true
	        });
	        pageflow.delayedStart.waitFor(function (resolve) {
	          _this2.resolveDelayedStart = resolve;
	        });
	      }
	    }
	  }, {
	    key: "hideOrLoop",
	    value: function hideOrLoop(el) {
	      var _this3 = this;
	      if (el.target === el.currentTarget) {
	        if (PAGEFLOW_EDITOR) {
	          this.setState({
	            animating: false
	          });
	          setTimeout(function () {
	            _this3.setState({
	              animating: true
	            });
	          }, 1000);
	        } else {
	          this.setState({
	            hidden: true
	          });
	          this.resolveDelayedStart();
	        }
	      }
	    }
	  }, {
	    key: "componentWillUnmount",
	    value: function componentWillUnmount() {
	      clearTimeout(this.hiddenTimeout);
	    }
	  }, {
	    key: "render",
	    value: function render() {
	      var _this4 = this;
	      var editing = this.props.editing;
	      var _this$state = this.state,
	        hidden = _this$state.hidden,
	        animating = _this$state.animating;
	      var invert = getInvert(this.props);
	      var logoElement = /*#__PURE__*/React$1__default.createElement("div", {
	        className: classnames("media_loading_spinner-logo", {
	          'media_loading_spinner-logo-invert': invert
	        })
	      });
	      if (this.props.removeLogo) {
	        logoElement = '';
	      }
	      if (editing || !hidden) {
	        return /*#__PURE__*/React$1__default.createElement("div", {
	          className: classnames('media_loading_spinner', {
	            'media_loading_spinner-fade': animating
	          }, {
	            'media_loading_spinner-invert': invert
	          }),
	          onAnimationEnd: function onAnimationEnd(event) {
	            return _this4.hideOrLoop(event);
	          },
	          onTouchMove: preventScrollBouncing$1,
	          style: inlineStyle$1(this.props)
	        }, logoElement, /*#__PURE__*/React$1__default.createElement("div", {
	          className: "media_loading_spinner-image",
	          style: backgroundImageInlineStyles(this.props)
	        }), this.props.children);
	      } else {
	        return /*#__PURE__*/React$1__default.createElement("noscript", null);
	      }
	    }
	  }]);
	  return MediaLoadingSpinnerComponent;
	}(React$1__default.Component);
	function preventScrollBouncing$1(e) {
	  e.preventDefault();
	}
	function backgroundImageInlineStyles(_ref) {
	  var firstPageBackgroundImageUrlMedium = _ref.firstPageBackgroundImageUrlMedium,
	    firstPageBackgroundImageUrlLarge = _ref.firstPageBackgroundImageUrlLarge,
	    backgroundImage = _ref.backgroundImage,
	    blurStrength = _ref.blurStrength,
	    backgroundImageX = _ref.backgroundImageX,
	    backgroundImageY = _ref.backgroundImageY;
	  var backgroundPosition = {
	    x: backgroundImageX != undefined ? backgroundImageX : 50,
	    y: backgroundImageY != undefined ? backgroundImageY : 50
	  };
	  var url = blurStrength === 0 ? backgroundImage ? backgroundImage.urls.large : firstPageBackgroundImageUrlLarge : backgroundImage ? backgroundImage.urls.medium : firstPageBackgroundImageUrlMedium;
	  if (url) {
	    var style = {
	      backgroundImage: "url(\"".concat(url, "\")"),
	      filter: 'blur(' + blurStrength + 'px)'
	    };
	    if (backgroundImage) {
	      style.backgroundPosition = "".concat(backgroundPosition.x, "% ").concat(backgroundPosition.y, "%");
	    }
	    return style;
	  }
	}
	function getInvert(props) {
	  if (!props.backgroundImage && props.invert == undefined) {
	    return props.firstPageInvert;
	  }
	  return props.invert;
	}
	function inlineStyle$1(props) {
	  var invert = getInvert(props);
	  var animationDelay = props.animationDuration !== undefined ? props.animationDuration + 's' : undefined;
	  return {
	    position: 'absolute',
	    top: 0,
	    left: 0,
	    width: '100%',
	    height: '100%',
	    zIndex: 100,
	    backgroundColor: invert ? '#fff' : '#000',
	    animationDelay: animationDelay
	  };
	}
	var MediaLoadingSpinner = connect(combine$1({
	  editing: editingWidget({
	    role: 'loading_spinner'
	  }),
	  firstPageInvert: firstPageAttribute('invert'),
	  firstPageBackgroundImageUrlMedium: pageBackgroundImageUrl({
	    variant: 'medium',
	    page: firstPageAttribures()
	  }),
	  firstPageBackgroundImageUrlLarge: pageBackgroundImageUrl({
	    variant: 'large',
	    page: firstPageAttribures()
	  }),
	  backgroundImage: file('imageFiles', {
	    id: widgetAttribute('customBackgroundImageId', {
	      role: 'loading_spinner'
	    })
	  }),
	  backgroundImageX: widgetAttribute('customBackgroundImageX', {
	    role: 'loading_spinner'
	  }),
	  backgroundImageY: widgetAttribute('customBackgroundImageY', {
	    role: 'loading_spinner'
	  }),
	  invert: widgetAttribute('invert', {
	    role: 'loading_spinner'
	  }),
	  removeLogo: widgetAttribute('removeLogo', {
	    role: 'loading_spinner'
	  }),
	  blurStrength: widgetAttribute('blurStrength', {
	    role: 'loading_spinner'
	  }),
	  animationDuration: widgetAttribute('animationDuration', {
	    role: 'loading_spinner'
	  })
	}))(MediaLoadingSpinnerComponent);
	function register$8() {
	  registerWidgetType('media_loading_spinner', {
	    component: MediaLoadingSpinner
	  });
	}

	function _callSuper$r(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
	var TitleLoadingSpinner = /*#__PURE__*/function (_React$Component) {
	  _inherits(TitleLoadingSpinner, _React$Component);
	  function TitleLoadingSpinner() {
	    _classCallCheck(this, TitleLoadingSpinner);
	    return _callSuper$r(this, TitleLoadingSpinner, arguments);
	  }
	  _createClass(TitleLoadingSpinner, [{
	    key: "render",
	    value: function render() {
	      var _this$props = this.props,
	        title = _this$props.title,
	        subtitle = _this$props.subtitle,
	        entryTitle = _this$props.entryTitle;
	      var invert = getInvert(this.props);
	      var animationDuration = this.props.animationDuration !== undefined ? this.props.animationDuration + 's' : undefined;
	      return /*#__PURE__*/React$1__default.createElement(MediaLoadingSpinner, null, /*#__PURE__*/React$1__default.createElement("div", {
	        className: classnames('media_loading_spinner-titles', {
	          'media_loading_spinner-invert': invert
	        }),
	        style: {
	          animationDuration: animationDuration
	        }
	      }, /*#__PURE__*/React$1__default.createElement("div", {
	        className: "media_loading_spinner-title"
	      }, title || entryTitle), /*#__PURE__*/React$1__default.createElement("div", {
	        className: "media_loading_spinner-subtitle"
	      }, subtitle)));
	    }
	  }]);
	  return TitleLoadingSpinner;
	}(React$1__default.Component);
	function register$9() {
	  registerWidgetType('title_loading_spinner', {
	    component: connect(combine$1({
	      firstPageInvert: firstPageAttribute('invert'),
	      backgroundImage: file('imageFiles', {
	        id: widgetAttribute('customBackgroundImageId', {
	          role: 'loading_spinner'
	        })
	      }),
	      entryTitle: entryAttribute('title'),
	      title: widgetAttribute('title', {
	        role: 'loading_spinner'
	      }),
	      subtitle: widgetAttribute('subtitle', {
	        role: 'loading_spinner'
	      }),
	      removeLogo: widgetAttribute('removeLogo', {
	        role: 'loading_spinner'
	      }),
	      invert: widgetAttribute('invert', {
	        role: 'loading_spinner'
	      }),
	      animationDuration: widgetAttribute('animationDuration', {
	        role: 'loading_spinner'
	      })
	    }))(TitleLoadingSpinner)
	  });
	}

	function registerWidgetTypes$3() {
	  register$7();
	  register$9();
	  register$8();
	}

	register$6();
	registerWidgetTypes$1();
	registerWidgetTypes$2();
	registerWidgetTypes();
	registerWidgetTypes$3();
	if (pageflow$1.events) {
	  pageflow$1.events.on('seed:loaded', function () {
	    return boot(pageflow$1);
	  });
	}
	var index$2 = {
	  components: _objectSpread2({
	    ConsentSettings: Settings,
	    MediaPageBackground: MediaPageBackground,
	    PageWithInteractiveBackground: PageWithInteractiveBackground$1
	  }, components),
	  actions: actions,
	  selectors: selectors,
	  registerPageType: registerPageType,
	  registerPageTypeWithDefaultBackground: registerPageTypeWithDefaultBackground,
	  registerWidgetType: registerWidgetType,
	  mediaReduxModule: reduxModule,
	  mediaPageBackgroundReduxModule: pageBackgroundReduxModule,
	  pageWithInteractiveBackgroundReduxModule: reduxModule$1,
	  iconMapping: iconMapping,
	  SvgIcon: Container$1,
	  classNames: classnames,
	  connect: connect,
	  connectInPage: connectInPage,
	  combineReducers: combineReducers,
	  combine: combine,
	  ServerSidePage: _default$2,
	  ServerSideWidget: _default$3,
	  ServerSidePageBackgroundAsset: _default$4
	};

	return index$2;

}(React, {}, {}, {}, pageflow));
