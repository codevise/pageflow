# Additional Frontend Seed Data

When developing custom content elements or widget types, you might
require additional seed data generated by the server. Plugins can
register lambdas to generate such data:

``` ruby
# app/plugins/rainbow_plugin.rb
class RainbowPlugin
  def configure(config)
    config.for_entry_type(PageflowScrolled.entry_type) do |entry_type_config|
      # ...

      entry_type_config.additional_frontend_seed_data.register(
        'rainbowColors',
        lambda do |entry:, request:, **|
          [{name: 'red'}, {name: 'blue'}, {name: 'green'}]
        end
      )
    end
  end
end
```

The entry model and the request object get passed to the lambda. The
double splat operator (`**`) in the above example makes the lambda
forwards compatible in case further options are added in the future.

The data can then be accessed in React components:

``` jsx
export function Rainbow() {
  const colors = useAdditionalSeedData('rainbowColors');

  return (
    <div>
      Colors: {colors.map(color => color.name).join(', ')}
    </div
  )
}
```

If you know, that the seed data is only ever used by content elements
of a certain type, you can make sure seed data is only generated and
rendered if content elements of a given type are present in the entry:

``` ruby
entry_type_config.additional_frontend_seed_data.register(
  'rainbowColors',
  lambda do |entry:, request:, **|
    [{name: 'red'}, {name: 'blue'}, {name: 'green'}]
  end,
  content_element_type_names: ['rainbow']
)
```

Now `rainbowColors` seed data will only be rendered for entries
containing a content element of type `rainbow`. Note that in the
editor, seed data will always be rendered since content elements
requiring the data might be added later on.
